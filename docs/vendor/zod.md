This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.github/
  workflows/
    release.yml
    test.yml
  stale.yml
.husky/
  .gitignore
  pre-commit
  pre-push
deno/
  lib/
    __tests__/
      all-errors.test.ts
      anyunknown.test.ts
      array.test.ts
      async-parsing.test.ts
      async-refinements.test.ts
      base.test.ts
      complex.test.ts
      crazySchema.ts
      deepmasking.test.ts
      default.test.ts
      description.test.ts
      discriminatedUnions.test.ts
      enum.test.ts
      error.test.ts
      firstparty.test.ts
      function.test.ts
      instanceof.test.ts
      intersection.test.ts
      map.test.ts
      masking.test.ts
      mocker.test.ts
      Mocker.ts
      nan.test.ts
      nativeEnum.test.ts
      nullable.test.ts
      number.test.ts
      object-augmentation.test.ts
      object.test.ts
      optional.test.ts
      parser.test.ts
      parseUtil.test.ts
      partials.test.ts
      pickomit.test.ts
      primitive.test.ts
      promise.test.ts
      record.test.ts
      recursive.test.ts
      refine.test.ts
      safeparse.test.ts
      set.test.ts
      string.test.ts
      transformer.test.ts
      tuple.test.ts
      unions.test.ts
      validations.test.ts
      void.test.ts
    benchmarks/
      discriminatedUnion.ts
      index.ts
      object.ts
      primitives.ts
      realworld.ts
      string.ts
      union.ts
    helpers/
      errorUtil.ts
      parseUtil.ts
      partialUtil.ts
      typeAliases.ts
      util.ts
    external.ts
    index.ts
    mod.ts
    types.ts
    ZodError.ts
  build.mjs
docs/
  index.html
  logo.svg
  README.md
src/
  __tests__/
    all-errors.test.ts
    anyunknown.test.ts
    array.test.ts
    async-parsing.test.ts
    async-refinements.test.ts
    base.test.ts
    complex.test.ts
    crazySchema.ts
    deepmasking.test.ts
    default.test.ts
    description.test.ts
    discriminatedUnions.test.ts
    enum.test.ts
    error.test.ts
    firstparty.test.ts
    function.test.ts
    instanceof.test.ts
    intersection.test.ts
    map.test.ts
    masking.test.ts
    mocker.test.ts
    Mocker.ts
    nan.test.ts
    nativeEnum.test.ts
    nullable.test.ts
    number.test.ts
    object-augmentation.test.ts
    object-in-es5-env.test.ts
    object.test.ts
    optional.test.ts
    parser.test.ts
    parseUtil.test.ts
    partials.test.ts
    pickomit.test.ts
    primitive.test.ts
    promise.test.ts
    record.test.ts
    recursive.test.ts
    refine.test.ts
    safeparse.test.ts
    set.test.ts
    string.test.ts
    transformer.test.ts
    tuple.test.ts
    unions.test.ts
    validations.test.ts
    void.test.ts
  benchmarks/
    discriminatedUnion.ts
    index.ts
    object.ts
    primitives.ts
    realworld.ts
    string.ts
    union.ts
  helpers/
    errorUtil.ts
    parseUtil.ts
    partialUtil.ts
    typeAliases.ts
    util.ts
  external.ts
  index.ts
  types.ts
  ZodError.ts
.dependency-cruiser.js
.editorconfig
.eslintrc.js
.gitignore
.prettierrc.yaml
CHANGELOG.md
CODE_OF_CONDUCT.md
CONTRIBUTING.md
ERROR_HANDLING.md
FUNDING.yml
jest.config.json
LICENSE
logo.svg
MIGRATION.md
package.json
README_ZH.md
README.md
rollup.config.js
tsconfig.base.json
tsconfig.cjs.json
tsconfig.esm.json
tsconfig.json
tsconfig.types.json
```

# Files

## File: .github/workflows/release.yml
````yaml
# .github/release.yml

name: release
on:
  push:
    branches:
      - "master"
    paths:
      - package.json

jobs:
  build_and_publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0
          submodules: true

      - name: Set up Node
        uses: actions/setup-node@v1
        with:
          node-version: 16

      - name: Install dependencies
        run: |
          yarn install

      - name: Build
        run: |
          yarn clean
          yarn build

      - id: publish
        name: Publish to NPM
        uses: JS-DevTools/npm-publish@v1
        with:
          token: ${{ secrets.NPM_TOKEN }}
          dry-run: false

      - name: Post-publish
        if: steps.publish.outputs.type != 'none'
        run: |
          echo "Published ${{ steps.publish.outputs.type }} version: ${{ steps.publish.outputs.version }}"

      - name: Publish skipped
        if: steps.publish.outputs.type == 'none'
        run: |
          echo "Version in package.json has not changed. Skipping."
          exit 0

      - name: Configure changelog
        if: steps.publish.outputs.type != 'none'
        run: |
          echo '{"categories": [], "template": "## Commits:\n\n${{ '${{UNCATEGORIZED}}' }}", "pr_template": ${{ '"- ${{MERGE_SHA}} ${{TITLE}}"' }} }' > changelog_config.json
          cat changelog_config.json
          echo "last_tag=$(git describe --tags --abbrev=0)" >> $GITHUB_ENV
          echo "curr_commit=$(git rev-parse HEAD)" >> $GITHUB_ENV

      - name: Generate changelog
        if: steps.publish.outputs.type != 'none'
        id: github_release
        uses: mikepenz/release-changelog-builder-action@v2.9.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          fromTag: "${{ env.last_tag }}"
          toTag: ${{ github.ref }}
          commitMode: true
          configuration: changelog_config.json

      - name: Create release
        if: steps.publish.outputs.type != 'none'
        id: create_release
        uses: actions/create-release@latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.publish.outputs.version }}
          release_name: v${{ steps.publish.outputs.version }}
          commitish: ${{ github.ref }}
          body: ${{steps.github_release.outputs.changelog}}
          draft: false
          prerelease: false
````

## File: .github/workflows/test.yml
````yaml
name: test

on:
  push:
    branches:
      - "master"
  pull_request:
    branches:
      - master

jobs:
  test-node:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: ["14"]
        typescript: ["4.1", "4.2", "4.3", "4.4", "4.5", "4.6"]
    name: Test with TypeScript ${{ matrix.typescript }} on Node ${{ matrix.node }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node }}
      - run: yarn install
      - run: yarn add typescript@${{ matrix.typescript }}
      - run: yarn build
      - run: yarn test


  test-deno:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        deno: ["v1.x"]
    name: Test with Deno ${{ matrix.deno }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v1
        with:
          node-version: 16
      - uses: denolib/setup-deno@v2
        with:
          deno-version: ${{ matrix.deno }}
      - run: yarn install
      - run: yarn build:deno
      - run: deno --version
      - run: deno test
        working-directory: ./deno/lib
      - run: deno run ./index.ts
        working-directory: ./deno/lib
      - run: deno run ./mod.ts
        working-directory: ./deno/lib
      - run: |
          deno bundle ./mod.ts ./bundle.js
          deno run ./bundle.js
        working-directory: ./deno/lib

  lint:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: ["14"]
    name: Lint on Node ${{ matrix.node }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node }}
      - run: yarn install
      - run: yarn prettier:check
      - run: yarn lint:check
````

## File: .github/stale.yml
````yaml
# Number of days of inactivity before an issue becomes stale
daysUntilStale: 60
# Number of days of inactivity before a stale issue is closed
daysUntilClose: 7
# Issues with these labels will never be considered stale
# exemptLabels:
#   - pinned
#   - security
# Label to use when marking an issue as stale
staleLabel: wontfix
# Comment to post when marking an issue as stale. Set to `false` to disable
markComment: >
  This issue has been automatically marked as stale because it has not had
  recent activity. It will be closed if no further activity occurs. Thank you
  for your contributions.
# Comment to post when closing a stale issue. Set to `false` to disable
closeComment: false
````

## File: .husky/.gitignore
````
_
````

## File: .husky/pre-commit
````
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npx lint-staged
yarn build:deno
git add deno
````

## File: .husky/pre-push
````
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

yarn test
````

## File: deno/lib/__tests__/all-errors.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

const Test = z.object({
  f1: z.number(),
  f2: z.string().optional(),
  f3: z.string().nullable(),
  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),
});
type TestFlattenedErrors = z.inferFlattenedErrors<
  typeof Test,
  { message: string; code: number }
>;
type TestFormErrors = z.inferFormErrors<typeof Test>;

test("default flattened errors type inference", () => {
  type TestTypeErrors = {
    formErrors: string[];
    fieldErrors: { [P in keyof z.TypeOf<typeof Test>]?: string[] | undefined };
  };

  const t1: util.AssertEqual<
    z.TypeOfFlattenedError<typeof Test>,
    TestTypeErrors
  > = true;
  const t2: util.AssertEqual<
    z.TypeOfFlattenedError<typeof Test, { message: string }>,
    TestTypeErrors
  > = false;
  [t1, t2];
});

test("custom flattened errors type inference", () => {
  type ErrorType = { message: string; code: number };
  type TestTypeErrors = {
    formErrors: ErrorType[];
    fieldErrors: {
      [P in keyof z.TypeOf<typeof Test>]?: ErrorType[] | undefined;
    };
  };

  const t1: util.AssertEqual<
    z.TypeOfFlattenedError<typeof Test>,
    TestTypeErrors
  > = false;
  const t2: util.AssertEqual<
    z.TypeOfFlattenedError<typeof Test, { message: string; code: number }>,
    TestTypeErrors
  > = true;
  const t3: util.AssertEqual<
    z.TypeOfFlattenedError<typeof Test, { message: string }>,
    TestTypeErrors
  > = false;
  [t1, t2, t3];
});

test("form errors type inference", () => {
  type TestTypeErrors = {
    formErrors: string[];
    fieldErrors: { [P in keyof z.TypeOf<typeof Test>]?: string[] | undefined };
  };

  const t1: util.AssertEqual<
    z.TypeOfFormErrors<typeof Test>,
    TestTypeErrors
  > = true;
  [t1];
});

test(".flatten() type assertion", () => {
  const parsed = Test.safeParse({}) as z.SafeParseError<void>;
  const validFlattenedErrors: TestFlattenedErrors = parsed.error.flatten(
    () => ({ message: "", code: 0 })
  );
  // @ts-expect-error should fail assertion between `TestFlattenedErrors` and unmapped `flatten()`.
  const invalidFlattenedErrors: TestFlattenedErrors = parsed.error.flatten();
  const validFormErrors: TestFormErrors = parsed.error.flatten();
  // @ts-expect-error should fail assertion between `TestFormErrors` and mapped `flatten()`.
  const invalidFormErrors: TestFormErrors = parsed.error.flatten(() => ({
    message: "string",
    code: 0,
  }));

  [
    validFlattenedErrors,
    invalidFlattenedErrors,
    validFormErrors,
    invalidFormErrors,
  ];
});

test(".formErrors type assertion", () => {
  const parsed = Test.safeParse({}) as z.SafeParseError<void>;
  const validFormErrors: TestFormErrors = parsed.error.formErrors;
  // @ts-expect-error should fail assertion between `TestFlattenedErrors` and `.formErrors`.
  const invalidFlattenedErrors: TestFlattenedErrors = parsed.error.formErrors;

  [validFormErrors, invalidFlattenedErrors];
});

test("all errors", () => {
  const propertySchema = z.string();
  const schema = z
    .object({
      a: propertySchema,
      b: propertySchema,
    })
    .refine(
      (val) => {
        return val.a === val.b;
      },
      { message: "Must be equal" }
    );

  try {
    schema.parse({
      a: "asdf",
      b: "qwer",
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      expect(error.flatten()).toEqual({
        formErrors: ["Must be equal"],
        fieldErrors: {},
      });
    }
  }

  try {
    schema.parse({
      a: null,
      b: null,
    });
  } catch (_error) {
    const error = _error as z.ZodError;
    expect(error.flatten()).toEqual({
      formErrors: [],
      fieldErrors: {
        a: ["Expected string, received null"],
        b: ["Expected string, received null"],
      },
    });

    expect(error.flatten((iss) => iss.message.toUpperCase())).toEqual({
      formErrors: [],
      fieldErrors: {
        a: ["EXPECTED STRING, RECEIVED NULL"],
        b: ["EXPECTED STRING, RECEIVED NULL"],
      },
    });
    // Test identity

    expect(error.flatten((i: z.ZodIssue) => i)).toEqual({
      formErrors: [],
      fieldErrors: {
        a: [
          {
            code: "invalid_type",
            expected: "string",
            message: "Expected string, received null",
            path: ["a"],
            received: "null",
          },
        ],
        b: [
          {
            code: "invalid_type",
            expected: "string",
            message: "Expected string, received null",
            path: ["b"],
            received: "null",
          },
        ],
      },
    });
    // Test mapping
    expect(error.flatten((i: z.ZodIssue) => i.message.length)).toEqual({
      formErrors: [],
      fieldErrors: {
        a: ["Expected string, received null".length],
        b: ["Expected string, received null".length],
      },
    });
  }
});
````

## File: deno/lib/__tests__/anyunknown.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

test("check any inference", () => {
  const t1 = z.any();
  t1.optional();
  t1.nullable();
  type t1 = z.infer<typeof t1>;
  const f1: util.AssertEqual<t1, any> = true;
  expect(f1).toBeTruthy();
});

test("check unknown inference", () => {
  const t1 = z.unknown();
  t1.optional();
  t1.nullable();
  type t1 = z.infer<typeof t1>;
  const f1: util.AssertEqual<t1, unknown> = true;
  expect(f1).toBeTruthy();
});

test("check never inference", () => {
  const t1 = z.never();
  expect(() => t1.parse(undefined)).toThrow();
  expect(() => t1.parse("asdf")).toThrow();
  expect(() => t1.parse(null)).toThrow();
});
````

## File: deno/lib/__tests__/array.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

const minTwo = z.string().array().min(2);
const maxTwo = z.string().array().max(2);
const justTwo = z.string().array().length(2);
const intNum = z.string().array().nonempty();
const nonEmptyMax = z.string().array().nonempty().max(2);

type t1 = z.infer<typeof nonEmptyMax>;
const f1: util.AssertEqual<[string, ...string[]], t1> = true;
f1;
type t2 = z.infer<typeof minTwo>;
const f2: util.AssertEqual<string[], t2> = true;
f2;

test("passing validations", () => {
  minTwo.parse(["a", "a"]);
  minTwo.parse(["a", "a", "a"]);
  maxTwo.parse(["a", "a"]);
  maxTwo.parse(["a"]);
  justTwo.parse(["a", "a"]);
  intNum.parse(["a"]);
  nonEmptyMax.parse(["a"]);
});

test("failing validations", () => {
  expect(() => minTwo.parse(["a"])).toThrow();
  expect(() => maxTwo.parse(["a", "a", "a"])).toThrow();
  expect(() => justTwo.parse(["a"])).toThrow();
  expect(() => justTwo.parse(["a", "a", "a"])).toThrow();
  expect(() => intNum.parse([])).toThrow();
  expect(() => nonEmptyMax.parse([])).toThrow();
  expect(() => nonEmptyMax.parse(["a", "a", "a"])).toThrow();
});

test("parse empty array in nonempty", () => {
  expect(() =>
    z
      .array(z.string())
      .nonempty()
      .parse([] as any)
  ).toThrow();
});

test("get element", () => {
  justTwo.element.parse("asdf");
  expect(() => justTwo.element.parse(12)).toThrow();
});

test("continue parsing despite array size error", () => {
  const schema = z.object({
    people: z.string().array().min(2),
  });

  const result = schema.safeParse({
    people: [123],
  });
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues.length).toEqual(2);
  }
});
````

## File: deno/lib/__tests__/async-parsing.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

/// string
const stringSchema = z.string();

test("string async parse", async () => {
  const goodData = "XXX";
  const badData = 12;

  const goodResult = await stringSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await stringSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// number
const numberSchema = z.number();
test("number async parse", async () => {
  const goodData = 1234.2353;
  const badData = "1234";

  const goodResult = await numberSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await numberSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// bigInt
const bigIntSchema = z.bigint();
test("bigInt async parse", async () => {
  const goodData = BigInt(145);
  const badData = 134;

  const goodResult = await bigIntSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await bigIntSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// boolean
const booleanSchema = z.boolean();
test("boolean async parse", async () => {
  const goodData = true;
  const badData = 1;

  const goodResult = await booleanSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await booleanSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// date
const dateSchema = z.date();
test("date async parse", async () => {
  const goodData = new Date();
  const badData = new Date().toISOString();

  const goodResult = await dateSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await dateSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// undefined
const undefinedSchema = z.undefined();
test("undefined async parse", async () => {
  const goodData = undefined;
  const badData = "XXX";

  const goodResult = await undefinedSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(undefined);

  const badResult = await undefinedSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// null
const nullSchema = z.null();
test("null async parse", async () => {
  const goodData = null;
  const badData = undefined;

  const goodResult = await nullSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await nullSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// any
const anySchema = z.any();
test("any async parse", async () => {
  const goodData = [{}];
  // const badData = 'XXX';

  const goodResult = await anySchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  // const badResult = await anySchema.safeParseAsync(badData);
  // expect(badResult.success).toBe(false);
  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// unknown
const unknownSchema = z.unknown();
test("unknown async parse", async () => {
  const goodData = ["asdf", 124, () => {}];
  // const badData = 'XXX';

  const goodResult = await unknownSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  // const badResult = await unknownSchema.safeParseAsync(badData);
  // expect(badResult.success).toBe(false);
  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// void
const voidSchema = z.void();
test("void async parse", async () => {
  const goodData = undefined;
  const badData = 0;

  const goodResult = await voidSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await voidSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// array
const arraySchema = z.array(z.string());
test("array async parse", async () => {
  const goodData = ["XXX"];
  const badData = "XXX";

  const goodResult = await arraySchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await arraySchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// object
const objectSchema = z.object({ string: z.string() });
test("object async parse", async () => {
  const goodData = { string: "XXX" };
  const badData = { string: 12 };

  const goodResult = await objectSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await objectSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// union
const unionSchema = z.union([z.string(), z.undefined()]);
test("union async parse", async () => {
  const goodData = undefined;
  const badData = null;

  const goodResult = await unionSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await unionSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// record
const recordSchema = z.record(z.object({}));
test("record async parse", async () => {
  const goodData = { adsf: {}, asdf: {} };
  const badData = [{}];

  const goodResult = await recordSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await recordSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// function
const functionSchema = z.function();
test("function async parse", async () => {
  const goodData = () => {};
  const badData = "XXX";

  const goodResult = await functionSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(typeof goodResult.data).toEqual("function");

  const badResult = await functionSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// literal
const literalSchema = z.literal("asdf");
test("literal async parse", async () => {
  const goodData = "asdf";
  const badData = "asdff";

  const goodResult = await literalSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await literalSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// enum
const enumSchema = z.enum(["fish", "whale"]);
test("enum async parse", async () => {
  const goodData = "whale";
  const badData = "leopard";

  const goodResult = await enumSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await enumSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// nativeEnum
enum nativeEnumTest {
  asdf = "qwer",
}
// @ts-ignore
const nativeEnumSchema = z.nativeEnum(nativeEnumTest);
test("nativeEnum async parse", async () => {
  const goodData = nativeEnumTest.asdf;
  const badData = "asdf";

  const goodResult = await nativeEnumSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await nativeEnumSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// promise
const promiseSchema = z.promise(z.number());
test("promise async parse good", async () => {
  const goodData = Promise.resolve(123);

  const goodResult = await promiseSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) {
    expect(goodResult.data).toBeInstanceOf(Promise);
    const data = await goodResult.data;
    expect(data).toEqual(123);
    // expect(goodResult.data).resolves.toEqual(124);
    // return goodResult.data;
  } else {
    throw new Error("success should be true");
  }
});

test("promise async parse bad", async () => {
  const badData = Promise.resolve("XXX");
  const badResult = await promiseSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(true);
  if (badResult.success) {
    await expect(badResult.data).rejects.toBeInstanceOf(z.ZodError);
  } else {
    throw new Error("success should be true");
  }
});

test("async validation non-empty strings", async () => {
  const base = z.object({
    hello: z.string().refine((x) => x && x.length > 0),
    foo: z.string().refine((x) => x && x.length > 0),
  });

  const testval = { hello: "", foo: "" };
  const result1 = base.safeParse(testval);
  const result2 = base.safeParseAsync(testval);

  const r1 = result1;
  await result2.then((r2) => {
    if (r1.success === false && r2.success === false)
      expect(r1.error.issues.length).toBe(r2.error.issues.length); // <--- r1 has length 2, r2 has length 1
  });
});

test("async validation multiple errors 1", async () => {
  const base = z.object({
    hello: z.string(),
    foo: z.number(),
  });

  const testval = { hello: 3, foo: "hello" };
  const result1 = base.safeParse(testval);
  const result2 = base.safeParseAsync(testval);

  const r1 = result1;
  await result2.then((r2) => {
    if (r1.success === false && r2.success === false)
      expect(r2.error.issues.length).toBe(r1.error.issues.length);
  });
});

test("async validation multiple errors 2", async () => {
  const base = (is_async?: boolean) =>
    z.object({
      hello: z.string(),
      foo: z.object({
        bar: z.number().refine(is_async ? async () => false : () => false),
      }),
    });

  const testval = { hello: 3, foo: { bar: 4 } };
  const result1 = base().safeParse(testval);
  const result2 = base(true).safeParseAsync(testval);

  const r1 = result1;
  await result2.then((r2) => {
    if (r1.success === false && r2.success === false)
      expect(r2.error.issues.length).toBe(r1.error.issues.length);
  });
});

test("ensure early async failure prevents follow-up refinement checks", async () => {
  let count = 0;
  const base = z.object({
    hello: z.string(),
    foo: z
      .number()
      .refine(async () => {
        count++;
        return true;
      })
      .refine(async () => {
        count++;
        return true;
      }, "Good"),
  });

  const testval = { hello: "bye", foo: 3 };
  const result = await base.safeParseAsync(testval);
  if (result.success === false) {
    expect(result.error.issues.length).toBe(1);
    expect(count).toBe(1);
  }

  // await result.then((r) => {
  //   if (r.success === false) expect(r.error.issues.length).toBe(1);
  //   expect(count).toBe(2);
  // });
});
````

## File: deno/lib/__tests__/async-refinements.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

test("parse async test", async () => {
  const schema1 = z.string().refine(async (_val) => false);
  expect(() => schema1.parse("asdf")).toThrow();

  const schema2 = z.string().refine((_val) => Promise.resolve(true));
  return await expect(() => schema2.parse("asdf")).toThrow();
});

test("parseAsync async test", async () => {
  const schema1 = z.string().refine(async (_val) => true);
  await schema1.parseAsync("asdf");

  const schema2 = z.string().refine(async (_val) => false);
  return await expect(schema2.parseAsync("asdf")).rejects.toBeDefined();
  // expect(async () => await schema2.parseAsync('asdf')).toThrow();
});

test("parseAsync async test", async () => {
  // expect.assertions(2);

  const schema1 = z.string().refine((_val) => Promise.resolve(true));
  const v1 = await schema1.parseAsync("asdf");
  expect(v1).toEqual("asdf");

  const schema2 = z.string().refine((_val) => Promise.resolve(false));
  await expect(schema2.parseAsync("asdf")).rejects.toBeDefined();

  const schema3 = z.string().refine((_val) => Promise.resolve(true));
  await expect(schema3.parseAsync("asdf")).resolves.toEqual("asdf");
  return await expect(schema3.parseAsync("qwer")).resolves.toEqual("qwer");
});

test("parseAsync async with value", async () => {
  const schema1 = z.string().refine(async (val) => {
    return val.length > 5;
  });
  await expect(schema1.parseAsync("asdf")).rejects.toBeDefined();

  const v = await schema1.parseAsync("asdf123");
  return await expect(v).toEqual("asdf123");
});
````

## File: deno/lib/__tests__/base.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

test("type guard", () => {
  const stringToNumber = z.string().transform((arg) => arg.length);

  const s1 = z.object({
    stringToNumber,
  });
  type t1 = z.input<typeof s1>;

  const data: any = "asdf";
  const parsed = s1.safeParse(data);
  if (parsed.success) {
    const f1: util.AssertEqual<typeof data, t1> = true;
    f1;
  }
});

test("test this binding", () => {
  const callback = (predicate: (val: string) => boolean) => {
    return predicate("hello");
  };

  expect(callback((value) => z.string().safeParse(value).success)).toBe(true); // true
  expect(callback((value) => z.string().safeParse(value).success)).toBe(true); // true
});
````

## File: deno/lib/__tests__/complex.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { crazySchema } from "./crazySchema.ts";
// import * as z from "../index";

test("parse", () => {
  crazySchema.parse({
    tuple: ["asdf", 1234, true, null, undefined, "1234"],
    merged: { k1: "asdf", k2: 12 },
    union: ["asdf", 12, "asdf", 12, "asdf", 12],
    array: [12, 15, 16],
    // sumTransformer: [12, 15, 16],
    sumMinLength: [12, 15, 16, 98, 24, 63],
    intersection: {},
    enum: "one",
    nonstrict: { points: 1234 },
    numProm: Promise.resolve(12),
    lenfun: (x: string) => x.length,
  });
});
````

## File: deno/lib/__tests__/crazySchema.ts
````typescript
import * as z from "../index.ts";

export const crazySchema = z.object({
  tuple: z.tuple([
    z.string().nullable().optional(),
    z.number().nullable().optional(),
    z.boolean().nullable().optional(),
    z.null().nullable().optional(),
    z.undefined().nullable().optional(),
    z.literal("1234").nullable().optional(),
  ]),
  merged: z
    .object({
      k1: z.string().optional(),
    })
    .merge(z.object({ k1: z.string().nullable(), k2: z.number() })),
  union: z.array(z.union([z.literal("asdf"), z.literal(12)])).nonempty(),
  array: z.array(z.number()),
  // sumTransformer: z.transformer(z.array(z.number()), z.number(), (arg) => {
  //   return arg.reduce((a, b) => a + b, 0);
  // }),
  sumMinLength: z.array(z.number()).refine((arg) => arg.length > 5),
  intersection: z.intersection(
    z.object({ p1: z.string().optional() }),
    z.object({ p1: z.number().optional() })
  ),
  enum: z.intersection(z.enum(["zero", "one"]), z.enum(["one", "two"])),
  nonstrict: z.object({ points: z.number() }).nonstrict(),
  numProm: z.promise(z.number()),
  lenfun: z.function(z.tuple([z.string()]), z.boolean()),
});

export const asyncCrazySchema = crazySchema.extend({
  // async_transform: z.transformer(
  //   z.array(z.number()),
  //   z.number(),
  //   async (arg) => {
  //     return arg.reduce((a, b) => a + b, 0);
  //   }
  // ),
  async_refine: z.array(z.number()).refine(async (arg) => arg.length > 5),
});
````

## File: deno/lib/__tests__/deepmasking.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

test("test", () => {
  z;
});

// const fish = z.object({
//   name: z.string(),
//   props: z.object({
//     color: z.string(),
//     numScales: z.number(),
//   }),
// });

// const nonStrict = z
//   .object({
//     name: z.string(),
//     color: z.string(),
//   })
//   .nonstrict();

// test('object pick type', () => {
//   const modNonStrictFish = nonStrict.omit({ name: true });
//   modNonStrictFish.parse({ color: 'asdf' });

//   const bad1 = () => fish.pick({ props: { unknown: true } } as any);
//   const bad2 = () => fish.omit({ name: true, props: { unknown: true } } as any);

//   expect(bad1).toThrow();
//   expect(bad2).toThrow();
// });

// test('f1', () => {
//   const f1 = fish.pick(true);
//   f1.parse({ name: 'a', props: { color: 'b', numScales: 3 } });
// });
// test('f2', () => {
//   const f2 = fish.pick({ props: true });
//   f2.parse({ props: { color: 'asdf', numScales: 1 } });
//   const badcheck2 = () => f2.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);
//   expect(badcheck2).toThrow();
// });
// test('f3', () => {
//   const f3 = fish.pick({ props: { color: true } });
//   f3.parse({ props: { color: 'b' } });
//   const badcheck3 = () => f3.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);
//   expect(badcheck3).toThrow();
// });
// test('f4', () => {
//   const badcheck4 = () => fish.pick({ props: { color: true, unknown: true } });
//   expect(badcheck4).toThrow();
// });
// test('f6', () => {
//   const f6 = fish.omit({ props: true });
//   const badcheck6 = () => f6.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);
//   f6.parse({ name: 'adsf' });
//   expect(badcheck6).toThrow();
// });
// test('f7', () => {
//   const f7 = fish.omit({ props: { color: true } });
//   f7.parse({ name: 'a', props: { numScales: 3 } });
//   const badcheck7 = () => f7.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);
//   expect(badcheck7).toThrow();
// });
// test('f8', () => {
//   const badcheck8 = () => fish.omit({ props: { color: true, unknown: true } });
//   expect(badcheck8).toThrow();
// });
// test('f9', () => {
//   const f9 = nonStrict.pick(true);
//   f9.parse({ name: 'a', color: 'asdf' });
// });
// test('f10', () => {
//   const f10 = nonStrict.pick({ name: true });
//   f10.parse({ name: 'a' });
//   const val = f10.parse({ name: 'a', color: 'b' });
//   expect(val).toEqual({ name: 'a' });
// });
// test('f12', () => {
//   const badfcheck12 = () => nonStrict.omit({ color: true, asdf: true });
//   expect(badfcheck12).toThrow();
// });

// test('array masking', () => {
//   const fishArray = z.array(fish);
//   const modFishArray = fishArray.pick({
//     name: true,
//     props: {
//       numScales: true,
//     },
//   });

//   modFishArray.parse([{ name: 'fish', props: { numScales: 12 } }]);
//   const bad1 = () => modFishArray.parse([{ name: 'fish', props: { numScales: 12, color: 'asdf' } }] as any);
//   expect(bad1).toThrow();
// });

// test('array masking', () => {
//   const fishArray = z.array(fish);
//   const fail = () =>
//     fishArray.pick({
//       name: true,
//       props: {
//         whatever: true,
//       },
//     } as any);
//   expect(fail).toThrow();
// });

// test('array masking', () => {
//   const fishArray = z.array(fish);
//   const fail = () =>
//     fishArray.omit({
//       whateve: true,
//     } as any);
//   expect(fail).toThrow();
// });

// test('array masking', () => {
//   const fishArray = z.array(fish);
//   const modFishList = fishArray.omit({
//     name: true,
//     props: {
//       color: true,
//     },
//   });

//   modFishList.parse([{ props: { numScales: 12 } }]);
//   const fail = () => modFishList.parse([{ name: 'hello', props: { numScales: 12 } }] as any);
//   expect(fail).toThrow();
// });

// test('primitive array masking', () => {
//   const fishArray = z.array(z.number());
//   const fail = () => fishArray.pick({} as any);
//   expect(fail).toThrow();
// });

// test('other array masking', () => {
//   const fishArray = z.array(z.array(z.number()));
//   const fail = () => fishArray.pick({} as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #1', () => {
//   const fail = () => fish.pick(1 as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #2', () => {
//   const fail = () => fish.pick([] as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #3', () => {
//   const fail = () => fish.pick(false as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #4', () => {
//   const fail = () => fish.pick('asdf' as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #5', () => {
//   const fail = () => fish.omit(1 as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #6', () => {
//   const fail = () => fish.omit([] as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #7', () => {
//   const fail = () => fish.omit(false as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #8', () => {
//   const fail = () => fish.omit('asdf' as any);
//   expect(fail).toThrow();
// });
````

## File: deno/lib/__tests__/default.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { z } from "../index.ts";
import { util } from "../helpers/util.ts";

test("basic defaults", () => {
  expect(z.string().default("default").parse(undefined)).toBe("default");
});

test("default with transform", () => {
  const stringWithDefault = z
    .string()
    .transform((val) => val.toUpperCase())
    .default("default");
  expect(stringWithDefault.parse(undefined)).toBe("DEFAULT");
  expect(stringWithDefault).toBeInstanceOf(z.ZodDefault);
  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodEffects);
  expect(stringWithDefault._def.innerType._def.schema).toBeInstanceOf(
    z.ZodSchema
  );

  type inp = z.input<typeof stringWithDefault>;
  const f1: util.AssertEqual<inp, string | undefined> = true;
  type out = z.output<typeof stringWithDefault>;
  const f2: util.AssertEqual<out, string> = true;
  f1;
  f2;
});

test("default on existing optional", () => {
  const stringWithDefault = z.string().optional().default("asdf");
  expect(stringWithDefault.parse(undefined)).toBe("asdf");
  expect(stringWithDefault).toBeInstanceOf(z.ZodDefault);
  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodOptional);
  expect(stringWithDefault._def.innerType._def.innerType).toBeInstanceOf(
    z.ZodString
  );

  type inp = z.input<typeof stringWithDefault>;
  const f1: util.AssertEqual<inp, string | undefined> = true;
  type out = z.output<typeof stringWithDefault>;
  const f2: util.AssertEqual<out, string> = true;
  f1;
  f2;
});

test("optional on default", () => {
  const stringWithDefault = z.string().default("asdf").optional();

  type inp = z.input<typeof stringWithDefault>;
  const f1: util.AssertEqual<inp, string | undefined> = true;
  type out = z.output<typeof stringWithDefault>;
  const f2: util.AssertEqual<out, string | undefined> = true;
  f1;
  f2;
});

test("complex chain example", () => {
  const complex = z
    .string()
    .default("asdf")
    .transform((val) => val.toUpperCase())
    .default("qwer")
    .removeDefault()
    .optional()
    .default("asdfasdf");

  expect(complex.parse(undefined)).toBe("ASDFASDF");
});

test("removeDefault", () => {
  const stringWithRemovedDefault = z.string().default("asdf").removeDefault();

  type out = z.output<typeof stringWithRemovedDefault>;
  const f2: util.AssertEqual<out, string> = true;
  f2;
});

test("nested", () => {
  const inner = z.string().default("asdf");
  const outer = z.object({ inner }).default({
    inner: undefined,
  });
  type input = z.input<typeof outer>;
  const f1: util.AssertEqual<
    input,
    { inner?: string | undefined } | undefined
  > = true;
  type out = z.output<typeof outer>;
  const f2: util.AssertEqual<out, { inner: string }> = true;
  f1;
  f2;
  expect(outer.parse(undefined)).toEqual({ inner: "asdf" });
  expect(outer.parse({})).toEqual({ inner: "asdf" });
  expect(outer.parse({ inner: undefined })).toEqual({ inner: "asdf" });
});

test("chained defaults", () => {
  const stringWithDefault = z.string().default("inner").default("outer");
  const result = stringWithDefault.parse(undefined);
  expect(result).toEqual("outer");
});

test("factory", () => {
  z.ZodDefault.create(z.string()).parse(undefined);
});
````

## File: deno/lib/__tests__/description.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

test("description", () => {
  const schema: any = z.string();
  const DESC = "asdlfkjasdf";
  expect(schema.describe(DESC).description).toEqual(DESC);
});
````

## File: deno/lib/__tests__/discriminatedUnions.test.ts
````typescript
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

test("valid", () => {
  expect(
    z
      .discriminatedUnion("type", [
        z.object({ type: z.literal("a"), a: z.string() }),
        z.object({ type: z.literal("b"), b: z.string() }),
      ])
      .parse({ type: "a", a: "abc" })
  ).toEqual({ type: "a", a: "abc" });
});

test("valid - discriminator value of various primitive types", () => {
  const schema = z.discriminatedUnion("type", [
    z.object({ type: z.literal("1"), val: z.literal(1) }),
    z.object({ type: z.literal(1), val: z.literal(2) }),
    z.object({ type: z.literal(BigInt(1)), val: z.literal(3) }),
    z.object({ type: z.literal("true"), val: z.literal(4) }),
    z.object({ type: z.literal(true), val: z.literal(5) }),
    z.object({ type: z.literal("null"), val: z.literal(6) }),
    z.object({ type: z.literal(null), val: z.literal(7) }),
    z.object({ type: z.literal("undefined"), val: z.literal(8) }),
    z.object({ type: z.literal(undefined), val: z.literal(9) }),
  ]);

  expect(schema.parse({ type: "1", val: 1 })).toEqual({ type: "1", val: 1 });
  expect(schema.parse({ type: 1, val: 2 })).toEqual({ type: 1, val: 2 });
  expect(schema.parse({ type: BigInt(1), val: 3 })).toEqual({
    type: BigInt(1),
    val: 3,
  });
  expect(schema.parse({ type: "true", val: 4 })).toEqual({
    type: "true",
    val: 4,
  });
  expect(schema.parse({ type: true, val: 5 })).toEqual({
    type: true,
    val: 5,
  });
  expect(schema.parse({ type: "null", val: 6 })).toEqual({
    type: "null",
    val: 6,
  });
  expect(schema.parse({ type: null, val: 7 })).toEqual({
    type: null,
    val: 7,
  });
  expect(schema.parse({ type: "undefined", val: 8 })).toEqual({
    type: "undefined",
    val: 8,
  });
  expect(schema.parse({ type: undefined, val: 9 })).toEqual({
    type: undefined,
    val: 9,
  });
});

test("invalid - null", () => {
  try {
    z.discriminatedUnion("type", [
      z.object({ type: z.literal("a"), a: z.string() }),
      z.object({ type: z.literal("b"), b: z.string() }),
    ]).parse(null);
    throw new Error();
  } catch (e: any) {
    expect(JSON.parse(e.message)).toEqual([
      {
        code: z.ZodIssueCode.invalid_type,
        expected: z.ZodParsedType.object,
        message: "Expected object, received null",
        received: z.ZodParsedType.null,
        path: [],
      },
    ]);
  }
});

test("invalid discriminator value", () => {
  try {
    z.discriminatedUnion("type", [
      z.object({ type: z.literal("a"), a: z.string() }),
      z.object({ type: z.literal("b"), b: z.string() }),
    ]).parse({ type: "x", a: "abc" });
    throw new Error();
  } catch (e: any) {
    expect(JSON.parse(e.message)).toEqual([
      {
        code: z.ZodIssueCode.invalid_union_discriminator,
        options: ["a", "b"],
        message: "Invalid discriminator value. Expected 'a' | 'b'",
        path: ["type"],
      },
    ]);
  }
});

test("valid discriminator value, invalid data", () => {
  try {
    z.discriminatedUnion("type", [
      z.object({ type: z.literal("a"), a: z.string() }),
      z.object({ type: z.literal("b"), b: z.string() }),
    ]).parse({ type: "a", b: "abc" });
    throw new Error();
  } catch (e: any) {
    expect(JSON.parse(e.message)).toEqual([
      {
        code: z.ZodIssueCode.invalid_type,
        expected: z.ZodParsedType.string,
        message: "Required",
        path: ["a"],
        received: z.ZodParsedType.undefined,
      },
    ]);
  }
});

test("wrong schema - missing discriminator", () => {
  try {
    z.discriminatedUnion("type", [
      z.object({ type: z.literal("a"), a: z.string() }),
      z.object({ b: z.string() }) as any,
    ]);
    throw new Error();
  } catch (e: any) {
    expect(e.message).toEqual(
      "The discriminator value could not be extracted from all the provided schemas"
    );
  }
});

test("wrong schema - duplicate discriminator values", () => {
  try {
    z.discriminatedUnion("type", [
      z.object({ type: z.literal("a"), a: z.string() }),
      z.object({ type: z.literal("a"), b: z.string() }),
    ]);
    throw new Error();
  } catch (e: any) {
    expect(e.message).toEqual(
      "Some of the discriminator values are not unique"
    );
  }
});

test("async - valid", async () => {
  expect(
    await z
      .discriminatedUnion("type", [
        z.object({
          type: z.literal("a"),
          a: z
            .string()
            .refine(async () => true)
            .transform(async (val) => Number(val)),
        }),
        z.object({
          type: z.literal("b"),
          b: z.string(),
        }),
      ])
      .parseAsync({ type: "a", a: "1" })
  ).toEqual({ type: "a", a: 1 });
});

test("async - invalid", async () => {
  try {
    await z
      .discriminatedUnion("type", [
        z.object({
          type: z.literal("a"),
          a: z
            .string()
            .refine(async () => true)
            .transform(async (val) => val),
        }),
        z.object({
          type: z.literal("b"),
          b: z.string(),
        }),
      ])
      .parseAsync({ type: "a", a: 1 });
    throw new Error();
  } catch (e: any) {
    expect(JSON.parse(e.message)).toEqual([
      {
        code: "invalid_type",
        expected: "string",
        received: "number",
        path: ["a"],
        message: "Expected string, received number",
      },
    ]);
  }
});
````

## File: deno/lib/__tests__/enum.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

test("create enum", () => {
  const MyEnum = z.enum(["Red", "Green", "Blue"]);
  expect(MyEnum.Values.Red).toEqual("Red");
  expect(MyEnum.Enum.Red).toEqual("Red");
  expect(MyEnum.enum.Red).toEqual("Red");
});

test("infer enum", () => {
  const MyEnum = z.enum(["Red", "Green", "Blue"]);
  type MyEnum = z.infer<typeof MyEnum>;
  const t1: util.AssertEqual<MyEnum, "Red" | "Green" | "Blue"> = true;
  [t1];
});

test("get options", () => {
  expect(z.enum(["tuna", "trout"]).options).toEqual(["tuna", "trout"]);
});

test("readonly enum", () => {
  const HTTP_SUCCESS = ["200", "201"] as const;
  const arg = z.enum(HTTP_SUCCESS);
  type arg = z.infer<typeof arg>;
  const f1: util.AssertEqual<arg, "200" | "201"> = true;
  f1;
  arg.parse("201");
  expect(() => arg.parse("202")).toThrow();
});
````

## File: deno/lib/__tests__/error.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { ZodParsedType } from "../helpers/parseUtil.ts";
import * as z from "../index.ts";
import { ZodError, ZodIssueCode } from "../ZodError.ts";

test("error creation", () => {
  const err1 = ZodError.create([]);
  err1.addIssue({
    code: ZodIssueCode.invalid_type,
    expected: ZodParsedType.object,
    received: ZodParsedType.string,
    path: [],
    message: "",
  });
  err1.isEmpty;

  const err2 = ZodError.create(err1.issues);
  const err3 = new ZodError([]);
  err3.addIssues(err1.issues);
  err3.addIssue(err1.issues[0]);
  err1.message;
  err2.message;
  err3.message;
});

const errorMap: z.ZodErrorMap = (error, ctx) => {
  if (error.code === ZodIssueCode.invalid_type) {
    if (error.expected === "string") {
      return { message: "bad type!" };
    }
  }
  if (error.code === ZodIssueCode.custom) {
    return { message: `less-than-${(error.params || {}).minimum}` };
  }
  return { message: ctx.defaultError };
};

test("type error with custom error map", () => {
  try {
    z.string().parse(234, { errorMap });
  } catch (err) {
    const zerr: z.ZodError = err as any;

    expect(zerr.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);
    expect(zerr.issues[0].message).toEqual(`bad type!`);
  }
});

test("refinement fail with params", () => {
  try {
    z.number()
      .refine((val) => val >= 3, {
        params: { minimum: 3 },
      })
      .parse(2, { errorMap });
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues[0].code).toEqual(z.ZodIssueCode.custom);
    expect(zerr.issues[0].message).toEqual(`less-than-3`);
  }
});

test("custom error with custom errormap", () => {
  try {
    z.string()
      .refine((val) => val.length > 12, {
        params: { minimum: 13 },
        message: "override",
      })
      .parse("asdf", { errorMap });
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues[0].message).toEqual("override");
  }
});

test("default error message", () => {
  try {
    z.number()
      .refine((x) => x > 3)
      .parse(2);
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues.length).toEqual(1);
    expect(zerr.issues[0].message).toEqual("Invalid input");
  }
});

test("override error in refine", () => {
  try {
    z.number()
      .refine((x) => x > 3, "override")
      .parse(2);
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues.length).toEqual(1);
    expect(zerr.issues[0].message).toEqual("override");
  }
});

test("override error in refinement", () => {
  try {
    z.number()
      .refine((x) => x > 3, {
        message: "override",
      })
      .parse(2);
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues.length).toEqual(1);
    expect(zerr.issues[0].message).toEqual("override");
  }
});

test("array minimum", () => {
  try {
    z.array(z.string()).min(3, "tooshort").parse(["asdf", "qwer"]);
  } catch (err) {
    const zerr: ZodError = err as any;
    expect(zerr.issues[0].code).toEqual(ZodIssueCode.too_small);
    expect(zerr.issues[0].message).toEqual("tooshort");
  }
  try {
    z.array(z.string()).min(3).parse(["asdf", "qwer"]);
  } catch (err) {
    const zerr: ZodError = err as any;
    expect(zerr.issues[0].code).toEqual(ZodIssueCode.too_small);
    expect(zerr.issues[0].message).toEqual(
      `Array must contain at least 3 element(s)`
    );
  }
});

// implement test for semi-smart union logic that checks for type error on either left or right
// test("union smart errors", () => {
//   // expect.assertions(2);

//   const p1 = z
//     .union([z.string(), z.number().refine((x) => x > 0)])
//     .safeParse(-3.2);

//   if (p1.success === true) throw new Error();
//   expect(p1.success).toBe(false);
//   expect(p1.error.issues[0].code).toEqual(ZodIssueCode.custom);

//   const p2 = z.union([z.string(), z.number()]).safeParse(false);
//   // .catch(err => expect(err.issues[0].code).toEqual(ZodIssueCode.invalid_union));
//   if (p2.success === true) throw new Error();
//   expect(p2.success).toBe(false);
//   expect(p2.error.issues[0].code).toEqual(ZodIssueCode.invalid_union);
// });

test("custom path in custom error map", () => {
  const schema = z.object({
    items: z.array(z.string()).refine((data) => data.length > 3, {
      path: ["items-too-few"],
    }),
  });

  const errorMap: z.ZodErrorMap = (error) => {
    expect(error.path.length).toBe(2);
    return { message: "doesnt matter" };
  };
  const result = schema.safeParse({ items: ["first"] }, { errorMap });
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].path).toEqual(["items", "items-too-few"]);
  }
});

test("error metadata from value", () => {
  const dynamicRefine = z.string().refine(
    (val) => val === val.toUpperCase(),
    (val) => ({ params: { val } })
  );

  const result = dynamicRefine.safeParse("asdf");
  expect(result.success).toEqual(false);
  if (!result.success) {
    const sub = result.error.issues[0];
    expect(result.error.issues[0].code).toEqual("custom");
    if (sub.code === "custom") {
      expect(sub.params!.val).toEqual("asdf");
    }
  }
});

// test("don't call refine after validation failed", () => {
//   const asdf = z
//     .union([
//       z.number(),
//       z.string().transform(z.number(), (val) => {
//         return parseFloat(val);
//       }),
//     ])
//     .refine((v) => v >= 1);

//   expect(() => asdf.safeParse("foo")).not.toThrow();
// });

test("root level formatting", () => {
  const schema = z.string().email();
  const result = schema.safeParse("asdfsdf");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.format()._errors).toEqual(["Invalid email"]);
  }
});

test("custom path", () => {
  const schema = z
    .object({
      password: z.string(),
      confirm: z.string(),
    })
    .refine((val) => val.confirm === val.password, { path: ["confirm"] });

  const result = schema.safeParse({
    password: "peanuts",
    confirm: "qeanuts",
  });

  expect(result.success).toEqual(false);
  if (!result.success) {
    // nested errors
    const error = result.error.format();
    expect(error._errors).toEqual([]);
    expect(error.password?._errors).toEqual(undefined);
    expect(error.confirm?._errors).toEqual(["Invalid input"]);
  }
});

test("custom path", () => {
  const schema = z
    .object({
      password: z.string().min(6),
      confirm: z.string().min(6),
    })
    .refine((val) => val.confirm === val.password);

  const result = schema.safeParse({
    password: "qwer",
    confirm: "asdf",
  });

  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues.length).toEqual(3);
  }
});

const schema = z.object({
  inner: z.object({
    name: z
      .string()
      .refine((val) => val.length > 5)
      .array()
      .refine((val) => val.length <= 1),
  }),
});

test("no abort early on refinements", () => {
  const invalidItem = {
    inner: { name: ["aasd", "asdfasdfasfd"] },
  };

  const result1 = schema.safeParse(invalidItem);
  expect(result1.success).toEqual(false);
  if (!result1.success) {
    expect(result1.error.issues.length).toEqual(2);
  }
});
test("formatting", () => {
  const invalidItem = {
    inner: { name: ["aasd", "asdfasdfasfd"] },
  };
  const invalidArray = {
    inner: { name: ["asdfasdf", "asdfasdfasfd"] },
  };
  const result1 = schema.safeParse(invalidItem);
  const result2 = schema.safeParse(invalidArray);

  expect(result1.success).toEqual(false);
  expect(result2.success).toEqual(false);
  if (!result1.success) {
    const error = result1.error.format();

    expect(error._errors).toEqual([]);
    expect(error.inner?._errors).toEqual([]);
    // expect(error.inner?.name?._errors).toEqual(["Invalid input"]);
    // expect(error.inner?.name?.[0]._errors).toEqual(["Invalid input"]);
    expect(error.inner?.name?.[1]).toEqual(undefined);
  }
  if (!result2.success) {
    const error = result2.error.format();
    expect(error._errors).toEqual([]);
    expect(error.inner?._errors).toEqual([]);
    expect(error.inner?.name?._errors).toEqual(["Invalid input"]);
    expect(error.inner?.name?.[0]).toEqual(undefined);
    expect(error.inner?.name?.[1]).toEqual(undefined);
    expect(error.inner?.name?.[2]).toEqual(undefined);
  }
});

const stringWithCustomError = z.string({
  errorMap: (issue, ctx) => ({
    message:
      issue.code === "invalid_type"
        ? ctx.data
          ? "Invalid name"
          : "Name is required"
        : ctx.defaultError,
  }),
});

test("schema-bound error map", () => {
  const result = stringWithCustomError.safeParse(1234);
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].message).toEqual("Invalid name");
  }

  const result2 = stringWithCustomError.safeParse(undefined);
  expect(result2.success).toEqual(false);
  if (!result2.success) {
    expect(result2.error.issues[0].message).toEqual("Name is required");
  }

  // support contextual override
  const result3 = stringWithCustomError.safeParse(undefined, {
    errorMap: () => ({ message: "OVERRIDE" }),
  });
  expect(result3.success).toEqual(false);
  if (!result3.success) {
    expect(result3.error.issues[0].message).toEqual("OVERRIDE");
  }
});

test("overrideErrorMap", () => {
  // support overrideErrorMap
  z.setErrorMap(() => ({ message: "OVERRIDE" }));
  const result4 = stringWithCustomError.min(10).safeParse("tooshort");
  expect(result4.success).toEqual(false);
  if (!result4.success) {
    expect(result4.error.issues[0].message).toEqual("OVERRIDE");
  }
  z.setErrorMap(z.defaultErrorMap);
});

test("invalid and required", () => {
  const str = z.string({
    invalid_type_error: "Invalid name",
    required_error: "Name is required",
  });
  const result1 = str.safeParse(1234);
  expect(result1.success).toEqual(false);
  if (!result1.success) {
    expect(result1.error.issues[0].message).toEqual("Invalid name");
  }
  const result2 = str.safeParse(undefined);
  expect(result2.success).toEqual(false);
  if (!result2.success) {
    expect(result2.error.issues[0].message).toEqual("Name is required");
  }
});

test("Fallback to invalid_type_error without required_error", () => {
  const str = z.string({
    invalid_type_error: "Invalid name",
    // required_error: "Name is required",
  });

  const result2 = str.safeParse(undefined);
  expect(result2.success).toEqual(false);
  if (!result2.success) {
    expect(result2.error.issues[0].message).toEqual("Invalid name");
  }
});

test("invalid and required and errorMap", () => {
  expect(() => {
    return z.string({
      invalid_type_error: "Invalid name",
      required_error: "Name is required",
      errorMap: () => ({ message: "OVERRIDE" }),
    });
  }).toThrow();
});

test("strict error message", () => {
  const errorMsg = "Invalid object";
  const obj = z.object({ x: z.string() }).strict(errorMsg);
  const result = obj.safeParse({ x: "a", y: "b" });
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].message).toEqual(errorMsg);
  }
});

test("enum default error message", () => {
  try {
    z.enum(["Tuna", "Trout"]).parse("Salmon");
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues.length).toEqual(1);
    expect(zerr.issues[0].message).toEqual(
      "Invalid enum value. Expected 'Tuna' | 'Trout'"
    );
    expect(zerr.issues[0].message).not.toContain("Salmon");
  }
});

test("literal default error message", () => {
  try {
    z.literal("Tuna").parse("Trout");
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues.length).toEqual(1);
    expect(zerr.issues[0].message).toEqual(
      `Invalid literal value, expected "Tuna"`
    );
  }
});

// test("dont short circuit on continuable errors", () => {
//   const user = z
//     .object({
//       password: z.string().min(6),
//       confirm: z.string(),
//     })
//     .refine((data) => data.password === data.confirm, {
//       message: "Passwords don't match",
//       path: ["confirm"],
//     });
//   const result = user.safeParse({ password: "asdf", confirm: "qwer" });
//   if (!result.success) {
//     expect(result.error.issues.length).toEqual(2);
//   }
// });
````

## File: deno/lib/__tests__/firstparty.test.ts
````typescript
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

test("first party switch", () => {
  const myType = z.string() as z.ZodFirstPartySchemaTypes;
  const def = myType._def;

  switch (def.typeName) {
    case z.ZodFirstPartyTypeKind.ZodString:
      break;
    case z.ZodFirstPartyTypeKind.ZodNumber:
      break;
    case z.ZodFirstPartyTypeKind.ZodNaN:
      break;
    case z.ZodFirstPartyTypeKind.ZodBigInt:
      break;
    case z.ZodFirstPartyTypeKind.ZodBoolean:
      break;
    case z.ZodFirstPartyTypeKind.ZodDate:
      break;
    case z.ZodFirstPartyTypeKind.ZodUndefined:
      break;
    case z.ZodFirstPartyTypeKind.ZodNull:
      break;
    case z.ZodFirstPartyTypeKind.ZodAny:
      break;
    case z.ZodFirstPartyTypeKind.ZodUnknown:
      break;
    case z.ZodFirstPartyTypeKind.ZodNever:
      break;
    case z.ZodFirstPartyTypeKind.ZodVoid:
      break;
    case z.ZodFirstPartyTypeKind.ZodArray:
      break;
    case z.ZodFirstPartyTypeKind.ZodObject:
      break;
    case z.ZodFirstPartyTypeKind.ZodUnion:
      break;
    case z.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      break;
    case z.ZodFirstPartyTypeKind.ZodIntersection:
      break;
    case z.ZodFirstPartyTypeKind.ZodTuple:
      break;
    case z.ZodFirstPartyTypeKind.ZodRecord:
      break;
    case z.ZodFirstPartyTypeKind.ZodMap:
      break;
    case z.ZodFirstPartyTypeKind.ZodSet:
      break;
    case z.ZodFirstPartyTypeKind.ZodFunction:
      break;
    case z.ZodFirstPartyTypeKind.ZodLazy:
      break;
    case z.ZodFirstPartyTypeKind.ZodLiteral:
      break;
    case z.ZodFirstPartyTypeKind.ZodEnum:
      break;
    case z.ZodFirstPartyTypeKind.ZodEffects:
      break;
    case z.ZodFirstPartyTypeKind.ZodNativeEnum:
      break;
    case z.ZodFirstPartyTypeKind.ZodOptional:
      break;
    case z.ZodFirstPartyTypeKind.ZodNullable:
      break;
    case z.ZodFirstPartyTypeKind.ZodDefault:
      break;
    case z.ZodFirstPartyTypeKind.ZodPromise:
      break;
    default:
      util.assertNever(def);
  }
});
````

## File: deno/lib/__tests__/function.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

const args1 = z.tuple([z.string()]);
const returns1 = z.number();
const func1 = z.function(args1, returns1);

test("function parsing", () => {
  const parsed = func1.parse((arg: any) => arg.length);
  parsed("asdf");
});

test("parsed function fail 1", () => {
  const parsed = func1.parse((x: string) => x);
  expect(() => parsed("asdf")).toThrow();
});

test("parsed function fail 2", () => {
  const parsed = func1.parse((x: string) => x);
  expect(() => parsed(13 as any)).toThrow();
});

test("function inference 1", () => {
  type func1 = z.TypeOf<typeof func1>;
  const t1: util.AssertEqual<func1, (k: string) => number> = true;
  [t1];
});

test("args method", () => {
  const t1 = z.function();
  type t1 = z.infer<typeof t1>;
  const f1: util.AssertEqual<t1, () => void> = true;

  const t2 = t1.args(z.string());
  type t2 = z.infer<typeof t2>;
  const f2: util.AssertEqual<t2, (arg: string) => void> = true;

  const t3 = t2.returns(z.boolean());
  type t3 = z.infer<typeof t3>;
  const f3: util.AssertEqual<t3, (arg: string) => boolean> = true;

  f1;
  f2;
  f3;
});

const args2 = z.tuple([
  z.object({
    f1: z.number(),
    f2: z.string().nullable(),
    f3: z.array(z.boolean().optional()).optional(),
  }),
]);
const returns2 = z.union([z.string(), z.number()]);

const func2 = z.function(args2, returns2);

test("function inference 2", () => {
  type func2 = z.TypeOf<typeof func2>;
  const t2: util.AssertEqual<
    func2,
    (arg: {
      f1: number;
      f2: string | null;
      f3?: (boolean | undefined)[] | undefined;
    }) => string | number
  > = true;
  [t2];
});

test("valid function run", () => {
  const validFunc2Instance = func2.validate((_x) => {
    return "adf" as any;
  });

  const checker = () => {
    validFunc2Instance({
      f1: 21,
      f2: "asdf",
      f3: [true, false],
    });
  };

  checker();
});

test("input validation error", () => {
  const invalidFuncInstance = func2.validate((_x) => {
    return "adf" as any;
  });

  const checker = () => {
    invalidFuncInstance("Invalid_input" as any);
  };

  expect(checker).toThrow();
});

test("output validation error", () => {
  const invalidFuncInstance = func2.validate((_x) => {
    return ["this", "is", "not", "valid", "output"] as any;
  });

  const checker = () => {
    invalidFuncInstance({
      f1: 21,
      f2: "asdf",
      f3: [true, false],
    });
  };

  expect(checker).toThrow();
});

test("special function error codes", () => {
  const checker = z
    .function(z.tuple([z.string()]), z.boolean())
    .implement((arg) => {
      return arg.length as any;
    });
  try {
    checker("12" as any);
  } catch (err) {
    const zerr = err as z.ZodError;
    const first = zerr.issues[0];
    if (first.code !== z.ZodIssueCode.invalid_return_type) throw new Error();

    expect(first.returnTypeError).toBeInstanceOf(z.ZodError);
  }

  try {
    checker(12 as any);
  } catch (err) {
    const zerr = err as z.ZodError;
    const first = zerr.issues[0];
    if (first.code !== z.ZodIssueCode.invalid_arguments) throw new Error();
    expect(first.argumentsError).toBeInstanceOf(z.ZodError);
  }
});

test("function with async refinements", async () => {
  const func = z
    .function()
    .args(z.string().refine(async (val) => val.length > 10))
    .returns(z.promise(z.number().refine(async (val) => val > 10)))
    .implement(async (val) => {
      return val.length;
    });
  const results = [];
  try {
    await func("asdfasdf");
    results.push("success");
  } catch (err) {
    results.push("fail");
  }
  try {
    await func("asdflkjasdflkjsf");
    results.push("success");
  } catch (err) {
    results.push("fail");
  }

  expect(results).toEqual(["fail", "success"]);
});

test("non async function with async refinements should fail", async () => {
  const func = z
    .function()
    .args(z.string().refine(async (val) => val.length > 10))
    .returns(z.number().refine(async (val) => val > 10))
    .implement((val) => {
      return val.length;
    });

  const results = [];
  try {
    await func("asdasdfasdffasdf");
    results.push("success");
  } catch (err) {
    results.push("fail");
  }

  expect(results).toEqual(["fail"]);
});

test("allow extra parameters", () => {
  const maxLength5 = z
    .function()
    .args(z.string())
    .returns(z.boolean())
    .implement((str, _arg, _qewr) => {
      return str.length <= 5;
    });

  const filteredList = [
    "apple",
    "orange",
    "pear",
    "banana",
    "strawberry",
  ].filter(maxLength5);
  expect(filteredList.length).toEqual(2);
});

test("params and returnType getters", () => {
  const func = z.function().args(z.string()).returns(z.string());

  func.parameters().items[0].parse("asdf");
  func.returnType().parse("asdf");
});
````

## File: deno/lib/__tests__/instanceof.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

test("instanceof", async () => {
  class Test {}
  class Subtest extends Test {}

  const TestSchema = z.instanceof(Test);
  const SubtestSchema = z.instanceof(Subtest);

  TestSchema.parse(new Test());
  TestSchema.parse(new Subtest());
  SubtestSchema.parse(new Subtest());

  await expect(() => SubtestSchema.parse(new Test())).toThrow(
    /Input not instance of Subtest/
  );
  await expect(() => TestSchema.parse(12)).toThrow(
    /Input not instance of Test/
  );

  const f1: util.AssertEqual<Test, z.infer<typeof TestSchema>> = true;
  expect(f1).toBeTruthy();
});
````

## File: deno/lib/__tests__/intersection.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

test("object intersection", () => {
  const BaseTeacher = z.object({
    subjects: z.array(z.string()),
  });
  const HasID = z.object({ id: z.string() });

  const Teacher = z.intersection(BaseTeacher.passthrough(), HasID); // BaseTeacher.merge(HasID);
  const data = {
    subjects: ["math"],
    id: "asdfasdf",
  };
  expect(Teacher.parse(data)).toEqual(data);
  expect(() => Teacher.parse({ subject: data.subjects })).toThrow();
  expect(Teacher.parse({ ...data, extra: 12 })).toEqual({ ...data, extra: 12 });

  expect(() =>
    z.intersection(BaseTeacher.strict(), HasID).parse({ ...data, extra: 12 })
  ).toThrow();
});

test("deep intersection", () => {
  const Animal = z.object({
    properties: z.object({
      is_animal: z.boolean(),
    }),
  });
  const Cat = z
    .object({
      properties: z.object({
        jumped: z.boolean(),
      }),
    })
    .and(Animal);

  type Cat = z.infer<typeof Cat>;
  // const cat:Cat = 'asdf' as any;
  const cat = Cat.parse({ properties: { is_animal: true, jumped: true } });
  expect(cat.properties).toEqual({ is_animal: true, jumped: true });
});

test("deep intersection of arrays", async () => {
  const Author = z.object({
    posts: z.array(
      z.object({
        post_id: z.number(),
      })
    ),
  });
  const Registry = z
    .object({
      posts: z.array(
        z.object({
          title: z.string(),
        })
      ),
    })
    .and(Author);

  const posts = [
    { post_id: 1, title: "Novels" },
    { post_id: 2, title: "Fairy tales" },
  ];
  const cat = Registry.parse({ posts });
  expect(cat.posts).toEqual(posts);
  const asyncCat = await Registry.parseAsync({ posts });
  expect(asyncCat.posts).toEqual(posts);
});

test("invalid intersection types", async () => {
  const numberIntersection = z.intersection(
    z.number(),
    z.number().transform((x) => x + 1)
  );

  const syncResult = numberIntersection.safeParse(1234);
  expect(syncResult.success).toEqual(false);
  if (!syncResult.success) {
    expect(syncResult.error.issues[0].code).toEqual(
      z.ZodIssueCode.invalid_intersection_types
    );
  }

  const asyncResult = await numberIntersection.spa(1234);
  expect(asyncResult.success).toEqual(false);
  if (!asyncResult.success) {
    expect(asyncResult.error.issues[0].code).toEqual(
      z.ZodIssueCode.invalid_intersection_types
    );
  }
});

test("invalid array merge", async () => {
  const stringArrInt = z.intersection(
    z.string().array(),
    z
      .string()
      .array()
      .transform((val) => [...val, "asdf"])
  );
  const syncResult = stringArrInt.safeParse(["asdf", "qwer"]);
  expect(syncResult.success).toEqual(false);
  if (!syncResult.success) {
    expect(syncResult.error.issues[0].code).toEqual(
      z.ZodIssueCode.invalid_intersection_types
    );
  }

  const asyncResult = await stringArrInt.spa(["asdf", "qwer"]);
  expect(asyncResult.success).toEqual(false);
  if (!asyncResult.success) {
    expect(asyncResult.error.issues[0].code).toEqual(
      z.ZodIssueCode.invalid_intersection_types
    );
  }
});
````

## File: deno/lib/__tests__/map.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";
import { ZodIssueCode } from "../index.ts";

const stringMap = z.map(z.string(), z.string());
type stringMap = z.infer<typeof stringMap>;

test("type inference", () => {
  const f1: util.AssertEqual<stringMap, Map<string, string>> = true;
  f1;
});

test("valid parse", () => {
  const result = stringMap.safeParse(
    new Map([
      ["first", "foo"],
      ["second", "bar"],
    ])
  );
  expect(result.success).toEqual(true);
  if (result.success) {
    expect(result.data.has("first")).toEqual(true);
    expect(result.data.has("second")).toEqual(true);
    expect(result.data.get("first")).toEqual("foo");
    expect(result.data.get("second")).toEqual("bar");
  }
});

test("valid parse async", async () => {
  const result = await stringMap.spa(
    new Map([
      ["first", "foo"],
      ["second", "bar"],
    ])
  );
  expect(result.success).toEqual(true);
  if (result.success) {
    expect(result.data.has("first")).toEqual(true);
    expect(result.data.has("second")).toEqual(true);
    expect(result.data.get("first")).toEqual("foo");
    expect(result.data.get("second")).toEqual("bar");
  }
});

test("throws when a Set is given", () => {
  const result = stringMap.safeParse(new Set([]));
  expect(result.success).toEqual(false);
  if (result.success === false) {
    expect(result.error.issues.length).toEqual(1);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
  }
});

test("throws when the given map has invalid key and invalid input", () => {
  const result = stringMap.safeParse(new Map([[42, Symbol()]]));
  expect(result.success).toEqual(false);
  if (result.success === false) {
    expect(result.error.issues.length).toEqual(2);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[0].path).toEqual([0, "key"]);
    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[1].path).toEqual([0, "value"]);
  }
});

test("throws when the given map has multiple invalid entries", () => {
  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));

  const result = stringMap.safeParse(
    new Map([
      [1, "foo"],
      ["bar", 2],
    ] as [any, any][]) as Map<any, any>
  );

  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));
  expect(result.success).toEqual(false);
  if (result.success === false) {
    expect(result.error.issues.length).toEqual(2);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[0].path).toEqual([0, "key"]);
    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[1].path).toEqual([1, "value"]);
  }
});

test("dirty", async () => {
  const map = z.map(
    z.string().refine((val) => val === val.toUpperCase(), {
      message: "Keys must be uppercase",
    }),
    z.string()
  );
  const result = await map.spa(
    new Map([
      ["first", "foo"],
      ["second", "bar"],
    ])
  );
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues.length).toEqual(2);
    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);
    expect(result.error.issues[0].message).toEqual("Keys must be uppercase");
    expect(result.error.issues[1].code).toEqual(z.ZodIssueCode.custom);
    expect(result.error.issues[1].message).toEqual("Keys must be uppercase");
  }
});
````

## File: deno/lib/__tests__/masking.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

test("masking test", () => {});

test("require", () => {
  const baseSchema = z.object({
    firstName: z.string(),
    middleName: z.string().optional(),
    lastName: z.union([z.undefined(), z.string()]),
    otherName: z.union([z.string(), z.undefined(), z.string()]),
  });
  baseSchema;
  // const reqBase = baseSchema.require();
  // const ewr = reqBase.shape;
  // expect(ewr.firstName).toBeInstanceOf(z.ZodString);
  // expect(ewr.middleName).toBeInstanceOf(z.ZodString);
  // expect(ewr.lastName).toBeInstanceOf(z.ZodString);
  // expect(ewr.otherName).toBeInstanceOf(z.ZodUnion);
});
````

## File: deno/lib/__tests__/mocker.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { Mocker } from "./Mocker.ts";

test("mocker", () => {
  const mocker = new Mocker();
  mocker.string;
  mocker.number;
  mocker.boolean;
  mocker.null;
  mocker.undefined;
  mocker.stringOptional;
  mocker.stringNullable;
  mocker.numberOptional;
  mocker.numberNullable;
  mocker.booleanOptional;
  mocker.booleanNullable;
});
````

## File: deno/lib/__tests__/Mocker.ts
````typescript
function getRandomInt(max: number) {
  return Math.floor(Math.random() * Math.floor(max));
}

export class Mocker {
  pick = (...args: any[]) => {
    return args[getRandomInt(args.length)];
  };

  get string() {
    return Math.random().toString(36).substring(7);
  }
  get number() {
    return Math.random() * 100;
  }
  get bigint() {
    return BigInt(Math.floor(Math.random() * 10000));
  }
  get boolean() {
    return Math.random() < 0.5;
  }
  get date() {
    return new Date(Math.floor(Date.now() * Math.random()));
  }
  get null(): null {
    return null;
  }
  get undefined(): undefined {
    return undefined;
  }
  get stringOptional() {
    return this.pick(this.string, this.undefined);
  }
  get stringNullable() {
    return this.pick(this.string, this.null);
  }
  get numberOptional() {
    return this.pick(this.number, this.undefined);
  }
  get numberNullable() {
    return this.pick(this.number, this.null);
  }
  get booleanOptional() {
    return this.pick(this.boolean, this.undefined);
  }
  get booleanNullable() {
    return this.pick(this.boolean, this.null);
  }
}
````

## File: deno/lib/__tests__/nan.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

const schema = z.nan();

test("passing validations", () => {
  schema.parse(NaN);
  schema.parse(Number("Not a number"));
});

test("failing validations", () => {
  expect(() => schema.parse(5)).toThrow();
  expect(() => schema.parse("John")).toThrow();
  expect(() => schema.parse(true)).toThrow();
  expect(() => schema.parse(null)).toThrow();
  expect(() => schema.parse(undefined)).toThrow();
  expect(() => schema.parse({})).toThrow();
  expect(() => schema.parse([])).toThrow();
});
````

## File: deno/lib/__tests__/nativeEnum.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

test("nativeEnum test with consts", () => {
  const Fruits: { Apple: "apple"; Banana: "banana" } = {
    Apple: "apple",
    Banana: "banana",
  };
  const fruitEnum = z.nativeEnum(Fruits);
  type fruitEnum = z.infer<typeof fruitEnum>;
  fruitEnum.parse("apple");
  fruitEnum.parse("banana");
  fruitEnum.parse(Fruits.Apple);
  fruitEnum.parse(Fruits.Banana);
  const t1: util.AssertEqual<fruitEnum, "apple" | "banana"> = true;
  [t1];
});

test("nativeEnum test with real enum", () => {
  enum Fruits {
    Apple = "apple",
    Banana = "banana",
  }
  // @ts-ignore
  const fruitEnum = z.nativeEnum(Fruits);
  type fruitEnum = z.infer<typeof fruitEnum>;
  fruitEnum.parse("apple");
  fruitEnum.parse("banana");
  fruitEnum.parse(Fruits.Apple);
  fruitEnum.parse(Fruits.Banana);
  const t1: util.AssertEqual<fruitEnum, Fruits> = true;
  [t1];
});

test("nativeEnum test with const with numeric keys", () => {
  const FruitValues = {
    Apple: 10,
    Banana: 20,
    // @ts-ignore
  } as const;
  const fruitEnum = z.nativeEnum(FruitValues);
  type fruitEnum = z.infer<typeof fruitEnum>;
  fruitEnum.parse(10);
  fruitEnum.parse(20);
  fruitEnum.parse(FruitValues.Apple);
  fruitEnum.parse(FruitValues.Banana);
  const t1: util.AssertEqual<fruitEnum, 10 | 20> = true;
  [t1];
});

test("from enum", () => {
  enum Fruits {
    Cantaloupe,
    Apple = "apple",
    Banana = "banana",
  }

  const FruitEnum = z.nativeEnum(Fruits as any);
  type FruitEnum = z.infer<typeof FruitEnum>;
  FruitEnum.parse(Fruits.Cantaloupe);
  FruitEnum.parse(Fruits.Apple);
  FruitEnum.parse("apple");
  FruitEnum.parse(0);
  expect(() => FruitEnum.parse(1)).toThrow();
  expect(() => FruitEnum.parse("Apple")).toThrow();
  expect(() => FruitEnum.parse("Cantaloupe")).toThrow();
});

test("from const", () => {
  const Greek = {
    Alpha: "a",
    Beta: "b",
    Gamma: 3,
    // @ts-ignore
  } as const;

  const GreekEnum = z.nativeEnum(Greek);
  type GreekEnum = z.infer<typeof GreekEnum>;
  GreekEnum.parse("a");
  GreekEnum.parse("b");
  GreekEnum.parse(3);
  expect(() => GreekEnum.parse("v")).toThrow();
  expect(() => GreekEnum.parse("Alpha")).toThrow();
  expect(() => GreekEnum.parse(2)).toThrow();

  expect(GreekEnum.enum.Alpha).toEqual("a");
});
````

## File: deno/lib/__tests__/nullable.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

function checkErrors(a: z.ZodTypeAny, bad: any) {
  let expected;
  try {
    a.parse(bad);
  } catch (error) {
    expected = (error as z.ZodError).formErrors;
  }
  try {
    a.nullable().parse(bad);
  } catch (error) {
    expect((error as z.ZodError).formErrors).toEqual(expected);
  }
}

test("Should have error messages appropriate for the underlying type", () => {
  checkErrors(z.string().min(2), 1);
  z.string().min(2).nullable().parse(null);
  checkErrors(z.number().gte(2), 1);
  z.number().gte(2).nullable().parse(null);
  checkErrors(z.boolean(), "");
  z.boolean().nullable().parse(null);
  checkErrors(z.null(), null);
  z.null().nullable().parse(null);
  checkErrors(z.null(), {});
  z.null().nullable().parse(null);
  checkErrors(z.object({}), 1);
  z.object({}).nullable().parse(null);
  checkErrors(z.tuple([]), 1);
  z.tuple([]).nullable().parse(null);
  checkErrors(z.unknown(), 1);
  z.unknown().nullable().parse(null);
});

test("unwrap", () => {
  const unwrapped = z.string().nullable().unwrap();
  expect(unwrapped).toBeInstanceOf(z.ZodString);
});
````

## File: deno/lib/__tests__/number.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

const gtFive = z.number().gt(5);
const gteFive = z.number().gte(5);
const ltFive = z.number().lt(5);
const lteFive = z.number().lte(5);
const intNum = z.number().int();
const multipleOfFive = z.number().multipleOf(5);
const stepPointOne = z.number().step(0.1);
const stepPointZeroZeroZeroOne = z.number().step(0.0001);
const stepSixPointFour = z.number().step(6.4);

test("passing validations", () => {
  gtFive.parse(6);
  gteFive.parse(5);
  ltFive.parse(4);
  lteFive.parse(5);
  intNum.parse(4);
  multipleOfFive.parse(15);
  stepPointOne.parse(6);
  stepPointOne.parse(6.1);
  stepPointOne.parse(6.1);
  stepSixPointFour.parse(12.8);
  stepPointZeroZeroZeroOne.parse(3.01);
});

test("failing validations", () => {
  expect(() => ltFive.parse(5)).toThrow();
  expect(() => lteFive.parse(6)).toThrow();
  expect(() => gtFive.parse(5)).toThrow();
  expect(() => gteFive.parse(4)).toThrow();
  expect(() => intNum.parse(3.14)).toThrow();
  expect(() => multipleOfFive.parse(14.9)).toThrow();

  expect(() => stepPointOne.parse(6.11)).toThrow();
  expect(() => stepPointOne.parse(6.1000000001)).toThrow();
  expect(() => stepSixPointFour.parse(6.41)).toThrow();
});

test("parse NaN", () => {
  expect(() => z.number().parse(NaN)).toThrow();
});

test("min max getters", () => {
  expect(z.number().int().isInt).toEqual(true);
  expect(z.number().isInt).toEqual(false);

  expect(z.number().min(5).minValue).toEqual(5);
  expect(z.number().min(5).min(10).minValue).toEqual(10);

  expect(z.number().max(5).maxValue).toEqual(5);
  expect(z.number().max(5).max(1).maxValue).toEqual(1);
});
````

## File: deno/lib/__tests__/object-augmentation.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

test("object augmentation", () => {
  const Animal = z
    .object({
      species: z.string(),
    })
    .augment({
      population: z.number(),
    });
  // overwrites `species`
  const ModifiedAnimal = Animal.augment({
    species: z.array(z.string()),
  });
  ModifiedAnimal.parse({
    species: ["asd"],
    population: 1324,
  });

  const bad = () =>
    ModifiedAnimal.parse({
      species: "asdf",
      population: 1324,
    } as any);
  expect(bad).toThrow();
});
````

## File: deno/lib/__tests__/object.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

const Test = z.object({
  f1: z.number(),
  f2: z.string().optional(),
  f3: z.string().nullable(),
  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),
});
type Test = z.infer<typeof Test>;

test("object type inference", () => {
  type TestType = {
    f1: number;
    f2?: string | undefined;
    f3: string | null;
    f4: { t: string | boolean }[];
  };

  const t1: util.AssertEqual<z.TypeOf<typeof Test>, TestType> = true;
  [t1];
});

test("unknown throw", () => {
  const asdf: unknown = 35;
  expect(() => Test.parse(asdf)).toThrow();
});

test("correct parsing", () => {
  Test.parse({
    f1: 12,
    f2: "string",
    f3: "string",
    f4: [
      {
        t: "string",
      },
    ],
  });

  Test.parse({
    f1: 12,
    f3: null,
    f4: [
      {
        t: false,
      },
    ],
  });
});

test("incorrect #1", () => {
  expect(() => Test.parse({} as any)).toThrow();
});

test("nonstrict by default", () => {
  z.object({ points: z.number() }).parse({
    points: 2314,
    unknown: "asdf",
  });
});

const data = {
  points: 2314,
  unknown: "asdf",
};

test("strip by default", () => {
  const val = z.object({ points: z.number() }).parse(data);
  expect(val).toEqual({ points: 2314 });
});

test("unknownkeys override", () => {
  const val = z
    .object({ points: z.number() })
    .strict()
    .passthrough()
    .strip()
    .nonstrict()
    .parse(data);

  expect(val).toEqual(data);
});

test("passthrough unknown", () => {
  const val = z.object({ points: z.number() }).passthrough().parse(data);

  expect(val).toEqual(data);
});

test("strip unknown", () => {
  const val = z.object({ points: z.number() }).strip().parse(data);

  expect(val).toEqual({ points: 2314 });
});

test("strict", () => {
  const val = z.object({ points: z.number() }).strict().safeParse(data);

  expect(val.success).toEqual(false);
});

test("catchall inference", () => {
  const o1 = z
    .object({
      first: z.string(),
    })
    .catchall(z.number());

  const d1 = o1.parse({ first: "asdf", num: 1243 });
  const f1: util.AssertEqual<number, typeof d1["asdf"]> = true;
  const f2: util.AssertEqual<string, typeof d1["first"]> = true;
  f1;
  f2;
});

test("catchall overrides strict", () => {
  const o1 = z
    .object({ first: z.string().optional() })
    .strict()
    .catchall(z.number());

  // should run fine
  // setting a catchall overrides the unknownKeys behavior
  o1.parse({
    asdf: 1234,
  });

  // should only run catchall validation
  // against unknown keys
  o1.parse({
    first: "asdf",
    asdf: 1234,
  });
});

test("catchall overrides strict", () => {
  const o1 = z
    .object({
      first: z.string(),
    })
    .strict()
    .catchall(z.number());

  // should run fine
  // setting a catchall overrides the unknownKeys behavior
  o1.parse({
    first: "asdf",
    asdf: 1234,
  });
});

test("test that optional keys are unset", async () => {
  const SNamedEntity = z.object({
    id: z.string(),
    set: z.string().optional(),
    unset: z.string().optional(),
  });
  const result = await SNamedEntity.parse({
    id: "asdf",
    set: undefined,
  });
  // eslint-disable-next-line ban/ban
  expect(Object.keys(result)).toEqual(["id", "set"]);
});

test("test catchall parsing", async () => {
  const result = z
    .object({ name: z.string() })
    .catchall(z.number())
    .parse({ name: "Foo", validExtraKey: 61 });

  expect(result).toEqual({ name: "Foo", validExtraKey: 61 });

  const result2 = z
    .object({ name: z.string() })
    .catchall(z.number())
    .safeParse({ name: "Foo", validExtraKey: 61, invalid: "asdf" });

  expect(result2.success).toEqual(false);
});

test("test nonexistent keys", async () => {
  const Schema = z.union([
    z.object({ a: z.string() }),
    z.object({ b: z.number() }),
  ]);
  const obj = { a: "A" };
  const result = await Schema.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21
  expect(result.success).toBe(true);
});

test("test async union", async () => {
  const Schema2 = z.union([
    z.object({
      ty: z.string(),
    }),
    z.object({
      ty: z.number(),
    }),
  ]);

  const obj = { ty: "A" };
  const result = await Schema2.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21
  expect(result.success).toEqual(true);
});

test("test inferred merged type", async () => {
  const asdf = z.object({ a: z.string() }).merge(z.object({ a: z.number() }));
  type asdf = z.infer<typeof asdf>;
  const f1: util.AssertEqual<asdf, { a: number }> = true;
  f1;
});

test("inferred type for unknown/any keys", () => {
  const myType = z.object({
    anyOptional: z.any().optional(),
    anyRequired: z.any(),
    unknownOptional: z.unknown().optional(),
    unknownRequired: z.unknown(),
  });
  type myType = z.infer<typeof myType>;
  const _f1: util.AssertEqual<
    myType,
    {
      anyOptional?: any;
      anyRequired?: any;
      unknownOptional?: unknown;
      unknownRequired?: unknown;
    }
  > = true;
  _f1;
});

test("setKey", () => {
  const base = z.object({ name: z.string() });
  const withNewKey = base.setKey("age", z.number());

  type withNewKey = z.infer<typeof withNewKey>;
  const _t1: util.AssertEqual<withNewKey, { name: string; age: number }> = true;
  _t1;
  withNewKey.parse({ name: "asdf", age: 1234 });
});

test("strictcreate", async () => {
  const strictObj = z.strictObject({
    name: z.string(),
  });

  const syncResult = strictObj.safeParse({ name: "asdf", unexpected: 13 });
  expect(syncResult.success).toEqual(false);

  const asyncResult = await strictObj.spa({ name: "asdf", unexpected: 13 });
  expect(asyncResult.success).toEqual(false);
});

test("object with refine", async () => {
  const schema = z
    .object({
      a: z.string().default("foo"),
      b: z.number(),
    })
    .refine(() => true);
  expect(schema.parse({ b: 5 })).toEqual({ b: 5, a: "foo" });
  const result = await schema.parseAsync({ b: 5 });
  expect(result).toEqual({ b: 5, a: "foo" });
});

test("intersection of object with date", async () => {
  const schema = z.object({
    a: z.date(),
  });
  expect(schema.and(schema).parse({ a: new Date(1637353595983) })).toEqual({
    a: new Date(1637353595983),
  });
  const result = await schema.parseAsync({ a: new Date(1637353595983) });
  expect(result).toEqual({ a: new Date(1637353595983) });
});

test("intersection of object with refine with date", async () => {
  const schema = z
    .object({
      a: z.date(),
    })
    .refine(() => true);
  expect(schema.and(schema).parse({ a: new Date(1637353595983) })).toEqual({
    a: new Date(1637353595983),
  });
  const result = await schema.parseAsync({ a: new Date(1637353595983) });
  expect(result).toEqual({ a: new Date(1637353595983) });
});

test("constructor key", () => {
  const person = z
    .object({
      name: z.string(),
    })
    .strict();

  expect(() =>
    person.parse({
      name: "bob dylan",
      constructor: 61,
    })
  ).toThrow();
});
````

## File: deno/lib/__tests__/optional.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

function checkErrors(a: z.ZodTypeAny, bad: any) {
  let expected;
  try {
    a.parse(bad);
  } catch (error) {
    expected = (error as z.ZodError).formErrors;
  }
  try {
    a.optional().parse(bad);
  } catch (error) {
    expect((error as z.ZodError).formErrors).toEqual(expected);
  }
}

test("Should have error messages appropriate for the underlying type", () => {
  checkErrors(z.string().min(2), 1);
  z.string().min(2).optional().parse(undefined);
  checkErrors(z.number().gte(2), 1);
  z.number().gte(2).optional().parse(undefined);
  checkErrors(z.boolean(), "");
  z.boolean().optional().parse(undefined);
  checkErrors(z.undefined(), null);
  z.undefined().optional().parse(undefined);
  checkErrors(z.null(), {});
  z.null().optional().parse(undefined);
  checkErrors(z.object({}), 1);
  z.object({}).optional().parse(undefined);
  checkErrors(z.tuple([]), 1);
  z.tuple([]).optional().parse(undefined);
  checkErrors(z.unknown(), 1);
  z.unknown().optional().parse(undefined);
});

test("unwrap", () => {
  const unwrapped = z.string().optional().unwrap();
  expect(unwrapped).toBeInstanceOf(z.ZodString);
});
````

## File: deno/lib/__tests__/parser.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

test("parse strict object with unknown keys", () => {
  expect(() =>
    z
      .object({ name: z.string() })
      .strict()
      .parse({ name: "bill", unknownKey: 12 } as any)
  ).toThrow();
});

test("parse nonstrict object with unknown keys", () => {
  z.object({ name: z.string() })
    .nonstrict()
    .parse({ name: "bill", unknownKey: 12 });
});

test("invalid left side of intersection", () => {
  expect(() =>
    z.intersection(z.string(), z.number()).parse(12 as any)
  ).toThrow();
});

test("invalid right side of intersection", () => {
  expect(() =>
    z.intersection(z.string(), z.number()).parse("12" as any)
  ).toThrow();
});

test("parsing non-array in tuple schema", () => {
  expect(() => z.tuple([]).parse("12" as any)).toThrow();
});

test("incorrect num elements in tuple", () => {
  expect(() => z.tuple([]).parse(["asdf"] as any)).toThrow();
});

test("invalid enum value", () => {
  expect(() => z.enum(["Blue"]).parse("Red" as any)).toThrow();
});

test("parsing unknown", () => {
  z.string().parse("Red" as unknown);
});
````

## File: deno/lib/__tests__/parseUtil.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import {
  isAborted,
  isDirty,
  isValid,
  SyncParseReturnType,
} from "../helpers/parseUtil.ts";

test("parseUtil isInvalid should use structural typing", () => {
  // Test for issue #556: https://github.com/colinhacks/zod/issues/556
  const aborted: SyncParseReturnType = { status: "aborted" };
  const dirty: SyncParseReturnType = { status: "dirty", value: "whatever" };
  const valid: SyncParseReturnType = { status: "valid", value: "whatever" };

  expect(isAborted(aborted)).toBe(true);
  expect(isAborted(dirty)).toBe(false);
  expect(isAborted(valid)).toBe(false);

  expect(isDirty(aborted)).toBe(false);
  expect(isDirty(dirty)).toBe(true);
  expect(isDirty(valid)).toBe(false);

  expect(isValid(aborted)).toBe(false);
  expect(isValid(dirty)).toBe(false);
  expect(isValid(valid)).toBe(true);
});
````

## File: deno/lib/__tests__/partials.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";
import { ZodNullable, ZodOptional } from "../index.ts";

const nested = z.object({
  name: z.string(),
  age: z.number(),
  outer: z.object({
    inner: z.string(),
  }),
  array: z.array(z.object({ asdf: z.string() })),
});

test("shallow inference", () => {
  const shallow = nested.partial();
  type shallow = z.infer<typeof shallow>;
  type correct = {
    name?: string | undefined;
    age?: number | undefined;
    outer?: { inner: string } | undefined;
    array?: { asdf: string }[];
  };
  const t1: util.AssertEqual<shallow, correct> = true;
  t1;
});

test("shallow partial parse", () => {
  const shallow = nested.partial();
  shallow.parse({});
  shallow.parse({
    name: "asdf",
    age: 23143,
  });
});

test("deep partial inference", () => {
  const deep = nested.deepPartial();
  const asdf = deep.shape.array.unwrap().element.shape.asdf.unwrap();
  asdf.parse("asdf");
  type deep = z.infer<typeof deep>;
  type correct = {
    array?: { asdf?: string }[];
    name?: string | undefined;
    age?: number | undefined;
    outer?: { inner?: string | undefined } | undefined;
  };

  const t1: util.AssertEqual<deep, correct> = true;
  t1;
});

test("deep partial parse", () => {
  const deep = nested.deepPartial();

  expect(deep.shape.name instanceof z.ZodOptional).toBe(true);
  expect(deep.shape.outer instanceof z.ZodOptional).toBe(true);
  expect(deep.shape.outer._def.innerType instanceof z.ZodObject).toBe(true);
  expect(
    deep.shape.outer._def.innerType.shape.inner instanceof z.ZodOptional
  ).toBe(true);
  expect(
    deep.shape.outer._def.innerType.shape.inner._def.innerType instanceof
      z.ZodString
  ).toBe(true);
});

test("deep partial runtime tests", () => {
  const deep = nested.deepPartial();
  deep.parse({});
  deep.parse({
    outer: {},
  });
  deep.parse({
    name: "asdf",
    age: 23143,
    outer: {
      inner: "adsf",
    },
  });
});

test("deep partial optional/nullable", () => {
  const schema = z
    .object({
      name: z.string().optional(),
      age: z.number().nullable(),
    })
    .deepPartial();

  expect(schema.shape.name.unwrap()).toBeInstanceOf(ZodOptional);
  expect(schema.shape.age.unwrap()).toBeInstanceOf(ZodNullable);
});

test("deep partial tuple", () => {
  const schema = z
    .object({
      tuple: z.tuple([
        z.object({
          name: z.string().optional(),
          age: z.number().nullable(),
        }),
      ]),
    })
    .deepPartial();

  expect(schema.shape.tuple.unwrap().items[0].shape.name).toBeInstanceOf(
    ZodOptional
  );
});

test("deep partial inference", () => {
  const mySchema = z.object({
    name: z.string(),
    array: z.array(z.object({ asdf: z.string() })),
    tuple: z.tuple([z.object({ value: z.string() })]),
  });

  const partialed = mySchema.deepPartial();
  type partialed = z.infer<typeof partialed>;
  type expected = {
    name?: string | undefined;
    array?:
      | {
          asdf?: string | undefined;
        }[]
      | undefined;
    tuple?: [{ value?: string }] | undefined;
  };
  const f1: util.AssertEqual<expected, partialed> = true;
  f1;
});

test("required", () => {
  const object = z.object({
    name: z.string(),
    age: z.number().optional(),
    field: z.string().optional().default("asdf"),
  });

  const requiredObject = object.required();
  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);
  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber);
  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);
});

test("with mask", async () => {
  const object = z.object({
    name: z.string(),
    age: z.number().optional(),
    field: z.string().optional().default("asdf"),
  });

  const masked = object
    .partial({
      name: true,
      age: true,
      field: true,
    })
    .strict();

  masked.parse({});
  await masked.parseAsync({});
});
````

## File: deno/lib/__tests__/pickomit.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

const fish = z.object({
  name: z.string(),
  age: z.number(),
  nested: z.object({}),
});

test("pick type inference", () => {
  const nameonlyFish = fish.pick({ name: true });
  type nameonlyFish = z.infer<typeof nameonlyFish>;
  const f1: util.AssertEqual<nameonlyFish, { name: string }> = true;
  f1;
});

test("pick parse - success", () => {
  const nameonlyFish = fish.pick({ name: true });
  nameonlyFish.parse({ name: "bob" });
});

test("pick parse - fail", () => {
  fish.pick({ name: true }).parse({ name: "12" } as any);
  fish.pick({ name: true }).parse({ name: "bob", age: 12 } as any);
  fish.pick({ age: true }).parse({ age: 12 } as any);

  const nameonlyFish = fish.pick({ name: true }).strict();
  const bad1 = () => nameonlyFish.parse({ name: 12 } as any);
  const bad2 = () => nameonlyFish.parse({ name: "bob", age: 12 } as any);
  const bad3 = () => nameonlyFish.parse({ age: 12 } as any);

  expect(bad1).toThrow();
  expect(bad2).toThrow();
  expect(bad3).toThrow();
});

test("omit type inference", () => {
  const nonameFish = fish.omit({ name: true });
  type nonameFish = z.infer<typeof nonameFish>;
  const f1: util.AssertEqual<nonameFish, { age: number; nested: {} }> = true;
  f1;
});

test("omit parse - success", () => {
  const nonameFish = fish.omit({ name: true });
  nonameFish.parse({ age: 12, nested: {} });
});

test("omit parse - fail", () => {
  const nonameFish = fish.omit({ name: true });
  const bad1 = () => nonameFish.parse({ name: 12 } as any);
  const bad2 = () => nonameFish.parse({ age: 12 } as any);
  const bad3 = () => nonameFish.parse({} as any);

  expect(bad1).toThrow();
  expect(bad2).toThrow();
  expect(bad3).toThrow();
});

test("nonstrict inference", () => {
  const laxfish = fish.nonstrict().pick({ name: true });
  type laxfish = z.infer<typeof laxfish>;
  const f1: util.AssertEqual<laxfish, { [k: string]: any; name: string }> =
    true;
  f1;
});

test("nonstrict parsing - pass", () => {
  const laxfish = fish.nonstrict().pick({ name: true });
  laxfish.parse({ name: "asdf", whatever: "asdf" });
  laxfish.parse({ name: "asdf", age: 12, nested: {} });
});

test("nonstrict parsing - fail", () => {
  const laxfish = fish.nonstrict().pick({ name: true });
  const bad = () => laxfish.parse({ whatever: "asdf" } as any);
  expect(bad).toThrow();
});
````

## File: deno/lib/__tests__/primitive.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";
import { Mocker } from "./Mocker.ts";

const literalStringSchema = z.literal("asdf");
const literalNumberSchema = z.literal(12);
const literalBooleanSchema = z.literal(true);
const stringSchema = z.string();
const numberSchema = z.number();
const bigintSchema = z.bigint();
const booleanSchema = z.boolean();
const dateSchema = z.date();
const nullSchema = z.null();
const undefinedSchema = z.undefined();
const stringSchemaOptional = z.string().optional();
const stringSchemaNullable = z.string().nullable();
const numberSchemaOptional = z.number().optional();
const numberSchemaNullable = z.number().nullable();
const bigintSchemaOptional = z.bigint().optional();
const bigintSchemaNullable = z.bigint().nullable();
const booleanSchemaOptional = z.boolean().optional();
const booleanSchemaNullable = z.boolean().nullable();
const dateSchemaOptional = z.date().optional();
const dateSchemaNullable = z.date().nullable();

const val = new Mocker();

test("literal string correct", () => {
  expect(literalStringSchema.parse("asdf")).toBe("asdf");
});

test("literal string incorrect", () => {
  const f = () => literalStringSchema.parse("not_asdf");
  expect(f).toThrow();
});

test("literal string number", () => {
  const f = () => literalStringSchema.parse(123);
  expect(f).toThrow();
});

test("literal string boolean", () => {
  const f = () => literalStringSchema.parse(true);
  expect(f).toThrow();
});

test("literal string boolean", () => {
  const f = () => literalStringSchema.parse(true);
  expect(f).toThrow();
});

test("literal string object", () => {
  const f = () => literalStringSchema.parse({});
  expect(f).toThrow();
});

test("literal number correct", () => {
  expect(literalNumberSchema.parse(12)).toBe(12);
});

test("literal number incorrect", () => {
  const f = () => literalNumberSchema.parse(13);
  expect(f).toThrow();
});

test("literal number number", () => {
  const f = () => literalNumberSchema.parse(val.string);
  expect(f).toThrow();
});

test("literal number boolean", () => {
  const f = () => literalNumberSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("literal number object", () => {
  const f = () => literalStringSchema.parse({});
  expect(f).toThrow();
});

test("literal boolean correct", () => {
  expect(literalBooleanSchema.parse(true)).toBe(true);
});

test("literal boolean incorrect", () => {
  const f = () => literalBooleanSchema.parse(false);
  expect(f).toThrow();
});

test("literal boolean number", () => {
  const f = () => literalBooleanSchema.parse("asdf");
  expect(f).toThrow();
});

test("literal boolean boolean", () => {
  const f = () => literalBooleanSchema.parse(123);
  expect(f).toThrow();
});

test("literal boolean object", () => {
  const f = () => literalBooleanSchema.parse({});
  expect(f).toThrow();
});

test("parse stringSchema string", () => {
  stringSchema.parse(val.string);
});

test("parse stringSchema number", () => {
  const f = () => stringSchema.parse(val.number);
  expect(f).toThrow();
});

test("parse stringSchema boolean", () => {
  const f = () => stringSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("parse stringSchema undefined", () => {
  const f = () => stringSchema.parse(val.undefined);
  expect(f).toThrow();
});

test("parse stringSchema null", () => {
  const f = () => stringSchema.parse(val.null);
  expect(f).toThrow();
});

test("parse numberSchema string", () => {
  const f = () => numberSchema.parse(val.string);
  expect(f).toThrow();
});

test("parse numberSchema number", () => {
  numberSchema.parse(val.number);
});

test("parse numberSchema bigint", () => {
  const f = () => numberSchema.parse(val.bigint);
  expect(f).toThrow();
});

test("parse numberSchema boolean", () => {
  const f = () => numberSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("parse numberSchema undefined", () => {
  const f = () => numberSchema.parse(val.undefined);
  expect(f).toThrow();
});

test("parse numberSchema null", () => {
  const f = () => numberSchema.parse(val.null);
  expect(f).toThrow();
});

test("parse bigintSchema string", () => {
  const f = () => bigintSchema.parse(val.string);
  expect(f).toThrow();
});

test("parse bigintSchema number", () => {
  const f = () => bigintSchema.parse(val.number);
  expect(f).toThrow();
});

test("parse bigintSchema bigint", () => {
  bigintSchema.parse(val.bigint);
});

test("parse bigintSchema boolean", () => {
  const f = () => bigintSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("parse bigintSchema undefined", () => {
  const f = () => bigintSchema.parse(val.undefined);
  expect(f).toThrow();
});

test("parse bigintSchema null", () => {
  const f = () => bigintSchema.parse(val.null);
  expect(f).toThrow();
});

test("parse booleanSchema string", () => {
  const f = () => booleanSchema.parse(val.string);
  expect(f).toThrow();
});

test("parse booleanSchema number", () => {
  const f = () => booleanSchema.parse(val.number);
  expect(f).toThrow();
});

test("parse booleanSchema boolean", () => {
  booleanSchema.parse(val.boolean);
});

test("parse booleanSchema undefined", () => {
  const f = () => booleanSchema.parse(val.undefined);
  expect(f).toThrow();
});

test("parse booleanSchema null", () => {
  const f = () => booleanSchema.parse(val.null);
  expect(f).toThrow();
});

// ==============

test("parse dateSchema string", () => {
  const f = () => dateSchema.parse(val.string);
  expect(f).toThrow();
});

test("parse dateSchema number", () => {
  const f = () => dateSchema.parse(val.number);
  expect(f).toThrow();
});

test("parse dateSchema boolean", () => {
  const f = () => dateSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("parse dateSchema date", () => {
  dateSchema.parse(val.date);
});

test("parse dateSchema undefined", () => {
  const f = () => dateSchema.parse(val.undefined);
  expect(f).toThrow();
});

test("parse dateSchema null", () => {
  const f = () => dateSchema.parse(val.null);
  expect(f).toThrow();
});

test("parse dateSchema invalid date", async () => {
  try {
    await dateSchema.parseAsync(new Date("invalid"));
  } catch (err) {
    expect((err as z.ZodError).issues[0].code).toEqual(
      z.ZodIssueCode.invalid_date
    );
  }
});
// ==============

test("parse undefinedSchema string", () => {
  const f = () => undefinedSchema.parse(val.string);
  expect(f).toThrow();
});

test("parse undefinedSchema number", () => {
  const f = () => undefinedSchema.parse(val.number);
  expect(f).toThrow();
});

test("parse undefinedSchema boolean", () => {
  const f = () => undefinedSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("parse undefinedSchema undefined", () => {
  undefinedSchema.parse(val.undefined);
});

test("parse undefinedSchema null", () => {
  const f = () => undefinedSchema.parse(val.null);
  expect(f).toThrow();
});

test("parse nullSchema string", () => {
  const f = () => nullSchema.parse(val.string);
  expect(f).toThrow();
});

test("parse nullSchema number", () => {
  const f = () => nullSchema.parse(val.number);
  expect(f).toThrow();
});

test("parse nullSchema boolean", () => {
  const f = () => nullSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("parse nullSchema undefined", () => {
  const f = () => nullSchema.parse(val.undefined);
  expect(f).toThrow();
});

test("parse nullSchema null", () => {
  nullSchema.parse(val.null);
});

export type AssertEqualTest = boolean | undefined extends true
  ? true extends boolean | undefined
    ? true
    : never
  : never;

type AssertEqual<X, Y> = (<T>() => T extends X ? 1 : 2) extends <
  T
>() => T extends Y ? 1 : 2
  ? true
  : never;

test("primitive inference", () => {
  const literalStringSchemaTest: AssertEqual<
    z.TypeOf<typeof literalStringSchema>,
    "asdf"
  > = true;
  const literalNumberSchemaTest: AssertEqual<
    z.TypeOf<typeof literalNumberSchema>,
    12
  > = true;
  const literalBooleanSchemaTest: AssertEqual<
    z.TypeOf<typeof literalBooleanSchema>,
    true
  > = true;
  const stringSchemaTest: AssertEqual<
    z.TypeOf<typeof stringSchema>,
    string
  > = true;
  const numberSchemaTest: AssertEqual<
    z.TypeOf<typeof numberSchema>,
    number
  > = true;
  const bigintSchemaTest: AssertEqual<
    z.TypeOf<typeof bigintSchema>,
    bigint
  > = true;
  const booleanSchemaTest: AssertEqual<
    z.TypeOf<typeof booleanSchema>,
    boolean
  > = true;
  const dateSchemaTest: AssertEqual<z.TypeOf<typeof dateSchema>, Date> = true;
  const nullSchemaTest: AssertEqual<z.TypeOf<typeof nullSchema>, null> = true;
  const undefinedSchemaTest: AssertEqual<
    z.TypeOf<typeof undefinedSchema>,
    undefined
  > = true;
  const stringSchemaOptionalTest: AssertEqual<
    z.TypeOf<typeof stringSchemaOptional>,
    string | undefined
  > = true;
  const stringSchemaNullableTest: AssertEqual<
    z.TypeOf<typeof stringSchemaNullable>,
    string | null
  > = true;
  const numberSchemaOptionalTest: AssertEqual<
    z.TypeOf<typeof numberSchemaOptional>,
    number | undefined
  > = true;
  const numberSchemaNullableTest: AssertEqual<
    z.TypeOf<typeof numberSchemaNullable>,
    number | null
  > = true;
  const bigintSchemaOptionalTest: AssertEqual<
    z.TypeOf<typeof bigintSchemaOptional>,
    bigint | undefined
  > = true;
  const bigintSchemaNullableTest: AssertEqual<
    z.TypeOf<typeof bigintSchemaNullable>,
    bigint | null
  > = true;
  const booleanSchemaOptionalTest: AssertEqual<
    z.TypeOf<typeof booleanSchemaOptional>,
    boolean | undefined
  > = true;
  const booleanSchemaNullableTest: AssertEqual<
    z.TypeOf<typeof booleanSchemaNullable>,
    boolean | null
  > = true;
  const dateSchemaOptionalTest: AssertEqual<
    z.TypeOf<typeof dateSchemaOptional>,
    Date | undefined
  > = true;
  const dateSchemaNullableTest: AssertEqual<
    z.TypeOf<typeof dateSchemaNullable>,
    Date | null
  > = true;

  [
    literalStringSchemaTest,
    literalNumberSchemaTest,
    literalBooleanSchemaTest,
    stringSchemaTest,
    numberSchemaTest,
    bigintSchemaTest,
    booleanSchemaTest,
    dateSchemaTest,
    nullSchemaTest,
    undefinedSchemaTest,
    stringSchemaOptionalTest,
    stringSchemaNullableTest,
    numberSchemaOptionalTest,
    numberSchemaNullableTest,
    bigintSchemaOptionalTest,
    bigintSchemaNullableTest,
    booleanSchemaOptionalTest,
    booleanSchemaNullableTest,
    dateSchemaOptionalTest,
    dateSchemaNullableTest,
  ];
});

test("get literal value", () => {
  expect(literalStringSchema.value).toEqual("asdf");
});

test("optional convenience methd", () => {
  z.ostring().parse(undefined);
  z.onumber().parse(undefined);
  z.oboolean().parse(undefined);
});
````

## File: deno/lib/__tests__/promise.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

const promSchema = z.promise(
  z.object({
    name: z.string(),
    age: z.number(),
  })
);

test("promise inference", () => {
  type promSchemaType = z.infer<typeof promSchema>;
  const t1: util.AssertEqual<
    promSchemaType,
    Promise<{ name: string; age: number }>
  > = true;
  expect(t1).toBeTruthy();
});

test("promise parsing success", async () => {
  const pr = promSchema.parse(Promise.resolve({ name: "Bobby", age: 10 }));
  expect(pr).toBeInstanceOf(Promise);
  const result = await pr;
  expect(typeof result).toBe("object");
  expect(typeof result.age).toBe("number");
  expect(typeof result.name).toBe("string");
});

test("promise parsing success 2", () => {
  const fakePromise = {
    then() {
      return this;
    },
    catch() {
      return this;
    },
  };
  promSchema.parse(fakePromise);
});

test("promise parsing fail", async () => {
  const bad = promSchema.parse(Promise.resolve({ name: "Bobby", age: "10" }));
  // return await expect(bad).resolves.toBe({ name: 'Bobby', age: '10' });
  return await expect(bad).rejects.toBeInstanceOf(z.ZodError);
  // done();
});

test("promise parsing fail 2", async () => {
  const failPromise = promSchema.parse(
    Promise.resolve({ name: "Bobby", age: "10" })
  );
  await expect(failPromise).rejects.toBeInstanceOf(z.ZodError);
  // done();/z
});

test("promise parsing fail", () => {
  const bad = () => promSchema.parse({ then: () => {}, catch: {} });
  expect(bad).toThrow();
});

// test('sync promise parsing', () => {
//   expect(() => z.promise(z.string()).parse(Promise.resolve('asfd'))).toThrow();
// });

const asyncFunction = z.function(z.tuple([]), promSchema);

test("async function pass", async () => {
  const validatedFunction = asyncFunction.implement(async () => {
    return { name: "jimmy", age: 14 };
  });
  await expect(validatedFunction()).resolves.toEqual({
    name: "jimmy",
    age: 14,
  });
});

test("async function fail", async () => {
  const validatedFunction = asyncFunction.implement(() => {
    return Promise.resolve("asdf" as any);
  });
  await expect(validatedFunction()).rejects.toBeInstanceOf(z.ZodError);
});

test("async promise parsing", () => {
  const res = z.promise(z.number()).parseAsync(Promise.resolve(12));
  expect(res).toBeInstanceOf(Promise);
});
````

## File: deno/lib/__tests__/record.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

const booleanRecord = z.record(z.boolean());
type booleanRecord = z.infer<typeof booleanRecord>;

const recordWithEnumKeys = z.record(z.enum(["Tuna", "Salmon"]), z.string());
type recordWithEnumKeys = z.infer<typeof recordWithEnumKeys>;

const recordWithLiteralKeys = z.record(
  z.union([z.literal("Tuna"), z.literal("Salmon")]),
  z.string()
);
type recordWithLiteralKeys = z.infer<typeof recordWithLiteralKeys>;

test("type inference", () => {
  const f1: util.AssertEqual<booleanRecord, Record<string, boolean>> = true;
  f1;

  const f2: util.AssertEqual<
    recordWithEnumKeys,
    Partial<Record<"Tuna" | "Salmon", string>>
  > = true;
  f2;
  const f3: util.AssertEqual<
    recordWithLiteralKeys,
    Partial<Record<"Tuna" | "Salmon", string>>
  > = true;
  f3;
});

test("methods", () => {
  booleanRecord.optional();
  booleanRecord.nullable();
});

test("string record parse - pass", () => {
  booleanRecord.parse({
    k1: true,
    k2: false,
    1234: false,
  });
});

test("string record parse - fail", () => {
  const badCheck = () =>
    booleanRecord.parse({
      asdf: 1234,
    } as any);
  expect(badCheck).toThrow();

  expect(() => booleanRecord.parse("asdf")).toThrow();
});

test("string record parse - fail", () => {
  const badCheck = () =>
    booleanRecord.parse({
      asdf: {},
    } as any);
  expect(badCheck).toThrow();
});

test("string record parse - fail", () => {
  const badCheck = () =>
    booleanRecord.parse({
      asdf: [],
    } as any);
  expect(badCheck).toThrow();
});

test("key schema", () => {
  const result1 = recordWithEnumKeys.parse({
    Tuna: "asdf",
    Salmon: "asdf",
  });
  expect(result1).toEqual({
    Tuna: "asdf",
    Salmon: "asdf",
  });

  const result2 = recordWithLiteralKeys.parse({
    Tuna: "asdf",
    Salmon: "asdf",
  });
  expect(result2).toEqual({
    Tuna: "asdf",
    Salmon: "asdf",
  });

  // shouldn't require us to specify all props in record
  const result3 = recordWithEnumKeys.parse({
    Tuna: "abcd",
  });
  expect(result3).toEqual({
    Tuna: "abcd",
  });

  // shouldn't require us to specify all props in record
  const result4 = recordWithLiteralKeys.parse({
    Salmon: "abcd",
  });
  expect(result4).toEqual({
    Salmon: "abcd",
  });

  expect(() =>
    recordWithEnumKeys.parse({
      Tuna: "asdf",
      Salmon: "asdf",
      Trout: "asdf",
    })
  ).toThrow();

  expect(() =>
    recordWithLiteralKeys.parse({
      Tuna: "asdf",
      Salmon: "asdf",

      Trout: "asdf",
    })
  ).toThrow();
});

// test("record element", () => {
//   expect(booleanRecord.element).toBeInstanceOf(z.ZodBoolean);
// });

test("key and value getters", () => {
  const rec = z.record(z.string(), z.number());

  rec.keySchema.parse("asdf");
  rec.valueSchema.parse(1234);
  rec.element.parse(1234);
});
````

## File: deno/lib/__tests__/recursive.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { z } from "../index.ts";

interface Category {
  name: string;
  subcategories: Category[];
}

const testCategory: Category = {
  name: "I",
  subcategories: [
    {
      name: "A",
      subcategories: [
        {
          name: "1",
          subcategories: [
            {
              name: "a",
              subcategories: [],
            },
          ],
        },
      ],
    },
  ],
};

test("recursion with z.late.object", () => {
  const Category: z.ZodType<Category> = z.late.object(() => ({
    name: z.string(),
    subcategories: z.array(Category),
  }));
  Category.parse(testCategory);
});

test("recursion with z.lazy", () => {
  const Category: z.ZodType<Category> = z.lazy(() =>
    z.object({
      name: z.string(),
      subcategories: z.array(Category),
    })
  );
  Category.parse(testCategory);
});

test("schema getter", () => {
  z.lazy(() => z.string()).schema.parse("asdf");
});
// interface A {
//   val: number;
//   b: B;
// }

// interface B {
//   val: number;
//   a: A;
// }

// const A: z.ZodType<A> = z.late.object(() => ({
//   val: z.number(),
//   b: B,
// }));

// const B: z.ZodType<B> = z.late.object(() => ({
//   val: z.number(),
//   a: A,
// }));

// const Alazy: z.ZodType<A> = z.lazy(() => z.object({
//   val: z.number(),
//   b: B,
// }));

// const Blazy: z.ZodType<B> = z.lazy(() => z.object({
//   val: z.number(),
//   a: A,
// }));

// const a: any = { val: 1 };
// const b: any = { val: 2 };
// a.b = b;
// b.a = a;

// test('valid check', () => {
//   A.parse(a);
//   B.parse(b);
// });

// test("valid check lazy", () => {
//   A.parse({val:1, b:});
//   B.parse(b);
// });

// test('masking check', () => {
//   const FragmentOnA = z
//     .object({
//       val: z.number(),
//       b: z
//         .object({
//           val: z.number(),
//           a: z
//             .object({
//               val: z.number(),
//             })
//             .nonstrict(),
//         })
//         .nonstrict(),
//     })
//     .nonstrict();

//   const fragment = FragmentOnA.parse(a);
//   fragment;
// });

// test('invalid check', () => {
//   expect(() => A.parse({} as any)).toThrow();
// });

// test('schema getter', () => {
//   (A as z.ZodLazy<any>).schema;
// });

// test("self recursion with cyclical data", () => {
//   interface Category {
//     name: string;
//     subcategories: Category[];
//   }

//   const Category: z.ZodType<Category> = z.late.object(() => ({
//     name: z.string(),
//     subcategories: z.array(Category),
//   }));

//   const untypedCategory: any = {
//     name: "Category A",
//   };
//   // creating a cycle
//   untypedCategory.subcategories = [untypedCategory];
//   Category.parse(untypedCategory);
// });

// test("self recursion with base type", () => {
//   const BaseCategory = z.object({
//     name: z.string(),
//   });
//   type BaseCategory = z.infer<typeof BaseCategory>;

//   type Category = BaseCategory & { subcategories: Category[] };

//   const Category: z.ZodType<Category> = z.late
//     .object(() => ({
//       subcategories: z.array(Category),
//     }))
//     .extend({
//       name: z.string(),
//     });

//   const untypedCategory: any = {
//     name: "Category A",
//   };
//   // creating a cycle
//   untypedCategory.subcategories = [untypedCategory];
//   Category.parse(untypedCategory); // parses successfully
// });
````

## File: deno/lib/__tests__/refine.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";
import { ZodIssueCode } from "../ZodError.ts";

test("refinement", () => {
  const obj1 = z.object({
    first: z.string(),
    second: z.string(),
  });
  const obj2 = obj1.partial().strict();

  const obj3 = obj2.refine(
    (data) => data.first || data.second,
    "Either first or second should be filled in."
  );

  expect(obj1 === (obj2 as any)).toEqual(false);
  expect(obj2 === (obj3 as any)).toEqual(false);

  expect(() => obj1.parse({})).toThrow();
  expect(() => obj2.parse({ third: "adsf" })).toThrow();
  expect(() => obj3.parse({})).toThrow();
  obj3.parse({ first: "a" });
  obj3.parse({ second: "a" });
  obj3.parse({ first: "a", second: "a" });
});

test("refinement 2", () => {
  const validationSchema = z
    .object({
      email: z.string().email(),
      password: z.string(),
      confirmPassword: z.string(),
    })
    .refine(
      (data) => data.password === data.confirmPassword,
      "Both password and confirmation must match"
    );

  expect(() =>
    validationSchema.parse({
      email: "aaaa@gmail.com",
      password: "aaaaaaaa",
      confirmPassword: "bbbbbbbb",
    })
  ).toThrow();
});

test("refinement type guard", () => {
  const validationSchema = z.object({
    a: z.string().refine((s): s is "a" => s === "a"),
  });
  type Schema = z.infer<typeof validationSchema>;

  const f1: util.AssertEqual<"a", Schema["a"]> = true;
  f1;
  const f2: util.AssertEqual<"string", Schema["a"]> = false;
  f2;
});

test("refinement Promise", async () => {
  const validationSchema = z
    .object({
      email: z.string().email(),
      password: z.string(),
      confirmPassword: z.string(),
    })
    .refine(
      (data) =>
        Promise.resolve().then(() => data.password === data.confirmPassword),
      "Both password and confirmation must match"
    );

  await validationSchema.parseAsync({
    email: "aaaa@gmail.com",
    password: "password",
    confirmPassword: "password",
  });
});

test("custom path", async () => {
  const result = await z
    .object({
      password: z.string(),
      confirm: z.string(),
    })
    .refine((data) => data.confirm === data.password, { path: ["confirm"] })
    .spa({ password: "asdf", confirm: "qewr" });
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].path).toEqual(["confirm"]);
  }
});

test("use path in refinement context", async () => {
  const noNested = z.string()._refinement((_val, ctx) => {
    if (ctx.path.length > 0) {
      ctx.addIssue({
        code: ZodIssueCode.custom,
        message: `schema cannot be nested. path: ${ctx.path.join(".")}`,
      });
      return false;
    } else {
      return true;
    }
  });

  const data = z.object({
    foo: noNested,
  });

  const t1 = await noNested.spa("asdf");
  const t2 = await data.spa({ foo: "asdf" });

  expect(t1.success).toBe(true);
  expect(t2.success).toBe(false);
  if (t2.success === false) {
    expect(t2.error.issues[0].message).toEqual(
      "schema cannot be nested. path: foo"
    );
  }
});

test("superRefine", () => {
  const Strings = z.array(z.string()).superRefine((val, ctx) => {
    if (val.length > 3) {
      ctx.addIssue({
        code: z.ZodIssueCode.too_big,
        maximum: 3,
        type: "array",
        inclusive: true,
        message: "Too many items 😡",
      });
    }

    if (val.length !== new Set(val).size) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `No duplicates allowed.`,
      });
    }
  });

  const result = Strings.safeParse(["asfd", "asfd", "asfd", "asfd"]);

  expect(result.success).toEqual(false);
  if (!result.success) expect(result.error.issues.length).toEqual(2);

  Strings.parse(["asfd", "qwer"]);
});

test("get inner type", () => {
  z.string()
    .refine(() => true)
    .innerType()
    .parse("asdf");
});

test("chained refinements", () => {
  const objectSchema = z
    .object({
      length: z.number(),
      size: z.number(),
    })
    .refine(({ length }) => length > 5, {
      path: ["length"],
      message: "length greater than 5",
    })
    .refine(({ size }) => size > 7, {
      path: ["size"],
      message: "size greater than 7",
    });
  const r1 = objectSchema.safeParse({
    length: 4,
    size: 9,
  });
  expect(r1.success).toEqual(false);
  if (!r1.success) expect(r1.error.issues.length).toEqual(1);

  const r2 = objectSchema.safeParse({
    length: 4,
    size: 3,
  });
  expect(r2.success).toEqual(false);
  if (!r2.success) expect(r2.error.issues.length).toEqual(2);
});

test("fatal superRefine", () => {
  const Strings = z
    .string()
    .superRefine((val, ctx) => {
      if (val === "") {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "foo",
          fatal: true,
        });
      }
    })
    .superRefine((val, ctx) => {
      if (val !== " ") {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "bar",
        });
      }
    });

  const result = Strings.safeParse("");

  expect(result.success).toEqual(false);
  if (!result.success) expect(result.error.issues.length).toEqual(1);
});
````

## File: deno/lib/__tests__/safeparse.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";
const stringSchema = z.string();

test("safeparse fail", () => {
  const safe = stringSchema.safeParse(12);
  expect(safe.success).toEqual(false);
  expect((safe as any).error).toBeInstanceOf(z.ZodError);
});

test("safeparse pass", () => {
  const safe = stringSchema.safeParse("12");
  expect(safe.success).toEqual(true);
  expect((safe as any).data).toEqual("12");
});

test("safeparse unexpected error", () => {
  expect(() =>
    stringSchema
      .refine((data) => {
        throw new Error(data);
      })
      .safeParse("12")
  ).toThrow();
});
````

## File: deno/lib/__tests__/set.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";
import { ZodIssueCode } from "../index.ts";

const stringSet = z.set(z.string());
type stringSet = z.infer<typeof stringSet>;

const minTwo = z.set(z.string()).min(2);
const maxTwo = z.set(z.string()).max(2);
const justTwo = z.set(z.string()).size(2);
const nonEmpty = z.set(z.string()).nonempty();
const nonEmptyMax = z.set(z.string()).nonempty().max(2);

test("type inference", () => {
  const f1: util.AssertEqual<stringSet, Set<string>> = true;
  f1;
});

test("valid parse", () => {
  const result = stringSet.safeParse(new Set(["first", "second"]));
  expect(result.success).toEqual(true);
  if (result.success) {
    expect(result.data.has("first")).toEqual(true);
    expect(result.data.has("second")).toEqual(true);
    expect(result.data.has("third")).toEqual(false);
  }

  expect(() => {
    minTwo.parse(new Set(["a", "b"]));
    minTwo.parse(new Set(["a", "b", "c"]));
    maxTwo.parse(new Set(["a", "b"]));
    maxTwo.parse(new Set(["a"]));
    justTwo.parse(new Set(["a", "b"]));
    nonEmpty.parse(new Set(["a"]));
    nonEmptyMax.parse(new Set(["a"]));
  }).not.toThrow();
});

test("valid parse async", async () => {
  const result = await stringSet.spa(new Set(["first", "second"]));
  expect(result.success).toEqual(true);
  if (result.success) {
    expect(result.data.has("first")).toEqual(true);
    expect(result.data.has("second")).toEqual(true);
    expect(result.data.has("third")).toEqual(false);
  }

  const asyncResult = await stringSet.safeParse(new Set(["first", "second"]));
  expect(asyncResult.success).toEqual(true);
  if (asyncResult.success) {
    expect(asyncResult.data.has("first")).toEqual(true);
    expect(asyncResult.data.has("second")).toEqual(true);
    expect(asyncResult.data.has("third")).toEqual(false);
  }
});

test("valid parse: size-related methods", () => {
  expect(() => {
    minTwo.parse(new Set(["a", "b"]));
    minTwo.parse(new Set(["a", "b", "c"]));
    maxTwo.parse(new Set(["a", "b"]));
    maxTwo.parse(new Set(["a"]));
    justTwo.parse(new Set(["a", "b"]));
    nonEmpty.parse(new Set(["a"]));
    nonEmptyMax.parse(new Set(["a"]));
  }).not.toThrow();

  const sizeZeroResult = stringSet.parse(new Set());
  expect(sizeZeroResult.size).toBe(0);

  const sizeTwoResult = minTwo.parse(new Set(["a", "b"]));
  expect(sizeTwoResult.size).toBe(2);
});

test("failing when parsing empty set in nonempty ", () => {
  const result = nonEmpty.safeParse(new Set());
  expect(result.success).toEqual(false);

  if (result.success === false) {
    expect(result.error.issues.length).toEqual(1);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.too_small);
  }
});

test("failing when set is smaller than min() ", () => {
  const result = minTwo.safeParse(new Set(["just_one"]));
  expect(result.success).toEqual(false);

  if (result.success === false) {
    expect(result.error.issues.length).toEqual(1);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.too_small);
  }
});

test("failing when set is bigger than max() ", () => {
  const result = maxTwo.safeParse(new Set(["one", "two", "three"]));
  expect(result.success).toEqual(false);

  if (result.success === false) {
    expect(result.error.issues.length).toEqual(1);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.too_big);
  }
});

test("doesn’t throw when an empty set is given", () => {
  const result = stringSet.safeParse(new Set([]));
  expect(result.success).toEqual(true);
});

test("throws when a Map is given", () => {
  const result = stringSet.safeParse(new Map([]));
  expect(result.success).toEqual(false);
  if (result.success === false) {
    expect(result.error.issues.length).toEqual(1);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
  }
});

test("throws when the given set has invalid input", () => {
  const result = stringSet.safeParse(new Set([Symbol()]));
  expect(result.success).toEqual(false);
  if (result.success === false) {
    expect(result.error.issues.length).toEqual(1);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[0].path).toEqual([0]);
  }
});

test("throws when the given set has multiple invalid entries", () => {
  const result = stringSet.safeParse(new Set([1, 2] as any[]) as Set<any>);

  expect(result.success).toEqual(false);
  if (result.success === false) {
    expect(result.error.issues.length).toEqual(2);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[0].path).toEqual([0]);
    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[1].path).toEqual([1]);
  }
});
````

## File: deno/lib/__tests__/string.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

const minFive = z.string().min(5, "min5");
const maxFive = z.string().max(5, "max5");
const justFive = z.string().length(5);
const nonempty = z.string().nonempty("nonempty");

test("passing validations", () => {
  minFive.parse("12345");
  minFive.parse("123456");
  maxFive.parse("12345");
  maxFive.parse("1234");
  nonempty.parse("1");
  justFive.parse("12345");
});

test("failing validations", () => {
  expect(() => minFive.parse("1234")).toThrow();
  expect(() => maxFive.parse("123456")).toThrow();
  expect(() => nonempty.parse("")).toThrow();
  expect(() => justFive.parse("1234")).toThrow();
  expect(() => justFive.parse("123456")).toThrow();
});

test("email validations", () => {
  const email = z.string().email();
  email.parse("mojojojo@example.com");
  expect(() => email.parse("asdf")).toThrow();
  expect(() => email.parse("@lkjasdf.com")).toThrow();
  expect(() => email.parse("asdf@sdf.")).toThrow();
});

test("more email validations", () => {
  const data = [
    `"josé.arrañoça"@domain.com`,
    `"сайт"@domain.com`,
    `"💩"@domain.com`,
    `"🍺🕺🎉"@domain.com`,
    `poop@💩.la`,
    `"🌮"@i❤️tacos.ws`,
  ];
  const email = z.string().email();
  for (const datum of data) {
    email.parse(datum);
  }
});

test("url validations", () => {
  const url = z.string().url();
  try {
    url.parse("http://google.com");
    url.parse("https://google.com/asdf?asdf=ljk3lk4&asdf=234#asdf");
    expect(() => url.parse("asdf")).toThrow();
    expect(() => url.parse("https:/")).toThrow();
    expect(() => url.parse("asdfj@lkjsdf.com")).toThrow();
  } catch (err) {}
});

test("url error overrides", () => {
  try {
    z.string().url().parse("https");
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual("Invalid url");
  }
  try {
    z.string().url("badurl").parse("https");
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual("badurl");
  }
  try {
    z.string().url({ message: "badurl" }).parse("https");
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual("badurl");
  }
});

test("uuid", () => {
  const uuid = z.string().uuid("custom error");
  uuid.parse("9491d710-3185-4e06-bea0-6a2f275345e0");
  uuid.parse("00000000-0000-0000-0000-000000000000");
  uuid.parse("b3ce60f8-e8b9-40f5-1150-172ede56ff74"); // Variant 0 - RFC 4122: Reserved, NCS backward compatibility
  uuid.parse("92e76bf9-28b3-4730-cd7f-cb6bc51f8c09"); // Variant 2 - RFC 4122: Reserved, Microsoft Corporation backward compatibility
  const result = uuid.safeParse("9491d710-3185-4e06-bea0-6a2f275345e0X");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].message).toEqual("custom error");
  }
});

test("bad uuid", () => {
  const uuid = z.string().uuid("custom error");
  uuid.parse("9491d710-3185-4e06-bea0-6a2f275345e0");
  const result = uuid.safeParse("invalid uuid");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].message).toEqual("custom error");
  }
});

test("cuid", () => {
  const cuid = z.string().cuid();
  cuid.parse("ckopqwooh000001la8mbi2im9");
  const result = cuid.safeParse("cifjhdsfhsd-invalid-cuid");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].message).toEqual("Invalid cuid");
  }
});

test("regex", () => {
  z.string()
    .regex(/^moo+$/)
    .parse("mooooo");
  expect(() => z.string().uuid().parse("purr")).toThrow();
});

test("regexp error message", () => {
  const result = z
    .string()
    .regex(/^moo+$/)
    .safeParse("boooo");
  if (!result.success) {
    expect(result.error.issues[0].message).toEqual("Invalid");
  } else {
    throw new Error("validation should have failed");
  }

  expect(() => z.string().uuid().parse("purr")).toThrow();
});

test("regex lastIndex reset", () => {
  const schema = z.string().regex(/^\d+$/g);
  expect(schema.safeParse("123").success).toEqual(true);
  expect(schema.safeParse("123").success).toEqual(true);
  expect(schema.safeParse("123").success).toEqual(true);
  expect(schema.safeParse("123").success).toEqual(true);
  expect(schema.safeParse("123").success).toEqual(true);
});

test("checks getters", () => {
  expect(z.string().email().isEmail).toEqual(true);
  expect(z.string().email().isURL).toEqual(false);
  expect(z.string().email().isCUID).toEqual(false);
  expect(z.string().email().isUUID).toEqual(false);

  expect(z.string().url().isEmail).toEqual(false);
  expect(z.string().url().isURL).toEqual(true);
  expect(z.string().url().isCUID).toEqual(false);
  expect(z.string().url().isUUID).toEqual(false);

  expect(z.string().cuid().isEmail).toEqual(false);
  expect(z.string().cuid().isURL).toEqual(false);
  expect(z.string().cuid().isCUID).toEqual(true);
  expect(z.string().cuid().isUUID).toEqual(false);

  expect(z.string().uuid().isEmail).toEqual(false);
  expect(z.string().uuid().isURL).toEqual(false);
  expect(z.string().uuid().isCUID).toEqual(false);
  expect(z.string().uuid().isUUID).toEqual(true);
});

test("min max getters", () => {
  expect(z.string().min(5).minLength).toEqual(5);
  expect(z.string().min(5).min(10).minLength).toEqual(10);

  expect(z.string().max(5).maxLength).toEqual(5);
  expect(z.string().max(5).max(1).maxLength).toEqual(1);
});
````

## File: deno/lib/__tests__/transformer.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";

const stringToNumber = z.string().transform((arg) => parseFloat(arg));
// const numberToString = z
//   .transformer(z.number())
//   .transform((n) => String(n));
const asyncNumberToString = z.number().transform(async (n) => String(n));

test("basic transformations", () => {
  const r1 = z
    .string()
    .transform((data) => data.length)
    .parse("asdf");
  expect(r1).toEqual(4);
});

test("coercion", () => {
  const numToString = z.number().transform((n) => String(n));
  const data = z
    .object({
      id: numToString,
    })
    .parse({ id: 5 });

  expect(data).toEqual({ id: "5" });
});

test("async coercion", async () => {
  const numToString = z.number().transform(async (n) => String(n));
  const data = await z
    .object({
      id: numToString,
    })
    .parseAsync({ id: 5 });

  expect(data).toEqual({ id: "5" });
});

test("sync coercion async error", async () => {
  expect(() =>
    z
      .object({
        id: asyncNumberToString,
      })
      .parse({ id: 5 })
  ).toThrow();
  // expect(data).toEqual({ id: '5' });
});

test("default", () => {
  const data = z.string().default("asdf").parse(undefined); // => "asdf"
  expect(data).toEqual("asdf");
});

test("dynamic default", () => {
  const data = z
    .string()
    .default(() => "string")
    .parse(undefined); // => "asdf"
  expect(data).toEqual("string");
});

test("default when property is null or undefined", () => {
  const data = z
    .object({
      foo: z.boolean().nullable().default(true),
      bar: z.boolean().default(true),
    })
    .parse({ foo: null });

  expect(data).toEqual({ foo: null, bar: true });
});

test("default with falsy values", () => {
  const schema = z.object({
    emptyStr: z.string().default("def"),
    zero: z.number().default(5),
    falseBoolean: z.boolean().default(true),
  });
  const input = { emptyStr: "", zero: 0, falseBoolean: true };
  const output = schema.parse(input);
  // defaults are not supposed to be used
  expect(output).toEqual(input);
});

test("object typing", () => {
  const t1 = z.object({
    stringToNumber,
  });

  type t1 = z.input<typeof t1>;
  type t2 = z.output<typeof t1>;

  const f1: util.AssertEqual<t1, { stringToNumber: string }> = true;
  const f2: util.AssertEqual<t2, { stringToNumber: number }> = true;
  f1;
  f2;
});

test("transform method overloads", () => {
  const t1 = z.string().transform((val) => val.toUpperCase());
  expect(t1.parse("asdf")).toEqual("ASDF");

  const t2 = z.string().transform((val) => val.length);
  expect(t2.parse("asdf")).toEqual(4);
});

test("multiple transformers", () => {
  const doubler = stringToNumber.transform((val) => {
    return val * 2;
  });
  expect(doubler.parse("5")).toEqual(10);
});

test("preprocess", () => {
  const schema = z.preprocess((data) => [data], z.string().array());

  const value = schema.parse("asdf");
  expect(value).toEqual(["asdf"]);
});

test("async preprocess", async () => {
  const schema = z.preprocess(async (data) => [data], z.string().array());

  const value = await schema.parseAsync("asdf");
  expect(value).toEqual(["asdf"]);
});

test("short circuit on dirty", () => {
  const schema = z
    .string()
    .refine(() => false)
    .transform((val) => val.toUpperCase());
  const result = schema.safeParse("asdf");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);
  }

  const result2 = schema.safeParse(1234);
  expect(result2.success).toEqual(false);
  if (!result2.success) {
    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);
  }
});

test("async short circuit on dirty", async () => {
  const schema = z
    .string()
    .refine(() => false)
    .transform((val) => val.toUpperCase());
  const result = await schema.spa("asdf");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);
  }

  const result2 = await schema.spa(1234);
  expect(result2.success).toEqual(false);
  if (!result2.success) {
    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);
  }
});
````

## File: deno/lib/__tests__/tuple.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";
import { ZodError } from "../ZodError.ts";

const testTuple = z.tuple([
  z.string(),
  z.object({ name: z.literal("Rudy") }),
  z.array(z.literal("blue")),
]);
const testData = ["asdf", { name: "Rudy" }, ["blue"]];
const badData = [123, { name: "Rudy2" }, ["blue", "red"]];

test("tuple inference", () => {
  const args1 = z.tuple([z.string()]);
  const returns1 = z.number();
  const func1 = z.function(args1, returns1);
  type func1 = z.TypeOf<typeof func1>;
  const t1: util.AssertEqual<func1, (k: string) => number> = true;
  [t1];
});

test("successful validation", () => {
  const val = testTuple.parse(testData);
  expect(val).toEqual(["asdf", { name: "Rudy" }, ["blue"]]);
});

test("successful async validation", async () => {
  const val = await testTuple.parseAsync(testData);
  return expect(val).toEqual(testData);
});

test("failed validation", () => {
  const checker = () => {
    testTuple.parse([123, { name: "Rudy2" }, ["blue", "red"]] as any);
  };
  try {
    checker();
  } catch (err) {
    if (err instanceof ZodError) {
      expect(err.issues.length).toEqual(3);
    }
  }
});

test("failed async validation", async () => {
  const res = await testTuple.safeParse(badData);
  expect(res.success).toEqual(false);
  if (!res.success) {
    expect(res.error.issues.length).toEqual(3);
  }
  // try {
  //   checker();
  // } catch (err) {
  //   if (err instanceof ZodError) {
  //     expect(err.issues.length).toEqual(3);
  //   }
  // }
});

test("tuple with transformers", () => {
  const stringToNumber = z.string().transform((val) => val.length);
  const val = z.tuple([stringToNumber]);

  type t1 = z.input<typeof val>;
  const f1: util.AssertEqual<t1, [string]> = true;
  type t2 = z.output<typeof val>;
  const f2: util.AssertEqual<t2, [number]> = true;
  expect(val.parse(["1234"])).toEqual([4]);
  f1;
  f2;
});

test("tuple with rest schema", () => {
  const myTuple = z.tuple([z.string(), z.number()]).rest(z.boolean());
  expect(myTuple.parse(["asdf", 1234, true, false, true])).toEqual([
    "asdf",
    1234,
    true,
    false,
    true,
  ]);

  expect(myTuple.parse(["asdf", 1234])).toEqual(["asdf", 1234]);

  expect(() => myTuple.parse(["asdf", 1234, "asdf"])).toThrow();
  type t1 = z.output<typeof myTuple>;

  const f1: util.AssertEqual<t1, [string, number, ...boolean[]]> = true;
  f1;
});

// test('tuple with optional elements', () => {
//   const result = z
//     .tuple([z.string(), z.number().optional()])
//     .safeParse(['asdf']);
//   expect(result).toEqual(['asdf']);
// });
````

## File: deno/lib/__tests__/unions.test.ts
````typescript
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

test("function parsing", () => {
  const schema = z.union([
    z.string().refine(() => false),
    z.number().refine(() => false),
  ]);
  const result = schema.safeParse("asdf");
  expect(result.success).toEqual(false);
});

test("union 2", () => {
  const result = z
    .union([z.number(), z.string().refine(() => false)])
    .safeParse("a");
  expect(result.success).toEqual(false);
});

test("return valid over invalid", () => {
  const schema = z.union([
    z.object({
      email: z.string().email(),
    }),
    z.string(),
  ]);
  expect(schema.parse("asdf")).toEqual("asdf");
  expect(schema.parse({ email: "asdlkjf@lkajsdf.com" })).toEqual({
    email: "asdlkjf@lkajsdf.com",
  });
});

test("return dirty result over aborted", () => {
  const result = z
    .union([z.number(), z.string().refine(() => false)])
    .safeParse("a");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues).toEqual([
      {
        code: "custom",
        message: "Invalid input",
        path: [],
      },
    ]);
  }
});

test("options getter", async () => {
  const union = z.union([z.string(), z.number()]);
  union.options[0].parse("asdf");
  union.options[1].parse(1234);
  await union.options[0].parseAsync("asdf");
  await union.options[1].parseAsync(1234);
});

test("readonly union", async () => {
  const options = [z.string(), z.number()] as const;
  const union = z.union(options);
  union.parse("asdf");
  union.parse(12);
});
````

## File: deno/lib/__tests__/validations.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import * as z from "../index.ts";

test("array min", async () => {
  try {
    await z.array(z.string()).min(4).parseAsync([]);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Array must contain at least 4 element(s)"
    );
  }
});

test("array max", async () => {
  try {
    await z.array(z.string()).max(2).parseAsync(["asdf", "asdf", "asdf"]);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Array must contain at most 2 element(s)"
    );
  }
});

test("string min", async () => {
  try {
    await z.string().min(4).parseAsync("asd");
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "String must contain at least 4 character(s)"
    );
  }
});

test("string max", async () => {
  try {
    await z.string().max(4).parseAsync("aasdfsdfsd");
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "String must contain at most 4 character(s)"
    );
  }
});

test("number min", async () => {
  try {
    await z.number().gte(3).parseAsync(2);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Number must be greater than or equal to 3"
    );
  }
});

test("number max", async () => {
  try {
    await z.number().lte(3).parseAsync(4);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Number must be less than or equal to 3"
    );
  }
});

test("number nonnegative", async () => {
  try {
    await z.number().nonnegative().parseAsync(-1);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Number must be greater than or equal to 0"
    );
  }
});

test("number nonpositive", async () => {
  try {
    await z.number().nonpositive().parseAsync(1);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Number must be less than or equal to 0"
    );
  }
});

test("number negative", async () => {
  try {
    await z.number().negative().parseAsync(1);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Number must be less than 0"
    );
  }
});

test("number positive", async () => {
  try {
    await z.number().positive().parseAsync(-1);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Number must be greater than 0"
    );
  }
});

test("instantiation", () => {
  z.string().min(5);
  z.string().max(5);
  z.string().length(5);
  z.string().email();
  z.string().url();
  z.string().uuid();
  z.string().min(5, { message: "Must be 5 or more characters long" });
  z.string().max(5, { message: "Must be 5 or fewer characters long" });
  z.string().length(5, { message: "Must be exactly 5 characters long" });
  z.string().email({ message: "Invalid email address." });
  z.string().url({ message: "Invalid url" });
  z.string().uuid({ message: "Invalid UUID" });
});

test("int", async () => {
  const int = z.number().int();
  int.parse(4);
  expect(() => int.parse(3.5)).toThrow();
});
````

## File: deno/lib/__tests__/void.test.ts
````typescript
// @ts-ignore TS6133
import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";
const test = Deno.test;

import { util } from "../helpers/util.ts";
import * as z from "../index.ts";
test("void", () => {
  const v = z.void();
  v.parse(undefined);

  expect(() => v.parse(null)).toThrow();
  expect(() => v.parse("")).toThrow();

  type v = z.infer<typeof v>;
  const t1: util.AssertEqual<v, void> = true;
  t1;
});
````

## File: deno/lib/benchmarks/discriminatedUnion.ts
````typescript
import Benchmark from "benchmark";

import { z } from "../index.ts";

const doubleSuite = new Benchmark.Suite("z.discriminatedUnion: double");
const manySuite = new Benchmark.Suite("z.discriminatedUnion: many");

const aSchema = z.object({
  type: z.literal("a"),
});
const objA = {
  type: "a",
};

const bSchema = z.object({
  type: z.literal("b"),
});
const objB = {
  type: "b",
};

const cSchema = z.object({
  type: z.literal("c"),
});
const objC = {
  type: "c",
};

const dSchema = z.object({
  type: z.literal("d"),
});

const double = z.discriminatedUnion("type", [aSchema, bSchema]);
const many = z.discriminatedUnion("type", [aSchema, bSchema, cSchema, dSchema]);

doubleSuite
  .add("valid: a", () => {
    double.parse(objA);
  })
  .add("valid: b", () => {
    double.parse(objB);
  })
  .add("invalid: null", () => {
    try {
      double.parse(null);
    } catch (err) {}
  })
  .add("invalid: wrong shape", () => {
    try {
      double.parse(objC);
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(doubleSuite as any).name}: ${e.target}`);
  });

manySuite
  .add("valid: a", () => {
    many.parse(objA);
  })
  .add("valid: c", () => {
    many.parse(objC);
  })
  .add("invalid: null", () => {
    try {
      many.parse(null);
    } catch (err) {}
  })
  .add("invalid: wrong shape", () => {
    try {
      many.parse({ type: "unknown" });
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(manySuite as any).name}: ${e.target}`);
  });

export default {
  suites: [doubleSuite, manySuite],
};
````

## File: deno/lib/benchmarks/index.ts
````typescript
import discriminatedUnionBenchmarks from "./discriminatedUnion.ts";
import objectBenchmarks from "./object.ts";
import primitiveBenchmarks from "./primitives.ts";
import realworld from "./realworld.ts";
import stringBenchmarks from "./string.ts";
import unionBenchmarks from "./union.ts";

for (const suite of [
  ...realworld.suites,
  ...primitiveBenchmarks.suites,
  ...stringBenchmarks.suites,
  ...objectBenchmarks.suites,
  ...unionBenchmarks.suites,
  ...discriminatedUnionBenchmarks.suites,
]) {
  suite.run();
}
````

## File: deno/lib/benchmarks/object.ts
````typescript
import Benchmark from "benchmark";

import { z } from "../index.ts";

const emptySuite = new Benchmark.Suite("z.object: empty");
const shortSuite = new Benchmark.Suite("z.object: short");
const longSuite = new Benchmark.Suite("z.object: long");

const empty = z.object({});
const short = z.object({
  string: z.string(),
});
const long = z.object({
  string: z.string(),
  number: z.number(),
  boolean: z.boolean(),
});

emptySuite
  .add("valid", () => {
    empty.parse({});
  })
  .add("valid: extra keys", () => {
    empty.parse({ string: "string" });
  })
  .add("invalid: null", () => {
    try {
      empty.parse(null);
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(emptySuite as any).name}: ${e.target}`);
  });

shortSuite
  .add("valid", () => {
    short.parse({ string: "string" });
  })
  .add("valid: extra keys", () => {
    short.parse({ string: "string", number: 42 });
  })
  .add("invalid: null", () => {
    try {
      short.parse(null);
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(shortSuite as any).name}: ${e.target}`);
  });

longSuite
  .add("valid", () => {
    long.parse({ string: "string", number: 42, boolean: true });
  })
  .add("valid: extra keys", () => {
    long.parse({ string: "string", number: 42, boolean: true, list: [] });
  })
  .add("invalid: null", () => {
    try {
      long.parse(null);
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(longSuite as any).name}: ${e.target}`);
  });

export default {
  suites: [emptySuite, shortSuite, longSuite],
};
````

## File: deno/lib/benchmarks/primitives.ts
````typescript
import Benchmark from "benchmark";

import { z } from "../index.ts";

const enumSuite = new Benchmark.Suite("z.enum");
const enumSchema = z.enum(["a", "b", "c"]);

enumSuite
  .add("valid", () => {
    enumSchema.parse("a");
  })
  .add("invalid", () => {
    try {
      enumSchema.parse("x");
    } catch (e) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`z.enum: ${e.target}`);
  });

const undefinedSuite = new Benchmark.Suite("z.undefined");
const undefinedSchema = z.undefined();

undefinedSuite
  .add("valid", () => {
    undefinedSchema.parse(undefined);
  })
  .add("invalid", () => {
    try {
      undefinedSchema.parse(1);
    } catch (e) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`z.undefined: ${e.target}`);
  });

const literalSuite = new Benchmark.Suite("z.literal");
const short = "short";
const bad = "bad";
const literalSchema = z.literal("short");

literalSuite
  .add("valid", () => {
    literalSchema.parse(short);
  })
  .add("invalid", () => {
    try {
      literalSchema.parse(bad);
    } catch (e) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`z.literal: ${e.target}`);
  });

const numberSuite = new Benchmark.Suite("z.number");
const numberSchema = z.number().int();

numberSuite
  .add("valid", () => {
    numberSchema.parse(1);
  })
  .add("invalid type", () => {
    try {
      numberSchema.parse("bad");
    } catch (e) {}
  })
  .add("invalid number", () => {
    try {
      numberSchema.parse(0.5);
    } catch (e) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`z.number: ${e.target}`);
  });

export default {
  suites: [enumSuite, undefinedSuite, literalSuite, numberSuite],
};
````

## File: deno/lib/benchmarks/realworld.ts
````typescript
import Benchmark from "benchmark";

import { z } from "../index.ts";

const shortSuite = new Benchmark.Suite("realworld");

const People = z.array(
  z.object({
    type: z.literal("person"),
    hair: z.enum(["blue", "brown"]),
    active: z.boolean(),
    name: z.string(),
    age: z.number().int(),
    hobbies: z.array(z.string()),
    address: z.object({
      street: z.string(),
      zip: z.string(),
      country: z.string(),
    }),
  })
);

let i = 0;

function num() {
  return ++i;
}

function str() {
  return (++i % 100).toString(16);
}

function array<T>(fn: () => T): T[] {
  return Array.from({ length: ++i % 10 }, () => fn());
}

const people = Array.from({ length: 100 }, () => {
  return {
    type: "person",
    hair: i % 2 ? "blue" : "brown",
    active: !!(i % 2),
    name: str(),
    age: num(),
    hobbies: array(str),
    address: {
      street: str(),
      zip: str(),
      country: str(),
    },
  };
});

shortSuite
  .add("valid", () => {
    People.parse(people);
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(shortSuite as any).name}: ${e.target}`);
  });

export default {
  suites: [shortSuite],
};
````

## File: deno/lib/benchmarks/string.ts
````typescript
import Benchmark from "benchmark";

import { z } from "../index.ts";

const SUITE_NAME = "z.string";
const suite = new Benchmark.Suite(SUITE_NAME);

const empty = "";
const short = "short";
const long = "long".repeat(256);
const manual = (str: unknown) => {
  if (typeof str !== "string") {
    throw new Error("Not a string");
  }

  return str;
};
const stringSchema = z.string();
const optionalStringSchema = z.string().optional();
const optionalNullableStringSchema = z.string().optional().nullable();

suite
  .add("empty string", () => {
    stringSchema.parse(empty);
  })
  .add("short string", () => {
    stringSchema.parse(short);
  })
  .add("long string", () => {
    stringSchema.parse(long);
  })
  .add("optional string", () => {
    optionalStringSchema.parse(long);
  })
  .add("nullable string", () => {
    optionalNullableStringSchema.parse(long);
  })
  .add("nullable (null) string", () => {
    optionalNullableStringSchema.parse(null);
  })
  .add("invalid: null", () => {
    try {
      stringSchema.parse(null);
    } catch (err) {}
  })
  .add("manual parser: long", () => {
    manual(long);
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${SUITE_NAME}: ${e.target}`);
  });

export default {
  suites: [suite],
};
````

## File: deno/lib/benchmarks/union.ts
````typescript
import Benchmark from "benchmark";

import { z } from "../index.ts";

const doubleSuite = new Benchmark.Suite("z.union: double");
const manySuite = new Benchmark.Suite("z.union: many");

const aSchema = z.object({
  type: z.literal("a"),
});
const objA = {
  type: "a",
};

const bSchema = z.object({
  type: z.literal("b"),
});
const objB = {
  type: "b",
};

const cSchema = z.object({
  type: z.literal("c"),
});
const objC = {
  type: "c",
};

const dSchema = z.object({
  type: z.literal("d"),
});

const double = z.union([aSchema, bSchema]);
const many = z.union([aSchema, bSchema, cSchema, dSchema]);

doubleSuite
  .add("valid: a", () => {
    double.parse(objA);
  })
  .add("valid: b", () => {
    double.parse(objB);
  })
  .add("invalid: null", () => {
    try {
      double.parse(null);
    } catch (err) {}
  })
  .add("invalid: wrong shape", () => {
    try {
      double.parse(objC);
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(doubleSuite as any).name}: ${e.target}`);
  });

manySuite
  .add("valid: a", () => {
    many.parse(objA);
  })
  .add("valid: c", () => {
    many.parse(objC);
  })
  .add("invalid: null", () => {
    try {
      many.parse(null);
    } catch (err) {}
  })
  .add("invalid: wrong shape", () => {
    try {
      many.parse({ type: "unknown" });
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(manySuite as any).name}: ${e.target}`);
  });

export default {
  suites: [doubleSuite, manySuite],
};
````

## File: deno/lib/helpers/errorUtil.ts
````typescript
export namespace errorUtil {
  export type ErrMessage = string | { message?: string };
  export const errToObj = (message?: ErrMessage) =>
    typeof message === "string" ? { message } : message || {};
  export const toString = (message?: ErrMessage): string | undefined =>
    typeof message === "string" ? message : message?.message;
}
````

## File: deno/lib/helpers/parseUtil.ts
````typescript
import {
  defaultErrorMap,
  IssueData,
  overrideErrorMap,
  ZodErrorMap,
  ZodIssue,
} from "../ZodError.ts";
import { util } from "./util.ts";

export const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set",
]);

export type ZodParsedType = keyof typeof ZodParsedType;

export const getParsedType = (data: any): ZodParsedType => {
  const t = typeof data;

  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;

    case "string":
      return ZodParsedType.string;

    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;

    case "boolean":
      return ZodParsedType.boolean;

    case "function":
      return ZodParsedType.function;

    case "bigint":
      return ZodParsedType.bigint;

    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (
        data.then &&
        typeof data.then === "function" &&
        data.catch &&
        typeof data.catch === "function"
      ) {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;

    default:
      return ZodParsedType.unknown;
  }
};

export const makeIssue = (params: {
  data: any;
  path: (string | number)[];
  errorMaps: ZodErrorMap[];
  issueData: IssueData;
}): ZodIssue => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...(issueData.path || [])];
  const fullIssue = {
    ...issueData,
    path: fullPath,
  };

  let errorMessage = "";
  const maps = errorMaps
    .filter((m) => !!m)
    .slice()
    .reverse() as ZodErrorMap[];
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }

  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage,
  };
};

export type ParseParams = {
  path: (string | number)[];
  errorMap: ZodErrorMap;
  async: boolean;
};

export type ParsePathComponent = string | number;
export type ParsePath = ParsePathComponent[];
export const EMPTY_PATH: ParsePath = [];

export interface ParseContext {
  readonly common: {
    readonly issues: ZodIssue[];
    readonly contextualErrorMap?: ZodErrorMap;
    readonly async: boolean;
    readonly typeCache: Map<any, ZodParsedType> | undefined;
  };
  readonly path: ParsePath;
  readonly schemaErrorMap?: ZodErrorMap;
  readonly parent: ParseContext | null;
  readonly data: any;
  readonly parsedType: ZodParsedType;
}

export type ParseInput = {
  data: any;
  path: (string | number)[];
  parent: ParseContext;
};

export function addIssueToContext(
  ctx: ParseContext,
  issueData: IssueData
): void {
  const issue = makeIssue({
    issueData: issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap, // contextual error map is first priority
      ctx.schemaErrorMap, // then schema-bound map if available
      overrideErrorMap, // then global override map
      defaultErrorMap, // then global default map
    ].filter((x) => !!x) as ZodErrorMap[],
  });
  ctx.common.issues.push(issue);
}

export type ObjectPair = {
  key: SyncParseReturnType<any>;
  value: SyncParseReturnType<any>;
};
export class ParseStatus {
  value: "aborted" | "dirty" | "valid" = "valid";
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }

  static mergeArray(
    status: ParseStatus,
    results: SyncParseReturnType<any>[]
  ): SyncParseReturnType {
    const arrayValue: any[] = [];
    for (const s of results) {
      if (s.status === "aborted") return INVALID;
      if (s.status === "dirty") status.dirty();
      arrayValue.push(s.value);
    }

    return { status: status.value, value: arrayValue };
  }

  static async mergeObjectAsync(
    status: ParseStatus,
    pairs: { key: ParseReturnType<any>; value: ParseReturnType<any> }[]
  ): Promise<SyncParseReturnType<any>> {
    const syncPairs: ObjectPair[] = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value,
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }

  static mergeObjectSync(
    status: ParseStatus,
    pairs: {
      key: SyncParseReturnType<any>;
      value: SyncParseReturnType<any>;
      alwaysSet?: boolean;
    }[]
  ): SyncParseReturnType {
    const finalObject: any = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted") return INVALID;
      if (value.status === "aborted") return INVALID;
      if (key.status === "dirty") status.dirty();
      if (value.status === "dirty") status.dirty();

      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key.value] = value.value;
      }
    }

    return { status: status.value, value: finalObject };
  }
}
export interface ParseResult {
  status: "aborted" | "dirty" | "valid";
  data: any;
}

export type INVALID = { status: "aborted" };
export const INVALID: INVALID = Object.freeze({
  status: "aborted",
});

export type DIRTY<T> = { status: "dirty"; value: T };
export const DIRTY = <T>(value: T): DIRTY<T> => ({ status: "dirty", value });

export type OK<T> = { status: "valid"; value: T };
export const OK = <T>(value: T): OK<T> => ({ status: "valid", value });

export type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;
export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
export type ParseReturnType<T> =
  | SyncParseReturnType<T>
  | AsyncParseReturnType<T>;

export const isAborted = (x: ParseReturnType<any>): x is INVALID =>
  (x as any).status === "aborted";
export const isDirty = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
  (x as any).status === "dirty";
export const isValid = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
  (x as any).status === "valid";
export const isAsync = <T>(
  x: ParseReturnType<T>
): x is AsyncParseReturnType<T> =>
  typeof Promise !== undefined && x instanceof Promise;
````

## File: deno/lib/helpers/partialUtil.ts
````typescript
import type {
  ZodArray,
  ZodNullable,
  ZodObject,
  ZodOptional,
  ZodTuple,
  ZodTupleItems,
  ZodTypeAny,
} from "../index.ts";

export namespace partialUtil {
  // export type DeepPartial<T extends AnyZodObject> = T extends AnyZodObject
  //   ? ZodObject<
  //       { [k in keyof T["_shape"]]: InternalDeepPartial<T["_shape"][k]> },
  //       T["_unknownKeys"],
  //       T["_catchall"]
  //     >
  //   : T extends ZodArray<infer Type, infer Card>
  //   ? ZodArray<InternalDeepPartial<Type>, Card>
  //   : ZodOptional<T>;

  // {
  //   // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
  //   // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
  //   object: T extends AnyZodObject
  //     ? ZodObject<
  //         { [k in keyof T["_shape"]]: DeepPartial<T["_shape"][k]> },
  //         T["_unknownKeys"],
  //         T["_catchall"]
  //       >
  //     : never;
  //   rest: ReturnType<T["optional"]>; // ZodOptional<T>;
  // }[T extends AnyZodObject
  //   ? "object" // T extends ZodOptional<any> // ? 'optional' // :
  //   : "rest"];

  export type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<
    infer Shape,
    infer Params,
    infer Catchall
  >
    ? ZodObject<
        { [k in keyof Shape]: ZodOptional<DeepPartial<Shape[k]>> },
        Params,
        Catchall
      >
    : T extends ZodArray<infer Type, infer Card>
    ? ZodArray<DeepPartial<Type>, Card>
    : T extends ZodOptional<infer Type>
    ? ZodOptional<DeepPartial<Type>>
    : T extends ZodNullable<infer Type>
    ? ZodNullable<DeepPartial<Type>>
    : T extends ZodTuple<infer Items>
    ? {
        [k in keyof Items]: Items[k] extends ZodTypeAny
          ? DeepPartial<Items[k]>
          : never;
      } extends infer PI
      ? PI extends ZodTupleItems
        ? ZodTuple<PI>
        : never
      : never
    : T;
  //  {
  //     // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
  //     // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
  //     object: T extends ZodObject<infer Shape, infer Params, infer Catchall>
  //       ? ZodOptional<
  //           ZodObject<
  //             { [k in keyof Shape]: DeepPartial<Shape[k]> },
  //             Params,
  //             Catchall
  //           >
  //         >
  //       : never;
  //     rest: ReturnType<T["optional"]>;
  //   }[T extends ZodObject<any>
  //     ? "object" // T extends ZodOptional<any> // ? 'optional' // :
  //     : "rest"];
}
````

## File: deno/lib/helpers/typeAliases.ts
````typescript
export type Primitive = string | number | bigint | boolean | null | undefined;
export type Scalars = Primitive | Primitive[];
````

## File: deno/lib/helpers/util.ts
````typescript
export namespace util {
  export type AssertEqual<T, Expected> = [T] extends [Expected]
    ? [Expected] extends [T]
      ? true
      : false
    : false;

  export function assertNever(_x: never): never {
    throw new Error();
  }

  export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
  export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;
  export type MakePartial<T, K extends keyof T> = Omit<T, K> &
    Partial<Pick<T, K>>;

  export const arrayToEnum = <T extends string, U extends [T, ...T[]]>(
    items: U
  ): { [k in U[number]]: k } => {
    const obj: any = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj as any;
  };

  export const getValidEnumValues = (obj: any) => {
    const validKeys = objectKeys(obj).filter(
      (k: any) => typeof obj[obj[k]] !== "number"
    );
    const filtered: any = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return objectValues(filtered);
  };

  export const objectValues = (obj: any) => {
    return objectKeys(obj).map(function (e) {
      return obj[e];
    });
  };

  export const objectKeys: ObjectConstructor["keys"] =
    typeof Object.keys === "function" // eslint-disable-line ban/ban
      ? (obj: any) => Object.keys(obj) // eslint-disable-line ban/ban
      : (object: any) => {
          const keys = [];
          for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
              keys.push(key);
            }
          }
          return keys;
        };

  export const find = <T>(
    arr: T[],
    checker: (arg: T) => any
  ): T | undefined => {
    for (const item of arr) {
      if (checker(item)) return item;
    }
    return undefined;
  };

  export type identity<T> = T;
  export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
  export type noUndefined<T> = T extends undefined ? never : T;

  export const isInteger: NumberConstructor["isInteger"] =
    typeof Number.isInteger === "function"
      ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
      : (val) =>
          typeof val === "number" && isFinite(val) && Math.floor(val) === val;
}
````

## File: deno/lib/external.ts
````typescript
export * from "./helpers/parseUtil.ts";
export * from "./helpers/typeAliases.ts";
export * from "./types.ts";
export * from "./ZodError.ts";
````

## File: deno/lib/index.ts
````typescript
import * as mod from "./external.ts";
export * from "./external.ts";
export { mod as z };
export default mod;
````

## File: deno/lib/mod.ts
````typescript
export * from "./index.ts";
````

## File: deno/lib/types.ts
````typescript
import { errorUtil } from "./helpers/errorUtil.ts";
import {
  addIssueToContext,
  AsyncParseReturnType,
  DIRTY,
  getParsedType,
  INVALID,
  isAborted,
  isAsync,
  isDirty,
  isValid,
  makeIssue,
  OK,
  ParseContext,
  ParseInput,
  ParseParams,
  ParsePath,
  ParseReturnType,
  ParseStatus,
  SyncParseReturnType,
  ZodParsedType,
} from "./helpers/parseUtil.ts";
import { partialUtil } from "./helpers/partialUtil.ts";
import { Primitive } from "./helpers/typeAliases.ts";
import { util } from "./helpers/util.ts";
import {
  defaultErrorMap,
  IssueData,
  overrideErrorMap,
  StringValidation,
  ZodCustomIssue,
  ZodError,
  ZodErrorMap,
  ZodIssue,
  ZodIssueCode,
} from "./ZodError.ts";

///////////////////////////////////////
///////////////////////////////////////
//////////                   //////////
//////////      ZodType      //////////
//////////                   //////////
///////////////////////////////////////
///////////////////////////////////////

export type RefinementCtx = {
  addIssue: (arg: IssueData) => void;
  path: (string | number)[];
};
export type ZodRawShape = { [k: string]: ZodTypeAny };
export type ZodTypeAny = ZodType<any, any, any>;
export type TypeOf<T extends ZodType<any, any, any>> = T["_output"];
export type input<T extends ZodType<any, any, any>> = T["_input"];
export type output<T extends ZodType<any, any, any>> = T["_output"];

type allKeys<T> = T extends any ? keyof T : never;
export type TypeOfFlattenedError<
  T extends ZodType<any, any, any>,
  U = string
> = {
  formErrors: U[];
  fieldErrors: {
    [P in allKeys<TypeOf<T>>]?: U[];
  };
};
export type TypeOfFormErrors<T extends ZodType<any, any, any>> =
  TypeOfFlattenedError<T>;
export type {
  TypeOf as infer,
  TypeOfFlattenedError as inferFlattenedErrors,
  TypeOfFormErrors as inferFormErrors,
};

export type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
export interface ZodTypeDef {
  errorMap?: ZodErrorMap;
  description?: string;
}

class ParseInputLazyPath implements ParseInput {
  parent: ParseContext;
  data: any;
  _path: ParsePath;
  _key: string | number | (string | number)[];
  constructor(
    parent: ParseContext,
    value: any,
    path: ParsePath,
    key: string | number | (string | number)[]
  ) {
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    return this._path.concat(this._key);
  }
}

const handleResult = <Input, Output>(
  ctx: ParseContext,
  result: SyncParseReturnType<Output>
):
  | { success: true; data: Output }
  | { success: false; error: ZodError<Input> } => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    const error = new ZodError(ctx.common.issues);
    return { success: false, error };
  }
};

type RawCreateParams =
  | {
      errorMap?: ZodErrorMap;
      invalid_type_error?: string;
      required_error?: string;
      description?: string;
    }
  | undefined;
type ProcessedCreateParams = { errorMap?: ZodErrorMap; description?: string };
function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
  if (!params) return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(
      `Can't use "invalid" or "required" in conjunction with custom error map.`
    );
  }
  if (errorMap) return { errorMap: errorMap, description };
  const customMap: ZodErrorMap = (iss, ctx) => {
    if (iss.code !== "invalid_type") return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined" && required_error)
      return { message: required_error };
    if (params.invalid_type_error)
      return { message: params.invalid_type_error };
    return { message: ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

export type SafeParseSuccess<Output> = { success: true; data: Output };
export type SafeParseError<Input> = { success: false; error: ZodError<Input> };

export type SafeParseReturnType<Input, Output> =
  | SafeParseSuccess<Output>
  | SafeParseError<Input>;

export abstract class ZodType<
  Output = any,
  Def extends ZodTypeDef = ZodTypeDef,
  Input = Output
> {
  readonly _type!: Output;
  readonly _output!: Output;
  readonly _input!: Input;
  readonly _def!: Def;

  get description() {
    return this._def.description;
  }

  abstract _parse(input: ParseInput): ParseReturnType<Output>;

  _getType(input: ParseInput): string {
    return getParsedType(input.data);
  }

  _getOrReturnCtx(
    input: ParseInput,
    ctx?: ParseContext | undefined
  ): ParseContext {
    return (
      ctx || {
        common: input.parent.common,
        data: input.data,

        parsedType: getParsedType(input.data),

        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent,
      }
    );
  }

  _processInputParams(input: ParseInput): {
    status: ParseStatus;
    ctx: ParseContext;
  } {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,

        parsedType: getParsedType(input.data),

        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent,
      },
    };
  }

  _parseSync(input: ParseInput): SyncParseReturnType<Output> {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }

  _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {
    const result = this._parse(input);

    return Promise.resolve(result);
  }

  parse(data: unknown, params?: Partial<ParseParams>): Output {
    const result = this.safeParse(data, params);
    if (result.success) return result.data;
    throw result.error;
  }

  safeParse(
    data: unknown,
    params?: Partial<ParseParams>
  ): SafeParseReturnType<Input, Output> {
    const ctx: ParseContext = {
      common: {
        issues: [],
        async: params?.async ?? false,
        typeCache: typeof Map !== "undefined" ? new Map() : undefined,
        contextualErrorMap: params?.errorMap,
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data),
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });

    return handleResult(ctx, result);
  }

  async parseAsync(
    data: unknown,
    params?: Partial<ParseParams>
  ): Promise<Output> {
    const result = await this.safeParseAsync(data, params);
    if (result.success) return result.data;
    throw result.error;
  }

  async safeParseAsync(
    data: unknown,
    params?: Partial<ParseParams>
  ): Promise<SafeParseReturnType<Input, Output>> {
    const ctx: ParseContext = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true,
        typeCache: typeof Map !== "undefined" ? new Map() : undefined,
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data),
    };

    const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
    const result = await (isAsync(maybeAsyncResult)
      ? maybeAsyncResult
      : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }

  /** Alias of safeParseAsync */
  spa = this.safeParseAsync;

  refine<RefinedOutput extends Output>(
    check: (arg: Output) => arg is RefinedOutput,
    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
  ): ZodEffects<this, RefinedOutput, RefinedOutput>;
  refine(
    check: (arg: Output) => unknown | Promise<unknown>,
    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
  ): ZodEffects<this, Output, Input>;
  refine(
    check: (arg: Output) => unknown,
    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
  ): ZodEffects<this, Output, Input> {
    const getIssueProperties: any = (val: Output) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () =>
        ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val),
        });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }

  refinement<RefinedOutput extends Output>(
    check: (arg: Output) => arg is RefinedOutput,
    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
  ): ZodEffects<this, RefinedOutput, RefinedOutput>;
  refinement(
    check: (arg: Output) => boolean,
    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
  ): ZodEffects<this, Output, Input>;
  refinement(
    check: (arg: Output) => unknown,
    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
  ): ZodEffects<this, Output, Input> {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(
          typeof refinementData === "function"
            ? refinementData(val, ctx)
            : refinementData
        );
        return false;
      } else {
        return true;
      }
    });
  }

  _refinement(
    refinement: RefinementEffect<Output>["refinement"]
  ): ZodEffects<this, Output, Input> {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement },
    });
  }
  superRefine = this._refinement;

  constructor(def: Def) {
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.default = this.default.bind(this);
    this.describe = this.describe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }

  optional(): ZodOptional<this> {
    ("");
    ("asdf");
    return ZodOptional.create(this) as any;
  }
  nullable(): ZodNullable<this> {
    return ZodNullable.create(this) as any;
  }
  nullish(): ZodNullable<ZodOptional<this>> {
    return this.optional().nullable();
  }
  array(): ZodArray<this> {
    return ZodArray.create(this);
  }
  promise(): ZodPromise<this> {
    return ZodPromise.create(this);
  }

  or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {
    return ZodUnion.create([this, option]) as any;
  }

  and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T> {
    return ZodIntersection.create(this, incoming);
  }

  transform<NewOut>(
    transform: (arg: Output) => NewOut | Promise<NewOut>
  ): ZodEffects<this, NewOut> {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform },
    }) as any;
  }

  default(def: util.noUndefined<Input>): ZodDefault<this>;
  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
  default(def: any) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;

    return new ZodDefault({
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
    }) as any;
  }

  describe(description: string): this {
    const This = (this as any).constructor;
    return new This({
      ...this._def,
      description,
    });
  }

  isOptional(): boolean {
    return this.safeParse(undefined).success;
  }
  isNullable(): boolean {
    return this.safeParse(null).success;
  }
}

/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodString      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////
type ZodStringCheck =
  | { kind: "min"; value: number; message?: string }
  | { kind: "max"; value: number; message?: string }
  | { kind: "email"; message?: string }
  | { kind: "url"; message?: string }
  | { kind: "uuid"; message?: string }
  | { kind: "cuid"; message?: string }
  | { kind: "regex"; regex: RegExp; message?: string };

export interface ZodStringDef extends ZodTypeDef {
  checks: ZodStringCheck[];
  typeName: ZodFirstPartyTypeKind.ZodString;
}

const cuidRegex = /^c[^\s-]{8,}$/i;
const uuidRegex =
  /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
// eslint-disable-next-line
const emailRegex =
  /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;

export class ZodString extends ZodType<string, ZodStringDef> {
  _parse(input: ParseInput): ParseReturnType<string> {
    const parsedType = this._getType(input);

    if (parsedType !== ZodParsedType.string) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx.parsedType,
        }
        //
      );
      return INVALID;
    }

    const status = new ParseStatus();
    let ctx: undefined | ParseContext = undefined;

    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      }
    }

    return { status: status.value, value: input.data };
  }

  protected _regex = (
    regex: RegExp,
    validation: StringValidation,
    message?: errorUtil.ErrMessage
  ) =>
    this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message),
    });

  _addCheck(check: ZodStringCheck) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check],
    });
  }

  email(message?: errorUtil.ErrMessage) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message?: errorUtil.ErrMessage) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  uuid(message?: errorUtil.ErrMessage) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message?: errorUtil.ErrMessage) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  regex(regex: RegExp, message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "regex",
      regex: regex,
      ...errorUtil.errToObj(message),
    });
  }

  min(minLength: number, message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message),
    });
  }

  max(maxLength: number, message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message),
    });
  }

  length(len: number, message?: errorUtil.ErrMessage) {
    return this.min(len, message).max(len, message);
  }

  /**
   * Deprecated.
   * Use z.string().min(1) instead.
   */
  nonempty = (message?: errorUtil.ErrMessage) =>
    this.min(1, errorUtil.errToObj(message));

  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get minLength() {
    let min: number | null = -Infinity;
    this._def.checks.map((ch) => {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) {
          min = ch.value;
        }
      }
    });
    return min;
  }
  get maxLength() {
    let max: number | null = null;
    this._def.checks.map((ch) => {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) {
          max = ch.value;
        }
      }
    });
    return max;
  }
  static create = (params?: RawCreateParams): ZodString => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      ...processCreateParams(params),
    });
  };
}

/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodNumber      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////
type ZodNumberCheck =
  | { kind: "min"; value: number; inclusive: boolean; message?: string }
  | { kind: "max"; value: number; inclusive: boolean; message?: string }
  | { kind: "int"; message?: string }
  | { kind: "multipleOf"; value: number; message?: string };

// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val: number, step: number) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return (valInt % stepInt) / Math.pow(10, decCount);
}

export interface ZodNumberDef extends ZodTypeDef {
  checks: ZodNumberCheck[];
  typeName: ZodFirstPartyTypeKind.ZodNumber;
}

export class ZodNumber extends ZodType<number, ZodNumberDef> {
  _parse(input: ParseInput): ParseReturnType<number> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    let ctx: undefined | ParseContext = undefined;
    const status = new ParseStatus();

    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive
          ? input.data < check.value
          : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive
          ? input.data > check.value
          : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message,
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }

    return { status: status.value, value: input.data };
  }

  static create = (params?: RawCreateParams): ZodNumber => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      ...processCreateParams(params),
    });
  };

  gte(value: number, message?: errorUtil.ErrMessage) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  min = this.gte;

  gt(value: number, message?: errorUtil.ErrMessage) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }

  lte(value: number, message?: errorUtil.ErrMessage) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  max = this.lte;

  lt(value: number, message?: errorUtil.ErrMessage) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }

  protected setLimit(
    kind: "min" | "max",
    value: number,
    inclusive: boolean,
    message?: string
  ) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message),
        },
      ],
    });
  }

  _addCheck(check: ZodNumberCheck) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check],
    });
  }

  int(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message),
    });
  }

  positive(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }

  negative(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }

  nonpositive(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message),
    });
  }

  nonnegative(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message),
    });
  }

  multipleOf(value: number, message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "multipleOf",
      value: value,
      message: errorUtil.toString(message),
    });
  }

  step = this.multipleOf;

  get minValue() {
    let min: number | null = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }

  get maxValue() {
    let max: number | null = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max;
  }

  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int");
  }
}

/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodBigInt      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////

export interface ZodBigIntDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodBigInt;
}

export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
  _parse(input: ParseInput): ParseReturnType<bigint> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }

  static create = (params?: RawCreateParams): ZodBigInt => {
    return new ZodBigInt({
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////////
//////////////////////////////////////////
//////////                     ///////////
//////////      ZodBoolean      //////////
//////////                     ///////////
//////////////////////////////////////////
//////////////////////////////////////////
export interface ZodBooleanDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodBoolean;
}

export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
  _parse(input: ParseInput): ParseReturnType<boolean> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }

  static create = (params?: RawCreateParams): ZodBoolean => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      ...processCreateParams(params),
    });
  };
}

///////////////////////////////////////
///////////////////////////////////////
//////////                     ////////
//////////      ZodDate        ////////
//////////                     ////////
///////////////////////////////////////
///////////////////////////////////////
export interface ZodDateDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodDate;
}

export class ZodDate extends ZodType<Date, ZodDateDef> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_date,
      });
      return INVALID;
    }

    return {
      status: "valid",
      value: new Date((input.data as Date).getTime()),
    };
  }

  static create = (params?: RawCreateParams): ZodDate => {
    return new ZodDate({
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params),
    });
  };
}

////////////////////////////////////////////
////////////////////////////////////////////
//////////                        //////////
//////////      ZodUndefined      //////////
//////////                        //////////
////////////////////////////////////////////
////////////////////////////////////////////
export interface ZodUndefinedDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodUndefined;
}

export class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
  params?: RawCreateParams;

  static create = (params?: RawCreateParams): ZodUndefined => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params),
    });
  };
}

///////////////////////////////////////
///////////////////////////////////////
//////////                   //////////
//////////      ZodNull      //////////
//////////                   //////////
///////////////////////////////////////
///////////////////////////////////////
export interface ZodNullDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodNull;
}

export class ZodNull extends ZodType<null, ZodNullDef> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
  static create = (params?: RawCreateParams): ZodNull => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////
//////////////////////////////////////
//////////                  //////////
//////////      ZodAny      //////////
//////////                  //////////
//////////////////////////////////////
//////////////////////////////////////
export interface ZodAnyDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodAny;
}

export class ZodAny extends ZodType<any, ZodAnyDef> {
  // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
  _any: true = true;
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    return OK(input.data);
  }
  static create = (params?: RawCreateParams): ZodAny => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////////
//////////////////////////////////////////
//////////                      //////////
//////////      ZodUnknown      //////////
//////////                      //////////
//////////////////////////////////////////
//////////////////////////////////////////
export interface ZodUnknownDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodUnknown;
}

export class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {
  // required
  _unknown: true = true;
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    return OK(input.data);
  }

  static create = (params?: RawCreateParams): ZodUnknown => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params),
    });
  };
}

////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      ZodNever      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
export interface ZodNeverDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodNever;
}

export class ZodNever extends ZodType<never, ZodNeverDef> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType,
    });
    return INVALID;
  }
  static create = (params?: RawCreateParams): ZodNever => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params),
    });
  };
}

///////////////////////////////////////
///////////////////////////////////////
//////////                   //////////
//////////      ZodVoid      //////////
//////////                   //////////
///////////////////////////////////////
///////////////////////////////////////
export interface ZodVoidDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodVoid;
}

export class ZodVoid extends ZodType<void, ZodVoidDef> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }

  static create = (params?: RawCreateParams): ZodVoid => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params),
    });
  };
}

////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      ZodArray      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
export interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  type: T;
  typeName: ZodFirstPartyTypeKind.ZodArray;
  minLength: { value: number; message?: string } | null;
  maxLength: { value: number; message?: string } | null;
}

export type ArrayCardinality = "many" | "atleastone";
type arrayOutputType<
  T extends ZodTypeAny,
  Cardinality extends ArrayCardinality = "many"
> = Cardinality extends "atleastone"
  ? [T["_output"], ...T["_output"][]]
  : T["_output"][];

export class ZodArray<
  T extends ZodTypeAny,
  Cardinality extends ArrayCardinality = "many"
> extends ZodType<
  arrayOutputType<T, Cardinality>,
  ZodArrayDef<T>,
  Cardinality extends "atleastone"
    ? [T["_input"], ...T["_input"][]]
    : T["_input"][]
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { ctx, status } = this._processInputParams(input);

    const def = this._def;

    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          message: def.minLength.message,
        });
        status.dirty();
      }
    }

    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          message: def.maxLength.message,
        });
        status.dirty();
      }
    }

    if (ctx.common.async) {
      return Promise.all(
        (ctx.data as any[]).map((item, i) => {
          return def.type._parseAsync(
            new ParseInputLazyPath(ctx, item, ctx.path, i)
          );
        })
      ).then((result) => {
        return ParseStatus.mergeArray(status, result);
      });
    }

    const result = (ctx.data as any[]).map((item, i) => {
      return def.type._parseSync(
        new ParseInputLazyPath(ctx, item, ctx.path, i)
      );
    });

    return ParseStatus.mergeArray(status, result);
  }

  get element() {
    return this._def.type;
  }

  min(minLength: number, message?: errorUtil.ErrMessage): this {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) },
    }) as any;
  }

  max(maxLength: number, message?: errorUtil.ErrMessage): this {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) },
    }) as any;
  }

  length(len: number, message?: errorUtil.ErrMessage): this {
    return this.min(len, message).max(len, message) as any;
  }

  nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone"> {
    return this.min(1, message) as any;
  }

  static create = <T extends ZodTypeAny>(
    schema: T,
    params?: RawCreateParams
  ): ZodArray<T> => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params),
    });
  };
}

export type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, "atleastone">;

/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodObject      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////

export namespace objectUtil {
  export type MergeShapes<U extends ZodRawShape, V extends ZodRawShape> = {
    [k in Exclude<keyof U, keyof V>]: U[k];
  } & V;

  type optionalKeys<T extends object> = {
    [k in keyof T]: undefined extends T[k] ? k : never;
  }[keyof T];

  // type requiredKeys<T extends object> = Exclude<keyof T, optionalKeys<T>>;
  type requiredKeys<T extends object> = {
    [k in keyof T]: undefined extends T[k] ? never : k;
  }[keyof T];

  export type addQuestionMarks<T extends object> = {
    [k in optionalKeys<T>]?: T[k];
  } & { [k in requiredKeys<T>]: T[k] };

  export type identity<T> = T;
  export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;

  export type noNeverKeys<T extends ZodRawShape> = {
    [k in keyof T]: [T[k]] extends [never] ? never : k;
  }[keyof T];

  export type noNever<T extends ZodRawShape> = identity<{
    [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
  }>;

  export const mergeShapes = <U extends ZodRawShape, T extends ZodRawShape>(
    first: U,
    second: T
  ): T & U => {
    return {
      ...first,
      ...second, // second overwrites first
    };
  };
}

export type extendShape<A, B> = {
  [k in Exclude<keyof A, keyof B>]: A[k];
} & { [k in keyof B]: B[k] };

const AugmentFactory =
  <Def extends ZodObjectDef>(def: Def) =>
  <Augmentation extends ZodRawShape>(
    augmentation: Augmentation
  ): ZodObject<
    extendShape<ReturnType<Def["shape"]>, Augmentation>,
    Def["unknownKeys"],
    Def["catchall"]
  > => {
    return new ZodObject({
      ...def,
      shape: () => ({
        ...def.shape(),
        ...augmentation,
      }),
    }) as any;
  };

type UnknownKeysParam = "passthrough" | "strict" | "strip";

export interface ZodObjectDef<
  T extends ZodRawShape = ZodRawShape,
  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,
  Catchall extends ZodTypeAny = ZodTypeAny
> extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodObject;
  shape: () => T;
  catchall: Catchall;
  unknownKeys: UnknownKeys;
}

export type baseObjectOutputType<Shape extends ZodRawShape> =
  objectUtil.flatten<
    objectUtil.addQuestionMarks<{
      [k in keyof Shape]: Shape[k]["_output"];
    }>
  >;

export type objectOutputType<
  Shape extends ZodRawShape,
  Catchall extends ZodTypeAny
> = ZodTypeAny extends Catchall
  ? baseObjectOutputType<Shape>
  : objectUtil.flatten<
      baseObjectOutputType<Shape> & { [k: string]: Catchall["_output"] }
    >;

export type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<
  objectUtil.addQuestionMarks<{
    [k in keyof Shape]: Shape[k]["_input"];
  }>
>;

export type objectInputType<
  Shape extends ZodRawShape,
  Catchall extends ZodTypeAny
> = ZodTypeAny extends Catchall
  ? baseObjectInputType<Shape>
  : objectUtil.flatten<
      baseObjectInputType<Shape> & { [k: string]: Catchall["_input"] }
    >;

type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U>
  ? deoptional<U>
  : T;

export type SomeZodObject = ZodObject<
  ZodRawShape,
  UnknownKeysParam,
  ZodTypeAny,
  any,
  any
>;

function deepPartialify(schema: ZodTypeAny): any {
  if (schema instanceof ZodObject) {
    const newShape: any = {};

    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape,
    }) as any;
  } else if (schema instanceof ZodArray) {
    return ZodArray.create(deepPartialify(schema.element));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(
      schema.items.map((item: any) => deepPartialify(item))
    );
  } else {
    return schema;
  }
}

export class ZodObject<
  T extends ZodRawShape,
  UnknownKeys extends UnknownKeysParam = "strip",
  Catchall extends ZodTypeAny = ZodTypeAny,
  Output = objectOutputType<T, Catchall>,
  Input = objectInputType<T, Catchall>
> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
  readonly _shape!: T;
  readonly _unknownKeys!: UnknownKeys;
  readonly _catchall!: Catchall;
  private _cached: { shape: T; keys: string[] } | null = null;

  _getCached(): { shape: T; keys: string[] } {
    if (this._cached !== null) return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return (this._cached = { shape, keys });
  }

  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    const { status, ctx } = this._processInputParams(input);

    const { shape, keys: shapeKeys } = this._getCached();
    const dataKeys = util.objectKeys(ctx.data);
    const extraKeys = dataKeys.filter((k) => !shapeKeys.includes(k));

    const pairs: {
      key: ParseReturnType<any>;
      value: ParseReturnType<any>;
      alwaysSet?: boolean;
    }[] = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(
          new ParseInputLazyPath(ctx, value, ctx.path, key)
        ),
        alwaysSet: key in ctx.data,
      });
    }

    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;

      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] },
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys,
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      // run catchall validation
      const catchall = this._def.catchall;

      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data,
        });
      }
    }

    if (ctx.common.async) {
      return Promise.resolve()
        .then(async () => {
          const syncPairs: any[] = [];
          for (const pair of pairs) {
            const key = await pair.key;
            syncPairs.push({
              key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet,
            });
          }
          return syncPairs;
        })
        .then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs as any);
    }
  }

  get shape() {
    return this._def.shape();
  }

  strict(message?: errorUtil.ErrMessage): ZodObject<T, "strict", Catchall> {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...(message !== undefined
        ? {
            errorMap: (issue, ctx) => {
              const defaultError =
                this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message).message ?? defaultError,
                };
              return {
                message: defaultError,
              };
            },
          }
        : {}),
    }) as any;
  }

  strip(): ZodObject<T, "strip", Catchall> {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip",
    }) as any;
  }

  passthrough(): ZodObject<T, "passthrough", Catchall> {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough",
    }) as any;
  }

  /**
   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
   * If you want to pass through unknown properties, use `.passthrough()` instead.
   */
  nonstrict = this.passthrough;

  augment = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
  extend = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);

  setKey<Key extends string, Schema extends ZodTypeAny>(
    key: Key,
    schema: Schema
  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> {
    return this.augment({ [key]: schema }) as any;
  }

  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge<Incoming extends AnyZodObject>(
    merging: Incoming
  ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  ZodObject<extendShape<T, Incoming["_shape"]>, UnknownKeys, Catchall> {
    // const mergedShape = objectUtil.mergeShapes(
    //   this._def.shape(),
    //   merging._def.shape()
    // );
    const merged: any = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () =>
        objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      typeName: ZodFirstPartyTypeKind.ZodObject,
    }) as any;
    return merged;
  }

  catchall<Index extends ZodTypeAny>(
    index: Index
  ): ZodObject<T, UnknownKeys, Index> {
    return new ZodObject({
      ...this._def,
      catchall: index,
    }) as any;
  }

  pick<Mask extends { [k in keyof T]?: true }>(
    mask: Mask
  ): ZodObject<
    objectUtil.noNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
    UnknownKeys,
    Catchall
  > {
    const shape: any = {};
    util.objectKeys(mask).map((key) => {
      shape[key] = this.shape[key];
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape,
    }) as any;
  }

  omit<Mask extends { [k in keyof T]?: true }>(
    mask: Mask
  ): ZodObject<
    objectUtil.noNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
    UnknownKeys,
    Catchall
  > {
    const shape: any = {};
    util.objectKeys(this.shape).map((key) => {
      if (util.objectKeys(mask).indexOf(key) === -1) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape,
    }) as any;
  }

  deepPartial(): partialUtil.DeepPartial<this> {
    return deepPartialify(this) as any;
  }

  partial(): ZodObject<
    { [k in keyof T]: ZodOptional<T[k]> },
    UnknownKeys,
    Catchall
  >;
  partial<Mask extends { [k in keyof T]?: true }>(
    mask: Mask
  ): ZodObject<
    objectUtil.noNever<{
      [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
    }>,
    UnknownKeys,
    Catchall
  >;
  partial(mask?: any) {
    const newShape: any = {};
    if (mask) {
      util.objectKeys(this.shape).map((key) => {
        if (util.objectKeys(mask).indexOf(key) === -1) {
          newShape[key] = this.shape[key];
        } else {
          newShape[key] = this.shape[key].optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape,
      }) as any;
    } else {
      for (const key in this.shape) {
        const fieldSchema = this.shape[key];
        newShape[key] = fieldSchema.optional();
      }
    }

    return new ZodObject({
      ...this._def,
      shape: () => newShape,
    }) as any;
  }

  required(): ZodObject<
    { [k in keyof T]: deoptional<T[k]> },
    UnknownKeys,
    Catchall
  > {
    const newShape: any = {};
    for (const key in this.shape) {
      const fieldSchema = this.shape[key];
      let newField = fieldSchema;
      while (newField instanceof ZodOptional) {
        newField = (newField as ZodOptional<any>)._def.innerType;
      }

      newShape[key] = newField;
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape,
    }) as any;
  }

  static create = <T extends ZodRawShape>(
    shape: T,
    params?: RawCreateParams
  ): ZodObject<T> => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params),
    }) as any;
  };

  static strictCreate = <T extends ZodRawShape>(
    shape: T,
    params?: RawCreateParams
  ): ZodObject<T, "strict"> => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params),
    }) as any;
  };

  static lazycreate = <T extends ZodRawShape>(
    shape: () => T,
    params?: RawCreateParams
  ): ZodObject<T> => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params),
    }) as any;
  };
}

export type AnyZodObject = ZodObject<any, any, any>;

////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      ZodUnion      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
export interface ZodUnionDef<
  T extends ZodUnionOptions = Readonly<
    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
  >
> extends ZodTypeDef {
  options: T;
  typeName: ZodFirstPartyTypeKind.ZodUnion;
}

export class ZodUnion<T extends ZodUnionOptions> extends ZodType<
  T[number]["_output"],
  ZodUnionDef<T>,
  T[number]["_input"]
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;

    function handleResults(
      results: { ctx: ParseContext; result: SyncParseReturnType<any> }[]
    ) {
      // return first issue-free validation if it exists
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }

      for (const result of results) {
        if (result.result.status === "dirty") {
          // add issues from dirty option

          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }

      // return invalid
      const unionErrors = results.map(
        (result) => new ZodError(result.ctx.common.issues)
      );

      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors,
      });
      return INVALID;
    }

    if (ctx.common.async) {
      return Promise.all(
        options.map(async (option) => {
          const childCtx: ParseContext = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: [],
            },
            parent: null,
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx,
            }),
            ctx: childCtx,
          };
        })
      ).then(handleResults);
    } else {
      let dirty: undefined | { result: DIRTY<any>; ctx: ParseContext } =
        undefined;
      const issues: ZodIssue[][] = [];
      for (const option of options) {
        const childCtx: ParseContext = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: [],
          },
          parent: null,
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx,
        });

        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }

        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }

      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }

      const unionErrors = issues.map((issues) => new ZodError(issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors,
      });

      return INVALID;
    }
  }

  get options() {
    return this._def.options;
  }

  static create = <
    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
  >(
    types: T,
    params?: RawCreateParams
  ): ZodUnion<T> => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params),
    });
  };
}

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

export type ZodDiscriminatedUnionOption<
  Discriminator extends string,
  DiscriminatorValue extends Primitive
> = ZodObject<
  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
  any,
  any
>;

export interface ZodDiscriminatedUnionDef<
  Discriminator extends string,
  DiscriminatorValue extends Primitive,
  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
> extends ZodTypeDef {
  discriminator: Discriminator;
  options: Map<DiscriminatorValue, Option>;
  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
}

export class ZodDiscriminatedUnion<
  Discriminator extends string,
  DiscriminatorValue extends Primitive,
  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
> extends ZodType<
  Option["_output"],
  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
  Option["_input"]
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { ctx } = this._processInputParams(input);

    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    const discriminator = this.discriminator;
    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
    const option = this.options.get(discriminatorValue);

    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: this.validDiscriminatorValues,
        path: [discriminator],
      });
      return INVALID;
    }

    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx,
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx,
      });
    }
  }

  get discriminator() {
    return this._def.discriminator;
  }

  get validDiscriminatorValues() {
    return Array.from(this.options.keys());
  }

  get options() {
    return this._def.options;
  }

  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create<
    Discriminator extends string,
    DiscriminatorValue extends Primitive,
    Types extends [
      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
    ]
  >(
    discriminator: Discriminator,
    types: Types,
    params?: RawCreateParams
  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
    // Get all the valid discriminator values
    const options: Map<DiscriminatorValue, Types[number]> = new Map();

    try {
      types.forEach((type) => {
        const discriminatorValue = type.shape[discriminator].value;
        options.set(discriminatorValue, type);
      });
    } catch (e) {
      throw new Error(
        "The discriminator value could not be extracted from all the provided schemas"
      );
    }

    // Assert that all the discriminator values are unique
    if (options.size !== types.length) {
      throw new Error("Some of the discriminator values are not unique");
    }

    return new ZodDiscriminatedUnion<
      Discriminator,
      DiscriminatorValue,
      Types[number]
    >({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      ...processCreateParams(params),
    });
  }
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////                           //////////
//////////      ZodIntersection      //////////
//////////                           //////////
///////////////////////////////////////////////
///////////////////////////////////////////////
export interface ZodIntersectionDef<
  T extends ZodTypeAny = ZodTypeAny,
  U extends ZodTypeAny = ZodTypeAny
> extends ZodTypeDef {
  left: T;
  right: U;
  typeName: ZodFirstPartyTypeKind.ZodIntersection;
}

function mergeValues(
  a: any,
  b: any
): { valid: true; data: any } | { valid: false } {
  const aType = getParsedType(a);
  const bType = getParsedType(b);

  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util
      .objectKeys(a)
      .filter((key) => bKeys.indexOf(key) !== -1);

    const newObj: any = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }

    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }

    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);

      if (!sharedValue.valid) {
        return { valid: false };
      }

      newArray.push(sharedValue.data);
    }

    return { valid: true, data: newArray };
  } else if (
    aType === ZodParsedType.date &&
    bType === ZodParsedType.date &&
    +a === +b
  ) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}

export class ZodIntersection<
  T extends ZodTypeAny,
  U extends ZodTypeAny
> extends ZodType<
  T["_output"] & U["_output"],
  ZodIntersectionDef<T, U>,
  T["_input"] & U["_input"]
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (
      parsedLeft: SyncParseReturnType,
      parsedRight: SyncParseReturnType
    ): SyncParseReturnType<T & U> => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }

      const merged = mergeValues(parsedLeft.value, parsedRight.value);

      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types,
        });
        return INVALID;
      }

      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }

      return { status: status.value, value: merged.data as any };
    };

    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
      ]).then(([left, right]: any) => handleParsed(left, right));
    } else {
      return handleParsed(
        this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
        this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        })
      );
    }
  }

  static create = <T extends ZodTypeAny, U extends ZodTypeAny>(
    left: T,
    right: U,
    params?: RawCreateParams
  ): ZodIntersection<T, U> => {
    return new ZodIntersection({
      left: left,
      right: right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params),
    });
  };
}

////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      ZodTuple      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
export type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
export type AssertArray<T> = T extends any[] ? T : never;
export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
}>;
export type OutputTypeOfTupleWithRest<
  T extends ZodTupleItems | [],
  Rest extends ZodTypeAny | null = null
> = Rest extends ZodTypeAny
  ? [...OutputTypeOfTuple<T>, ...Rest["_output"][]]
  : OutputTypeOfTuple<T>;

export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
}>;
export type InputTypeOfTupleWithRest<
  T extends ZodTupleItems | [],
  Rest extends ZodTypeAny | null = null
> = Rest extends ZodTypeAny
  ? [...InputTypeOfTuple<T>, ...Rest["_input"][]]
  : InputTypeOfTuple<T>;

export interface ZodTupleDef<
  T extends ZodTupleItems | [] = ZodTupleItems,
  Rest extends ZodTypeAny | null = null
> extends ZodTypeDef {
  items: T;
  rest: Rest;
  typeName: ZodFirstPartyTypeKind.ZodTuple;
}

export class ZodTuple<
  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
  Rest extends ZodTypeAny | null = null
> extends ZodType<
  OutputTypeOfTupleWithRest<T, Rest>,
  ZodTupleDef<T, Rest>,
  InputTypeOfTupleWithRest<T, Rest>
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        type: "array",
      });

      return INVALID;
    }

    const rest = this._def.rest;

    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        type: "array",
      });
      status.dirty();
    }

    const items = (ctx.data as any[])
      .map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema) return null as any as SyncParseReturnType<any>;
        return schema._parse(
          new ParseInputLazyPath(ctx, item, ctx.path, itemIndex)
        );
      })
      .filter((x) => !!x); // filter nulls

    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items as SyncParseReturnType[]);
    }
  }

  get items() {
    return this._def.items;
  }

  rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest> {
    return new ZodTuple({
      ...this._def,
      rest,
    });
  }

  static create = <T extends [ZodTypeAny, ...ZodTypeAny[]] | []>(
    schemas: T,
    params?: RawCreateParams
  ): ZodTuple<T, null> => {
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params),
    });
  };
}

/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodRecord      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////
export interface ZodRecordDef<
  Key extends KeySchema = ZodString,
  Value extends ZodTypeAny = ZodTypeAny
> extends ZodTypeDef {
  valueType: Value;
  keyType: Key;
  typeName: ZodFirstPartyTypeKind.ZodRecord;
}

type KeySchema = ZodType<string | number | symbol, any, any>;
type RecordType<K extends string | number | symbol, V> = [string] extends [K]
  ? Record<K, V>
  : [number] extends [K]
  ? Record<K, V>
  : [symbol] extends [K]
  ? Record<K, V>
  : Partial<Record<K, V>>;
export class ZodRecord<
  Key extends KeySchema = ZodString,
  Value extends ZodTypeAny = ZodTypeAny
> extends ZodType<
  RecordType<Key["_output"], Value["_output"]>,
  ZodRecordDef<Key, Value>,
  RecordType<Key["_input"], Value["_input"]>
> {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    const pairs: {
      key: ParseReturnType<any>;
      value: ParseReturnType<any>;
    }[] = [];

    const keyType = this._def.keyType;
    const valueType = this._def.valueType;

    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(
          new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)
        ),
      });
    }

    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs as any);
    }
  }

  get element() {
    return this._def.valueType;
  }

  static create<Value extends ZodTypeAny>(
    valueType: Value,
    params?: RawCreateParams
  ): ZodRecord<ZodString, Value>;
  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
    keySchema: Keys,
    valueType: Value,
    params?: RawCreateParams
  ): ZodRecord<Keys, Value>;
  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third),
      });
    }

    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second),
    });
  }
}

//////////////////////////////////////
//////////////////////////////////////
//////////                  //////////
//////////      ZodMap      //////////
//////////                  //////////
//////////////////////////////////////
//////////////////////////////////////
export interface ZodMapDef<
  Key extends ZodTypeAny = ZodTypeAny,
  Value extends ZodTypeAny = ZodTypeAny
> extends ZodTypeDef {
  valueType: Value;
  keyType: Key;
  typeName: ZodFirstPartyTypeKind.ZodMap;
}

export class ZodMap<
  Key extends ZodTypeAny = ZodTypeAny,
  Value extends ZodTypeAny = ZodTypeAny
> extends ZodType<
  Map<Key["_output"], Value["_output"]>,
  ZodMapDef<Key, Value>,
  Map<Key["_input"], Value["_input"]>
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    const keyType = this._def.keyType;
    const valueType = this._def.valueType;

    const pairs = [...(ctx.data as Map<unknown, unknown>).entries()].map(
      ([key, value], index) => {
        return {
          key: keyType._parse(
            new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])
          ),
          value: valueType._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])
          ),
        };
      }
    );

    if (ctx.common.async) {
      const finalMap = new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }

          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map();
      for (const pair of pairs) {
        const key = pair.key as SyncParseReturnType;
        const value = pair.value as SyncParseReturnType;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }

        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
  static create = <
    Key extends ZodTypeAny = ZodTypeAny,
    Value extends ZodTypeAny = ZodTypeAny
  >(
    keyType: Key,
    valueType: Value,
    params?: RawCreateParams
  ): ZodMap<Key, Value> => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////
//////////////////////////////////////
//////////                  //////////
//////////      ZodSet      //////////
//////////                  //////////
//////////////////////////////////////
//////////////////////////////////////
export interface ZodSetDef<Value extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  valueType: Value;
  typeName: ZodFirstPartyTypeKind.ZodSet;
  minSize: { value: number; message?: string } | null;
  maxSize: { value: number; message?: string } | null;
}

export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
  Set<Value["_output"]>,
  ZodSetDef<Value>,
  Set<Value["_input"]>
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    const def = this._def;

    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          message: def.minSize.message,
        });
        status.dirty();
      }
    }

    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          message: def.maxSize.message,
        });
        status.dirty();
      }
    }

    const valueType = this._def.valueType;

    function finalizeSet(elements: SyncParseReturnType<any>[]) {
      const parsedSet = new Set();
      for (const element of elements) {
        if (element.status === "aborted") return INVALID;
        if (element.status === "dirty") status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }

    const elements = [...(ctx.data as Set<unknown>).values()].map((item, i) =>
      valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i))
    );

    if (ctx.common.async) {
      return Promise.all(elements).then((elements) => finalizeSet(elements));
    } else {
      return finalizeSet(elements as SyncParseReturnType[]);
    }
  }

  min(minSize: number, message?: errorUtil.ErrMessage): this {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) },
    }) as any;
  }

  max(maxSize: number, message?: errorUtil.ErrMessage): this {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) },
    }) as any;
  }

  size(size: number, message?: errorUtil.ErrMessage): this {
    return this.min(size, message).max(size, message) as any;
  }

  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
    return this.min(1, message) as any;
  }

  static create = <Value extends ZodTypeAny = ZodTypeAny>(
    valueType: Value,
    params?: RawCreateParams
  ): ZodSet<Value> => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params),
    });
  };
}

///////////////////////////////////////////
///////////////////////////////////////////
//////////                       //////////
//////////      ZodFunction      //////////
//////////                       //////////
///////////////////////////////////////////
///////////////////////////////////////////
export interface ZodFunctionDef<
  Args extends ZodTuple<any, any> = ZodTuple<any, any>,
  Returns extends ZodTypeAny = ZodTypeAny
> extends ZodTypeDef {
  args: Args;
  returns: Returns;
  typeName: ZodFirstPartyTypeKind.ZodFunction;
}

export type OuterTypeOfFunction<
  Args extends ZodTuple<any, any>,
  Returns extends ZodTypeAny
> = Args["_input"] extends Array<any>
  ? (...args: Args["_input"]) => Returns["_output"]
  : never;

export type InnerTypeOfFunction<
  Args extends ZodTuple<any, any>,
  Returns extends ZodTypeAny
> = Args["_output"] extends Array<any>
  ? (...args: Args["_output"]) => Returns["_input"]
  : never;

export class ZodFunction<
  Args extends ZodTuple<any, any>,
  Returns extends ZodTypeAny
> extends ZodType<
  OuterTypeOfFunction<Args, Returns>,
  ZodFunctionDef<Args, Returns>,
  InnerTypeOfFunction<Args, Returns>
> {
  _parse(input: ParseInput): ParseReturnType<any> {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          overrideErrorMap,
          defaultErrorMap,
        ].filter((x) => !!x) as ZodErrorMap[],
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error,
        },
      });
    }

    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          overrideErrorMap,
          defaultErrorMap,
        ].filter((x) => !!x) as ZodErrorMap[],
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error,
        },
      });
    }

    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;

    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args: any[]) => {
        const error = new ZodError([]);
        const parsedArgs = await this._def.args
          .parseAsync(args, params)
          .catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
        const result = await fn(...(parsedArgs as any));
        const parsedReturns = await (
          this._def.returns as ZodPromise<ZodTypeAny>
        )._def.type
          .parseAsync(result, params)
          .catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
        return parsedReturns;
      });
    } else {
      return OK((...args: any[]) => {
        const parsedArgs = this._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn(...(parsedArgs.data as any));
        const parsedReturns = this._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      }) as any;
    }
  }

  parameters() {
    return this._def.args;
  }

  returnType() {
    return this._def.returns;
  }

  args<Items extends Parameters<typeof ZodTuple["create"]>[0]>(
    ...items: Items
  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,
    });
  }

  returns<NewReturnType extends ZodType<any, any>>(
    returnType: NewReturnType
  ): ZodFunction<Args, NewReturnType> {
    return new ZodFunction({
      ...this._def,
      returns: returnType,
    });
  }

  implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): F {
    const validatedFunc = this.parse(func);
    return validatedFunc as any;
  }

  strictImplement(
    func: InnerTypeOfFunction<Args, Returns>
  ): InnerTypeOfFunction<Args, Returns> {
    const validatedFunc = this.parse(func);
    return validatedFunc as any;
  }

  validate = this.implement;

  static create = <
    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
    U extends ZodTypeAny = ZodUnknown
  >(
    args?: T,
    returns?: U,
    params?: RawCreateParams
  ): ZodFunction<T, U> => {
    return new ZodFunction({
      args: (args
        ? args.rest(ZodUnknown.create())
        : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params),
    }) as any;
  };
}

///////////////////////////////////////
///////////////////////////////////////
//////////                   //////////
//////////      ZodLazy      //////////
//////////                   //////////
///////////////////////////////////////
///////////////////////////////////////
export interface ZodLazyDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  getter: () => T;
  typeName: ZodFirstPartyTypeKind.ZodLazy;
}

export class ZodLazy<T extends ZodTypeAny> extends ZodType<
  output<T>,
  ZodLazyDef<T>,
  input<T>
> {
  get schema(): T {
    return this._def.getter();
  }

  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }

  static create = <T extends ZodTypeAny>(
    getter: () => T,
    params?: RawCreateParams
  ): ZodLazy<T> => {
    return new ZodLazy({
      getter: getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////////
//////////////////////////////////////////
//////////                      //////////
//////////      ZodLiteral      //////////
//////////                      //////////
//////////////////////////////////////////
//////////////////////////////////////////
export interface ZodLiteralDef<T = any> extends ZodTypeDef {
  value: T;
  typeName: ZodFirstPartyTypeKind.ZodLiteral;
}

export class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value,
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }

  get value() {
    return this._def.value;
  }

  static create = <T extends Primitive>(
    value: T,
    params?: RawCreateParams
  ): ZodLiteral<T> => {
    return new ZodLiteral({
      value: value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params),
    });
  };
}

///////////////////////////////////////
///////////////////////////////////////
//////////                   //////////
//////////      ZodEnum      //////////
//////////                   //////////
///////////////////////////////////////
///////////////////////////////////////
export type ArrayKeys = keyof any[];
export type Indices<T> = Exclude<keyof T, ArrayKeys>;

type EnumValues = [string, ...string[]];

type Values<T extends EnumValues> = {
  [k in T[number]]: k;
};

export interface ZodEnumDef<T extends EnumValues = EnumValues>
  extends ZodTypeDef {
  values: T;
  typeName: ZodFirstPartyTypeKind.ZodEnum;
}

type Writeable<T> = { -readonly [P in keyof T]: T[P] };

function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(
  values: T
): ZodEnum<Writeable<T>>;
function createZodEnum<U extends string, T extends [U, ...U[]]>(
  values: T
): ZodEnum<T>;
function createZodEnum(values: any) {
  return new ZodEnum({
    values: values as any,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
  }) as any;
}

export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
  T[number],
  ZodEnumDef<T>
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_enum_value,
        options: this._def.values,
      });
      return INVALID;
    }
    return OK(input.data);
  }

  get options() {
    return this._def.values;
  }

  get enum(): Values<T> {
    const enumValues: any = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues as any;
  }

  get Values(): Values<T> {
    const enumValues: any = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues as any;
  }

  get Enum(): Values<T> {
    const enumValues: any = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues as any;
  }

  static create = createZodEnum;
}

/////////////////////////////////////////////
/////////////////////////////////////////////
//////////                         //////////
//////////      ZodNativeEnum      //////////
//////////                         //////////
/////////////////////////////////////////////
/////////////////////////////////////////////
export interface ZodNativeEnumDef<T extends EnumLike = EnumLike>
  extends ZodTypeDef {
  values: T;
  typeName: ZodFirstPartyTypeKind.ZodNativeEnum;
}

type EnumLike = { [k: string]: string | number; [nu: number]: string };

export class ZodNativeEnum<T extends EnumLike> extends ZodType<
  T[keyof T],
  ZodNativeEnumDef<T>
> {
  _parse(input: ParseInput): ParseReturnType<T[keyof T]> {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_enum_value,
        options: util.objectValues(nativeEnumValues),
      });
      return INVALID;
    }
    return OK(input.data);
  }

  get enum() {
    return this._def.values;
  }

  static create = <T extends EnumLike>(
    values: T,
    params?: RawCreateParams
  ): ZodNativeEnum<T> => {
    return new ZodNativeEnum({
      values: values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////////
//////////////////////////////////////////
//////////                      //////////
//////////      ZodPromise      //////////
//////////                      //////////
//////////////////////////////////////////
//////////////////////////////////////////
export interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  type: T;
  typeName: ZodFirstPartyTypeKind.ZodPromise;
}

export class ZodPromise<T extends ZodTypeAny> extends ZodType<
  Promise<T["_output"]>,
  ZodPromiseDef<T>,
  Promise<T["_input"]>
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { ctx } = this._processInputParams(input);
    if (
      ctx.parsedType !== ZodParsedType.promise &&
      ctx.common.async === false
    ) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    const promisified =
      ctx.parsedType === ZodParsedType.promise
        ? ctx.data
        : Promise.resolve(ctx.data);

    return OK(
      promisified.then((data: any) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap,
        });
      })
    );
  }

  static create = <T extends ZodTypeAny>(
    schema: T,
    params?: RawCreateParams
  ): ZodPromise<T> => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////////////
//////////////////////////////////////////////
//////////                          //////////
//////////        ZodEffects        //////////
//////////                          //////////
//////////////////////////////////////////////
//////////////////////////////////////////////

export type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
export type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void;

export type RefinementEffect<T> = {
  type: "refinement";
  refinement: (arg: T, ctx: RefinementCtx) => any;
};
export type TransformEffect<T> = {
  type: "transform";
  transform: (arg: T) => any;
};
export type PreprocessEffect<T> = {
  type: "preprocess";
  transform: (arg: T) => any;
};
export type Effect<T> =
  | RefinementEffect<T>
  | TransformEffect<T>
  | PreprocessEffect<T>;

export interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  schema: T;
  typeName: ZodFirstPartyTypeKind.ZodEffects;
  effect: Effect<any>;
}

export class ZodEffects<
  T extends ZodTypeAny,
  Output = T["_output"],
  Input = T["_input"]
> extends ZodType<Output, ZodEffectsDef<T>, Input> {
  innerType() {
    return this._def.schema;
  }

  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { status, ctx } = this._processInputParams(input);

    const effect = this._def.effect || null;

    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);

      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed) => {
          return this._def.schema._parseAsync({
            data: processed,
            path: ctx.path,
            parent: ctx,
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx,
        });
      }
    }

    if (effect.type === "refinement") {
      const checkCtx: RefinementCtx = {
        addIssue: (arg: IssueData) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        },
      };

      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);

      const executeRefinement = (
        acc: unknown
        // effect: RefinementEffect<any>
      ): any => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
          );
        }
        return acc;
      };

      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
        if (inner.status === "aborted") return INVALID;
        if (inner.status === "dirty") status.dirty();

        // return value is ignored
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema
          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
          .then((inner) => {
            if (inner.status === "aborted") return INVALID;
            if (inner.status === "dirty") status.dirty();

            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
      }
    }

    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
        // if (base.status === "aborted") return INVALID;
        // if (base.status === "dirty") {
        //   return { status: "dirty", value: base.value };
        // }
        if (!isValid(base)) return base;

        const result = effect.transform(base.value);
        if (result instanceof Promise) {
          throw new Error(
            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
          );
        }
        return OK(result);
      } else {
        return this._def.schema
          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
          .then((base) => {
            if (!isValid(base)) return base;
            // if (base.status === "aborted") return INVALID;
            // if (base.status === "dirty") {
            //   return { status: "dirty", value: base.value };
            // }
            return Promise.resolve(effect.transform(base.value)).then(OK);
          });
      }
    }

    util.assertNever(effect);
  }

  static create = <I extends ZodTypeAny>(
    schema: I,
    effect: Effect<I["_output"]>,
    params?: RawCreateParams
  ): ZodEffects<I, I["_output"]> => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params),
    });
  };

  static createWithPreprocess = <I extends ZodTypeAny>(
    preprocess: (arg: unknown) => unknown,
    schema: I,
    params?: RawCreateParams
  ): ZodEffects<I, I["_output"]> => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params),
    });
  };
}

export { ZodEffects as ZodTransformer };

///////////////////////////////////////////
///////////////////////////////////////////
//////////                       //////////
//////////      ZodOptional      //////////
//////////                       //////////
///////////////////////////////////////////
///////////////////////////////////////////
export interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  innerType: T;
  typeName: ZodFirstPartyTypeKind.ZodOptional;
}

export type ZodOptionalType<T extends ZodTypeAny> = ZodOptional<T>;

export class ZodOptional<T extends ZodTypeAny> extends ZodType<
  T["_output"] | undefined,
  ZodOptionalDef<T>,
  T["_input"] | undefined
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }

  unwrap() {
    return this._def.innerType;
  }

  static create = <T extends ZodTypeAny>(
    type: T,
    params?: RawCreateParams
  ): ZodOptional<T> => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params),
    }) as any;
  };
}

///////////////////////////////////////////
///////////////////////////////////////////
//////////                       //////////
//////////      ZodNullable      //////////
//////////                       //////////
///////////////////////////////////////////
///////////////////////////////////////////
export interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  innerType: T;
  typeName: ZodFirstPartyTypeKind.ZodNullable;
}

export type ZodNullableType<T extends ZodTypeAny> = ZodNullable<T>;

export class ZodNullable<T extends ZodTypeAny> extends ZodType<
  T["_output"] | null,
  ZodNullableDef<T>,
  T["_input"] | null
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }

  unwrap() {
    return this._def.innerType;
  }

  static create = <T extends ZodTypeAny>(
    type: T,
    params?: RawCreateParams
  ): ZodNullable<T> => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params),
    }) as any;
  };
}

////////////////////////////////////////////
////////////////////////////////////////////
//////////                        //////////
//////////       ZodDefault       //////////
//////////                        //////////
////////////////////////////////////////////
////////////////////////////////////////////
export interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  innerType: T;
  defaultValue: () => util.noUndefined<T["_input"]>;
  typeName: ZodFirstPartyTypeKind.ZodDefault;
}

export class ZodDefault<T extends ZodTypeAny> extends ZodType<
  util.noUndefined<T["_output"]>,
  ZodDefaultDef<T>,
  T["_input"] | undefined
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx,
    });
  }

  removeDefault() {
    return this._def.innerType;
  }

  static create = <T extends ZodTypeAny>(
    type: T,
    params?: RawCreateParams
  ): ZodOptional<T> => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params),
    }) as any;
  };
}

/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodNaN         //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////

export interface ZodNaNDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodNaN;
}

export class ZodNaN extends ZodType<number, ZodNaNDef> {
  _parse(input: ParseInput): ParseReturnType<any> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    return { status: "valid", value: input.data };
  }

  static create = (params?: RawCreateParams): ZodNaN => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params),
    });
  };
}

export const custom = <T>(
  check?: (data: unknown) => any,
  params?: Parameters<ZodTypeAny["refine"]>[1]
): ZodType<T> => {
  if (check) return ZodAny.create().refine(check, params);
  return ZodAny.create();
};

export { ZodType as Schema, ZodType as ZodSchema };

export const late = {
  object: ZodObject.lazycreate,
};

export enum ZodFirstPartyTypeKind {
  ZodString = "ZodString",
  ZodNumber = "ZodNumber",
  ZodNaN = "ZodNaN",
  ZodBigInt = "ZodBigInt",
  ZodBoolean = "ZodBoolean",
  ZodDate = "ZodDate",
  ZodUndefined = "ZodUndefined",
  ZodNull = "ZodNull",
  ZodAny = "ZodAny",
  ZodUnknown = "ZodUnknown",
  ZodNever = "ZodNever",
  ZodVoid = "ZodVoid",
  ZodArray = "ZodArray",
  ZodObject = "ZodObject",
  ZodUnion = "ZodUnion",
  ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
  ZodIntersection = "ZodIntersection",
  ZodTuple = "ZodTuple",
  ZodRecord = "ZodRecord",
  ZodMap = "ZodMap",
  ZodSet = "ZodSet",
  ZodFunction = "ZodFunction",
  ZodLazy = "ZodLazy",
  ZodLiteral = "ZodLiteral",
  ZodEnum = "ZodEnum",
  ZodEffects = "ZodEffects",
  ZodNativeEnum = "ZodNativeEnum",
  ZodOptional = "ZodOptional",
  ZodNullable = "ZodNullable",
  ZodDefault = "ZodDefault",
  ZodPromise = "ZodPromise",
}
export type ZodFirstPartySchemaTypes =
  | ZodString
  | ZodNumber
  | ZodNaN
  | ZodBigInt
  | ZodBoolean
  | ZodDate
  | ZodUndefined
  | ZodNull
  | ZodAny
  | ZodUnknown
  | ZodNever
  | ZodVoid
  | ZodArray<any, any>
  | ZodObject<any, any, any, any, any>
  | ZodUnion<any>
  | ZodDiscriminatedUnion<any, any, any>
  | ZodIntersection<any, any>
  | ZodTuple<any, any>
  | ZodRecord<any, any>
  | ZodMap<any>
  | ZodSet<any>
  | ZodFunction<any, any>
  | ZodLazy<any>
  | ZodLiteral<any>
  | ZodEnum<any>
  | ZodEffects<any, any, any>
  | ZodNativeEnum<any>
  | ZodOptional<any>
  | ZodNullable<any>
  | ZodDefault<any>
  | ZodPromise<any>;

const instanceOfType = <T extends new (...args: any[]) => any>(
  cls: T,
  params: Parameters<ZodTypeAny["refine"]>[1] = {
    message: `Input not instance of ${cls.name}`,
  }
) => custom<InstanceType<T>>((data) => data instanceof cls, params);

const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();

export {
  anyType as any,
  arrayType as array,
  bigIntType as bigint,
  booleanType as boolean,
  dateType as date,
  discriminatedUnionType as discriminatedUnion,
  effectsType as effect,
  enumType as enum,
  functionType as function,
  instanceOfType as instanceof,
  intersectionType as intersection,
  lazyType as lazy,
  literalType as literal,
  mapType as map,
  nanType as nan,
  nativeEnumType as nativeEnum,
  neverType as never,
  nullType as null,
  nullableType as nullable,
  numberType as number,
  objectType as object,
  oboolean,
  onumber,
  optionalType as optional,
  ostring,
  preprocessType as preprocess,
  promiseType as promise,
  recordType as record,
  setType as set,
  strictObjectType as strictObject,
  stringType as string,
  effectsType as transformer,
  tupleType as tuple,
  undefinedType as undefined,
  unionType as union,
  unknownType as unknown,
  voidType as void,
};
````

## File: deno/lib/ZodError.ts
````typescript
import { ZodParsedType } from "./helpers/parseUtil.ts";
import { Primitive } from "./helpers/typeAliases.ts";
import { util } from "./helpers/util.ts";

export const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
]);

export type ZodIssueCode = keyof typeof ZodIssueCode;

export type ZodIssueBase = {
  path: (string | number)[];
  message?: string;
};

export interface ZodInvalidTypeIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_type;
  expected: ZodParsedType;
  received: ZodParsedType;
}

export interface ZodInvalidLiteralIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_literal;
  expected: unknown;
}

export interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.unrecognized_keys;
  keys: string[];
}

export interface ZodInvalidUnionIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_union;
  unionErrors: ZodError[];
}

export interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_union_discriminator;
  options: Primitive[];
}

export interface ZodInvalidEnumValueIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_enum_value;
  options: (string | number)[];
}

export interface ZodInvalidArgumentsIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_arguments;
  argumentsError: ZodError;
}

export interface ZodInvalidReturnTypeIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_return_type;
  returnTypeError: ZodError;
}

export interface ZodInvalidDateIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_date;
}

export type StringValidation = "email" | "url" | "uuid" | "regex" | "cuid";

export interface ZodInvalidStringIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_string;
  validation: StringValidation;
}

export interface ZodTooSmallIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.too_small;
  minimum: number;
  inclusive: boolean;
  type: "array" | "string" | "number" | "set";
}

export interface ZodTooBigIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.too_big;
  maximum: number;
  inclusive: boolean;
  type: "array" | "string" | "number" | "set";
}

export interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_intersection_types;
}

export interface ZodNotMultipleOfIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.not_multiple_of;
  multipleOf: number;
}

export interface ZodCustomIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.custom;
  params?: { [k: string]: any };
}

export type DenormalizedError = { [k: string]: DenormalizedError | string[] };

export type ZodIssueOptionalMessage =
  | ZodInvalidTypeIssue
  | ZodInvalidLiteralIssue
  | ZodUnrecognizedKeysIssue
  | ZodInvalidUnionIssue
  | ZodInvalidUnionDiscriminatorIssue
  | ZodInvalidEnumValueIssue
  | ZodInvalidArgumentsIssue
  | ZodInvalidReturnTypeIssue
  | ZodInvalidDateIssue
  | ZodInvalidStringIssue
  | ZodTooSmallIssue
  | ZodTooBigIssue
  | ZodInvalidIntersectionTypesIssue
  | ZodNotMultipleOfIssue
  | ZodCustomIssue;

export type ZodIssue = ZodIssueOptionalMessage & { message: string };

export const quotelessJson = (obj: any) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

export type ZodFormattedError<T> = {
  _errors: string[];
} & (T extends [any, ...any[]]
  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
  : T extends any[]
  ? ZodFormattedError<T[number]>[]
  : T extends object
  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
  : unknown);

export class ZodError<T = any> extends Error {
  issues: ZodIssue[] = [];

  get errors() {
    return this.issues;
  }

  constructor(issues: ZodIssue[]) {
    super();

    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      // eslint-disable-next-line ban/ban
      Object.setPrototypeOf(this, actualProto);
    } else {
      (this as any).__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }

  format = (): ZodFormattedError<T> => {
    const fieldErrors: ZodFormattedError<T> = { _errors: [] } as any;
    const processError = (error: ZodError) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          (fieldErrors as any)._errors.push(issue.message);
        } else {
          let curr: any = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;

            if (!terminal) {
              if (typeof el === "string") {
                curr[el] = curr[el] || { _errors: [] };
              } else if (typeof el === "number") {
                const errorArray: any = [];
                errorArray._errors = [];
                curr[el] = curr[el] || errorArray;
              }
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(issue.message);
            }

            curr = curr[el];
            i++;
          }
        }
      }
    };

    processError(this);
    return fieldErrors;
  };

  static create = (issues: ZodIssue[]) => {
    const error = new ZodError(issues);
    return error;
  };

  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, null, 2);
  }

  get isEmpty(): boolean {
    return this.issues.length === 0;
  }

  addIssue = (sub: ZodIssue) => {
    this.issues = [...this.issues, sub];
  };

  addIssues = (subs: ZodIssue[] = []) => {
    this.issues = [...this.issues, ...subs];
  };

  flatten(mapper?: (issue: ZodIssue) => string): {
    formErrors: string[];
    fieldErrors: { [k: string]: string[] };
  };
  flatten<U>(mapper?: (issue: ZodIssue) => U): {
    formErrors: U[];
    fieldErrors: { [k: string]: U[] };
  };
  flatten<U = string>(
    mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any
  ): {
    formErrors: U[];
    fieldErrors: { [k: string]: U[] };
  } {
    const fieldErrors: any = {};
    const formErrors: U[] = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }

  get formErrors() {
    return this.flatten();
  }
}

type stripPath<T extends object> = T extends any
  ? util.OmitKeys<T, "path">
  : never;

export type IssueData = stripPath<ZodIssueOptionalMessage> & {
  path?: (string | number)[];
  fatal?: boolean;
};
export type MakeErrorData = IssueData;

type ErrorMapCtx = {
  defaultError: string;
  data: any;
};

export type ZodErrorMap = typeof defaultErrorMap;
export const defaultErrorMap = (
  issue: ZodIssueOptionalMessage,
  _ctx: ErrorMapCtx
): { message: string } => {
  let message: string;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === "undefined") {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(
        issue.expected
      )}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${issue.keys
        .map((k) => `'${k}'`)
        .join(", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${issue.options
        .map((val) => (typeof val === "string" ? `'${val}'` : val))
        .join(" | ")}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${issue.options
        .map((val) => (typeof val === "string" ? `'${val}'` : val))
        .join(" | ")}`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
      else message = "Invalid";
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${
          issue.inclusive ? `at least` : `more than`
        } ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${
          issue.inclusive ? `at least` : `over`
        } ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be greater than ${
          issue.inclusive ? `or equal to ` : ``
        }${issue.minimum}`;
      else message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${
          issue.inclusive ? `at most` : `less than`
        } ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${
          issue.inclusive ? `at most` : `under`
        } ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be less than ${
          issue.inclusive ? `or equal to ` : ``
        }${issue.maximum}`;
      else message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};

export let overrideErrorMap = defaultErrorMap;

export const setErrorMap = (map: ZodErrorMap) => {
  overrideErrorMap = map;
};
````

## File: deno/build.mjs
````
// This script expects to be run via `yarn build:deno`.
//
// Although this script generates code for use in Deno, this script itself is
// written for Node so that contributors do not need to install Deno to build.
//
// @ts-check

import {
  mkdirSync,
  readdirSync,
  readFileSync,
  statSync,
  writeFileSync,
} from "fs";
import { dirname } from "path";

// Node's path.join() normalize explicitly-relative paths like "./index.ts" to
// paths like "index.ts" which don't work as relative ES imports, so we do this.
const join = (/** @type string[] */ ...parts) =>
  parts.join("/").replace(/\/\//g, "/");

const projectRoot = process.cwd();
const nodeSrcRoot = join(projectRoot, "src");
const denoLibRoot = join(projectRoot, "deno", "lib");

const skipList = [join(nodeSrcRoot, "__tests__", "object-in-es5-env.test.ts")];
const walkAndBuild = (/** @type string */ dir) => {
  for (const entry of readdirSync(join(nodeSrcRoot, dir), {
    withFileTypes: true,
    encoding: "utf-8",
  })) {
    if (entry.isDirectory()) {
      walkAndBuild(join(dir, entry.name));
    } else if (entry.isFile() && entry.name.endsWith(".ts")) {
      const nodePath = join(nodeSrcRoot, dir, entry.name);
      const denoPath = join(denoLibRoot, dir, entry.name);

      if (skipList.includes(nodePath)) {
        // console.log(`Skipping ${nodePath}`);
        continue;
      }

      const nodeSource = readFileSync(nodePath, { encoding: "utf-8" });

      const denoSource = nodeSource.replace(
        /^(?:import|export)[\s\S]*?from\s*['"]([^'"]*)['"];$/gm,
        (line, target) => {
          if (target === "@jest/globals") {
            return `import { expect } from "https://deno.land/x/expect@v0.2.6/mod.ts";\nconst test = Deno.test;`;
          }

          const targetNodePath = join(dirname(nodePath), target);
          const targetNodePathIfFile = targetNodePath + ".ts";
          const targetNodePathIfDir = join(targetNodePath, "index.ts");

          try {
            if (statSync(targetNodePathIfFile)?.isFile()) {
              return line.replace(target, target + ".ts");
            }
          } catch (error) {
            if (error?.code !== "ENOENT") {
              throw error;
            }
          }

          try {
            if (statSync(targetNodePathIfDir)?.isFile()) {
              return line.replace(target, join(target, "index.ts"));
            }
          } catch (error) {
            if (error?.code !== "ENOENT") {
              throw error;
            }
          }

          // console.warn(`Skipping non-resolvable import:\n  ${line}`);
          return line;
        }
      );

      mkdirSync(dirname(denoPath), { recursive: true });
      writeFileSync(denoPath, denoSource, { encoding: "utf-8" });
    }
  }
};

walkAndBuild("");

writeFileSync(join(denoLibRoot, "mod.ts"), `export * from "./index.ts";\n`, {
  encoding: "utf-8",
});
````

## File: docs/index.html
````html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Document</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="description" content="Description" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />
    <link
      rel="stylesheet"
      href="//cdn.jsdelivr.net/npm/docsify/lib/themes/vue.css"
    />
  </head>

  <body>
    <nav
      style="
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
      "
    >
      <!-- <a href="https://twitter.com/colinhacks"
        ><span style="color: #888888">created by @colinhacks</span></a
      > -->
    </nav>
    <div id="app"></div>
    <script>
      window.$docsify = {
        repo: "colinhacks/zod",
        name: "Zod",
        nameLink: "https:zod.js.org",
        // subMaxLevel: 2,
        // logo: "logo.svg",
        themeColor: "#2552A8",
      };
    </script>
    <script src="//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.21.0/components/prism-typescript.min.js"></script>

    <style>
      .markdown-section {
        max-width: 700px;
      }
      h2 code,
      h3 code,
      h4 code {
        font-size: 75%;
      }
      hr {
        height: 1px;
        border: 0px;
        background: #dddddd;
        margin-right: 10px;
      }
    </style>
  </body>
</html>
````

## File: docs/logo.svg
````
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 1080 1080" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-miterlimit:5;">
    <use xlink:href="#_Image1" x="112.458" y="229.1" width="867.625px" height="669.651px" transform="matrix(0.999568,0,0,0.999479,0,0)"/>
    <g transform="matrix(0.116243,0,0,0.473619,-23.7923,-3587.35)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.0900481,0,0,0.473619,101.204,-3534.08)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.0481846,0,0,0.133311,454.599,-550.685)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.17212,-0.0993737,0.446387,0.773164,-4264.21,-6040.13)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.110306,-0.0636855,0.0916929,0.158817,-1037.66,-798.056)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.110306,-0.0636855,0.0916929,0.158817,-1050.22,-812.682)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.110306,-0.0636855,0.0916929,0.158817,-1062.67,-824.113)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.116652,-0.067349,0.0722158,0.125081,-870.022,-471.251)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.12113,-0.0699344,0.0722158,0.125081,-874.027,-449.65)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.129529,-0.0747837,0.0916929,0.158817,-1067.52,-724.985)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.0389201,-0.0224705,0.296775,0.514029,-2065.36,-4228.86)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <use xlink:href="#_Image2" x="30" y="160" width="1045px" height="842px"/>
    <g transform="matrix(1.01688,0,-5.64483e-17,1.01688,-1013.22,-4627.54)">
        <path d="M1825.05,4726.89L1250.49,4726.89L1040.57,4935.73L1517.16,5509.64L1555.18,5466.98L2026.94,4937.69L1825.05,4726.89ZM1804.06,4776.06L1960,4938.89L1518.48,5434.26L1107.11,4938.89L1270.78,4776.06L1804.06,4776.06Z" style="fill:rgb(48,104,183);"/>
    </g>
    <defs>
        <image id="_Image1" width="868px" height="670px" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA2QAAAKeCAYAAADKltgDAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAgAElEQVR4nOzdeZwcd33n//enFHAPYKZmTCBqWQUM2IDxAfRweHzbGN/yBQYC5GDZXbK7YcMmbLIk2ZD8siH3I8lmfwkk2STk5j6MwWfZxpKvlrEBX2V7bPfIbYPLM92+pm1L9d0/qkeakXXM0dXfPl7Ph/SQaKSuD/boQb1UVZ82AT0mjCo/Jukzko72PQsAABga/9aobf1N30Ng+JjvAYDF2jH2j5Le63sWAAAwdD7ZqG39tO8hMFzW+R4AWNCOsX8SMQYAAPw4pTRabrSaD9/oexAMD4IMPSGMKi+Q9M+SLvI9CwAAGGqnl0bLD7WaD9/iexAMB4IM3rVj7F8kvdv3LAAAAJLOKY2W7201H/6+70Ew+AgyeLUoxi70PQsAAECbSTq3NFr+fqv58F2+h8FgY6kHvGnH2L9KusD3LAAAAHvwnKRzG7Wt3/I9CAYXQQYvwqjyQuUxdr7vWQAAAPahJemMRm3r1b4HwWAiyNB17Rj7vKRzfc8CAACwDE9JOrVR23q970EweAgydBUxBgAA+lRT0smN2la2L6KjCDJ0TRhVDpD0BUnn+J4FAABgFR6TdGKjtvUHvgfB4CDI0BXtGPuipLN9zwIAALAGP5R0XKO29R7fg2AwEGQoXDvGviTpLD8T8GUOAAA6akZyxzVqWx/0PQj6H2eqKFQYVUrKY+zM7hzR2l/VfGkDAIBCTUs6rvHgzXXfg6C/cdaKwrRj7MuSzujKAc0kmaz94644AwAAKIDTnZI7Ye6BGx/1PQr6F6erKEQ7xr4i6fSuHNACmSyPMgt2RRlf4QAAoAhu509uc86dNHf/9XM+x0H/4nQVHeclxnaGWLA0yAAAAArj2t+ym+SyU2enr3/c90ToP5yxoqPCqDIi6auS3tWVA+4WYwtBJrP8ihkAAEBhXH6hzDk5l31HLjt9dnrL076nQn/hjBUd046xr0k6tSsHfF6MrZMCkylY9JXNlzgAAChKft+ic24hyi6TyzbNTm95xvNg6CPrfA+AweA3xtbtIca4ZREAABRtYaHYwlmHvUbSkSNjB39pfm4m8zoa+gZBhjULo8qLJH1d3mIs2EOMAQAAdMuuRWIme52kQ0fGNnxlfm6b2+dvA0SQYY3aMfYNSad05YDEGAAA6En5lbL2zw6XbOPI2IZvEGXYH4IMq7Yoxk7uygGJMQAA0NOWRNmbJXvZSLjhW/ONbX7HQk8jyLAqYVR5saSL1ZUYM2IMAAD0iSVR9jaZXjQSHnwFUYa9IciwYoti7KTij5Z/2DMxBgAA+sfiKNMxMrn5uZlr/M6EXkWQYUXaMfZNSScWfzRiDAAA9Kv2J6KayaQTR8Y2PjU/N7PF91ToPQQZli2MKi+RdImkE4o/GjEGAAD6nC2JsneNjG18dH5u5mbfY6G3EGRYlkUxdnzxRyPGAADAgLD2tbI8ys4aGdv44PzczK2+x0LvIMiwX2FUOVDStyQdV/zRiDEAADBIbPco2zQSbrx7fm7mdt+ToTcQZNinRTF2bPFHI8YAAMAgWhJlZqbzRsKNt87PzSS+J4N/nN1ir8Ko8lLlMTZV/NH2EGNB0P6bJGIMAAAMAtf+5iSXPeuy7OzZ6c2X+54KfnGGiz1qx9i3JR1d/NH2FmNB+2+S2r8GAACg7y2JsnmXZafPTm++1vdU8IezXDwPMQYAAFCkJVH2pMuyU2anN9/keyr4wZkulgijyqjyGHtH8UcjxgAAwLBaiLJMylzDuR0nzk5vuc33VOg+znaxUzvGLpX09uKPRowBAIBhtyTKHnVuxwmz01vu9D0VuoszXkiSwqgSKo+xtxV/NGIMAAAgtyTK6s7tOH52est9vqdC93DWi4UYu0zSW4s/GjEGAACw1OIoyx50LjtudnrLjO+p0B2B7wHgVxhVxiRdLmIMAADAk4XPKQskC15pFlw5PjH1E76nQncQZENsUYxNFn80YgwAAGDv2lFmgWTBIWbB5eMTUy/zPRWKR5ANqUUxVin+aMQYAADA/i1EmUkWHG4WXDo+MRX6ngrFIsiGUBhVxiVdIWIMAACgxyw5d3qLWXDJ+MTUS3xPheIQZENmUYy9pfijEWMAAAArt+Qc6mhZ8PXxiakR31OhGATZEAmjykGSrpT05uKPRowBAACs3q5zKbPgJFnwxfGJqRf6ngqdt873AOiOMKq8THmMvan4oxFjAAAAa7ewfVGS7BBJh42Mbfjy/Ny2zO9c6CSCbAgsirGjij/a4hhbR4wBAACsyc4ik8kOk2xiZGzD1+bntjm/c6FTCLIBtyjGjiz+aLvHWECMAQAArJnJdkXZkZKVR8Y2XDw/t83vWOgIgmyAhVHlxyVdJWIMAACgzy2JsoqkcCQ8+NL5BlHW7wiyARVGlZcrj7Ejij8aMQYAAFC8JVH2DpleMD83c5XfmbBWBNkAWhRjhxd/NGIMAACge2zn6ZVJx42MbXxufm7mO76nwuoRZANmUYy9sfijEWMAAABdZwtRZjLplJGxjc35uZkbfI+F1SHIBkgYVV4hKRYxBgAAMNiWRtnpI2Mb6/NzM7f4HgsrR5ANiDCq/ITyGDus+KMtxFhAjAEAAPhi7RsY8yg7e2Rs433zczPf8z0WVoYgGwCLYuwNxR9tcYwFxBgAAIA3tjjKzKRzR8KNt8/PzdzpezIsH2fOfS6MKuuVPzP2+uKPRowBAAD0Htf+5iSXPeey7LzZ6c2X+J4Ky8PZcx9rx1gs6XXFH40YAwAA6F1LouwZl2Vnzk5vZiV+H+AMuk+FUaWsPMYOLf5oxBgAAEDvWxJlT7kse9fs9OYtvqfCvnEW3YfCqLJBeYwdUvzRiDEAAID+sSTKHndZdvLs9OatvqfC3nEm3WeIMQAAAOzbQpRlUuZmndtxwuz0lh/4ngp7xtl0HwmjysHKY+y1xR+NGAMAAOhfS6Lsh87tOH52ekvieyo8H2fUfSKMKhuVx9hrij8aMQYAAND/FkdZts257LjZ6S0P+J4KS3FW3QfaMXa1pInij0aMAQAADI52lLlMctn97Sh7yPdU2CXwPQD2LYwqkXzFWECMAQAA9Lf2h0fn53evNguuGJ+YernvqbALQdbDvMeYEWMAAAD9byHKTLLg9WbB5eMTU+O+p0KOIOtRYVR5pfIYe3XxRyPGAAAABtvC+Z5JFhxpFnx7fGLqpb6nAkHWk8Ko8ioRYwAAAOioJVH2VrPg4vGJqRf7nmrYEWQ9ZlGMvar4oxFjAAAAw2VJlB0nC74yPjFV8j3VMFvnewDsEkaVVyuPsVcWfzRiDAAAYDiZdp7uyV4j6aiRsYO/OD83k/mdazgRZD0ijCoTIsYAAADQFTuLTCZ7naTXjYxt+Mr83DbndawhRJD1gEUxFhV/NGIMAAAAkmSyXVH2RsleOTK24etEWXcRZJ6FUeU1ymNsY/FHI8YAAACw2JIoe5NkLx8JN1wy39jmd6whQpB5FEaV14oYAwAAgFdLouytMr14JDz4CqKsOwgyTxbF2MHFH40YAwAAwL4sjjJNyaT5uZmrvY40JAgyD8KocojyGNtQ/NGIMQAAACyHtU8NTSadODK2cX5+bmaz76kGHUHWZcQYAAAAepYtibJTR8Y2PjY/N3OT77EGGUHWRWFUOVTSNZLKxR+NGAMAAMAqWPtaWR5lZ46MbZyZn5v5ru+xBhVB1iVhVHmd8itj64s/GjEGAACA1bLdo2zTSLjx7vm5mR/4nmwQEWRdEEaV10uKRYwBAACgLyyJMjPT+SPhxtvm52bu9j3ZoOHMvGCLYuwnij8aMQYAAIBOcu1vTnLZsy7LNs1Ob77U91SDhLPzAoVR5Q3KY+wVxR+NGAMAAEARlkTZvMuyM2anN1/je6pBwRl6QcKocpikq0SMAQAAoO8tibInXZadOju9+QbfUw0CztILEEaVNyqPsZcXfzRiDAAAAN2wKMqyrOFcdtLs9OZbfU/V7zhT77B2jMWSfrz4oxFjAAAA6KaFKMukzKXO7ThhdnrLHb6n6mecrXdQGFUOV35ljBgDAADAgFoSZQ87t+P42ekt9/qeql9xxt4hYVQ5QnmMvaz4oxFjAAAA8GlxlGU157LjZqe31HxP1Y8C3wMMgjCqHCliDAAAAENj4XPKAsmCyCy4cnxiqgufuTt4CLI1IsYAAAAwnNpRlp+PvtYsuGJ8YqoLj+4MFoJsDcKocpTyGDuo+KMRYwAAAOg1C1FmkgWHmQWXjk9Mhb6n6icE2SqFUeVNIsYAAAAw9BbOVU2y4M1mwbfGJ6YO9D1VvyDIViGMKm+WdKWk8eKPtivGjBgDAABAT1oSZe+QBV8fn5ga8T1VPyDIViiMKm+RpxgTMQYAAICetSvKzIITZcGXxyemDvA9Va9b53uAftKOsSskjRV/NGIMAAAA/WZh+6Ik2WslvXFk7OAvzc/NZH7n6l0E2TKFUaWi/MoYMQYAAADs1c4ik8neIOm1I2MbvjY/t815HatHEWTLEEaVSeVXxrqwMYYYAwAAQL8z2a4oO0KyDSNjGy4myp6PINuPMKq8VcQYAAAAsEJLouwtksZHwoO/Pd/Y5nWqXkOQ7UMYVd4m6XJJo8UfjRgDAADAoFkSZW+X6YCR8OCriLJdCLK9IMYAAACATrCdp7MmHSvT9vm5mWt9T9UrCLI9CKPK25XH2EuLPxoxBgAAgAFnC1FmMunkkbGNj8/Pzdzge6xeQJDtJowq7xAxBgAAAHTW0ig7bWRs4yPzczNbfY/lG0G2SBhVjpZ0maQDiz8aMQYAAIAhY+0bGPMoO2tkbOP983Mzt/keyyeCrC2MKlOSLhUxBgAAABTEFkeZmXTuSLjxzvm5mTt8T+YLZ/2SwqhyjKRvS3pJ8UcjxgAAADDsXPubk1y23WXZ+bPTmy/2PZUPQ3/mH0aVYyV9S8QYAAAA0EVLouwZl2Vnz05vvsL3VN021Gf/YVQ5TnmMvbj4oxFjAAAAwFJLouxpl2WnzU5vvs73VN00tAUQRpXjJV0iYgwAAADwaEmUPeGy7OTZ6c1V31N1S+B7AB+IMQAAAKBXLFn0caBZcOn4xNQRvqfqlqErgTCqnKA8xl5U/NGIMQAAAGB5Fq6UZVLmfuTcjuNnp7fc7Xuqog1VDYRR5URJ31RPxNhQ/aMHAAAAlmFxlGUPOZcdNzu95X7fUxVpaKogjConKY+xkeKPto8YM9MQ/WMHAAAAVmhJlD3QjrJtvqcqylA8QxZGlZNFjAEAAAB9YOGZskCy4FVmwZXjE1Ov8D1VUQY+yMKocoqki+UtxtYRYwAAAMCKtKMsv7BxqFlw+fjE1EG+pyrCQAdZGFXeKe8xZsQYAAAAsGILUWaSBUeYBd8en5ga9T1Vpw1skIVR5VRJ35BUKv5oi2IsCKRgHTEGAAAArJntOqe2YNIs+Ob4xFQXPrqqewYyyMKo8i5JX5ePGLN17UurxBgAAACwdkui7BhZ8LXxiakunOd3x8AFWRhVThMxBgAAAAyQXVFmFpwiC744PjH1Qt9TdcI63wN0UhhVTpf0NUkHFH80YgwAAADoHtt5im2yQyW9YWRsw1fm57ZlXsdao4EJsjCqnCHpqyLGAAAAgAFlsl1Rdphkrx4Z2/C1+bltzu9cqzcQQRZGlTNFjAEAAABDYEmUHSXZK0bCDZfMN/rzs6P7PsjCqHKWpK9I6sI9pMQYAAAA4N+SKJuU6cCR8ODL+zHK+jrIwqhytqQvixgDAAAAhsziKNPRMgXzczOx35lWrm+DLIwq54gYAwAAAIaY5WfiZjLphJGxjc/Mz81c53uqlejLIAujyiZJX5L0guKPRowBAAAAPcuWRNk7R8Y2zs3Pzdzoe6zl6rsgC6PKuZK+KGIMAAAAgNTeiG8LUXbGyNjGbfNzM9/1PdZy9FWQhVHlPElfEDEGAAAAYCfbPcrOGRnbeM/83Mz3fU+2P30TZGFUOV/EGAAAAIA9WhJlZtJ5I+HG78/Pzdzle7J96YuyCKPKBZL+TdKPFX80YgwAAADoX679zUkue85l2abZ6c3f9j3V3vR8XYRR5UJJ/ypiDAAAAMCyLImylsuyM2anN1/te6o96enCCKPKu5XHWBdurSTGAAAAgMGxJMqecll26uz05ut9T7W7nq2MMKq8R9K/iBgDAAAAsCqLoizLms5lJ89Ob77F91SL9WRphFHlIkn/LGIMAAAAwJosRFkmZe4x53acMDu95XbfUy3oudoIo8p7Jf2TiDEAAAAAHbEkyh5xbsfxs9Nb7vE9ldRjxRFGlfcpj7Gg+KMRYwAAAMDwWBxl2Yxz2XGz01se9D1VF8JnecKo8n4RYwAAAAAKsfA5ZYFkwUaz4MrxialyD0zlXxhVflLSP6hrMRbIzGTBuvbPiTEAAABgOLSvlLlMctmdzmUnzE5vedTXNN6vkIVR5YMixgAAAAB0RftKmZlkwRvMgsvHJ6bGfE3jNcjaMfb33ZmDGAMAAAAg7XqEySQLjjILvjU+MXWgj0m8BVkYVX5K0ue6MwMxBgAAAGCxJVH2dllw8fjE1Iu6PYWXIAujyk9L+jt1pYSIMQAAAAB7sivKzILjZcFXxiemDujmBF34rK+lwqjyM5L+VsQYAAAAAO8Wti9Kkr1G0hEjYwd/aX5uJuvG0bsaZGFU+VlJ/1fdKCEjxgAAAAAsx84ik8leL+mQkbENX52f2+aKPnLXgiyMKh+W9DfqVoyJGAMAAACwXJZnRP6zwyXbODK24RtFR1lXgiyMKv9OxBgAAACAnrYkyt4s2ctGwg3fmm9sK+yIhQdZGFU+Iumviz6OJGIMAAAAwBotibK3yTQyEh58ZVFRVmiQhVHlP0j6bJHH2IkYAwAAANARi6NMx8iUzc/NXFPEkQoLsjCq/EdJnynq/ZcgxgAAAAB0lOUVYSaTThoZ2/jk/NzM9Z0+SiFBFkaVj0r6yyLe+3mIMQAAAABFsCVR9q6RsY2Pzs/N3NzJQ3Q8yMKo8nOS/qLT77tHxBgAAACAIln7WlkeZWeNjG18cH5u5tZOvX1HgyyMKv9Z0v/p5Hvu1V5izIgxAAAAAB1ju0fZppFw493zczO3d+LdOxZk7Rj780693z7tI8ZEjAEAAADoqCVRZmY6byTceOv83EzSgXdeuzCq/LykP+vEe+0XMQYAAADAC9f+5iSXPeuy7OzZ6c2Xr+Ud11wvYVT5mKQ/Xev7LAsxBgAAAMCrJVE277LstNnpzd9Z7butqWDCqPJfJf3JWt5j2XbGWCALAmIMAAAAgCdLouwJl2XvnJ3efNNq3ilY7QhhVPkFEWMAAAAAhs6SZ8oONAu+PT4xddQq32nlwqjycUl/vJrfu2LEGAAAAICetHClLJMy96hzO06Ynd5y50reYcVXyMKo8osixgAAAAAMvYUrZYEU2I+brbtifGLqNSt5hxUFWRhVfknSH65oxtUixgAAAAD0vCVRVjYLrhyfmNq43N+97CALo8onJP3BqmZcKWIMAAAAQN9YFGUWvLIdZT+xnN+5rCALo8ovS/r9Nc24XMQYAAAAgL7TjjILJAsOMQsuH5+YOmh/v2u/QRZGlV+R9LsdmXF/iDEAAAAAfWshykyy4HCz4NLxianRff2OfQZZGFX+h6RPd3TGvSHGAAAAAPS9vF/aUVYxCy4Zn5h6yd5+9V6DLIwqvyrpdwqZcXe7xZgRYwAAAAD61pIom5IFXx+fmBrZ06/cY5CFUeXXJP12oTMu2EOMiRgDAAAA0Nd2RZlZcJIs+OL4xNQLd/9V63Z/IYwqvy7p/+vOjMQYAAAAgEG1sH1RkuwQSYeNjG348vzctmzhVywJsjCq/Iak3+zObMQYAAAAgEG3s8hkssMkmxgZ2/C1+bltTloUZGFU+ZSkT3VnJmIMAAAAwLCwPHPynx0p2fqRsQ3fnJ/blgdZO8Z+ozuzEGMAAAAAhs2SKKtICkfCgy9d196m+FvdmYEYAwAAADCsFkeZ3iFT9mOSbpPkVHQNEWMAAAAAhp7JJDkLnjNp87pW8+GkNFp+StK7ijsmMQYAAAAAkvJ1+NJPP3bvtV9bJ0ml0fL1kl4l6U3FHIwYAwAAAIC2/57ec/VfSu0Phm7UtjpJ/1HSlo4eph1jIsYAAAAAQJL+TNIfLvyHJUUURpWXS7pZUrTmwyzEWDvEiDEAAAAAQ+6Lkt6XJvGOhReeV0VhVDlS+ZWyF6/6MMQYAAAAACx2raTT0iRuLX4x2P1XNWpbvyfpA8o3L64cMQYAAAAAi90u6bzdY0xS/sHQu2s1H767NFp+VtIpKzoMMQYAAAAAiz0k6aQ0iX+4p/9yj0EmSaXR8mZJr5V05LIOQ4wBAAAAwGJNSaekSXzP3n7BPispjColSVdLevs+D0OMAQAAAMBizyp/Zuzqff2i5z1DtlijtrUl6TxJ2/b6i4gxAAAAAFjMSfrQ/mJM2k+QSVKjtvURSedKmn/ef0mMAQAAAMDuPp4m8eeX8wv3G2SS1KhtvUXSh5a+avlvN2IMAAAAANr+ME3iP13uL97rUo/dtZoP31kaLWeSTpK0NMSCde2fE2MAAAAAhta/SPpPTz/2wLI/QmzZQSZJpdHydyS9XrLDZSYzkwWBLGhfHdNCkAEAAADAULlK0kVpEm9fyW9acT2FUWVEsmtlNmkWyIJ1smDdrtsVuToGAAAAYLh8T9LxaRI3V/obl/UM2WKN2tZ5yZ0n6WFJknNyzknO5btEtOyrcwAAAADQ72qSzlhNjEmrCDJJatS2PiTnznXOtfIYy/IwE1EGAAAAYGjMSTo9TeL6at9gRc+QLdZq1uulcP19Znp3/oq193kYz5IBAAAAGHQt5VfGblnLm6w6yCSp1az/oDRaXmfSCZItfMujLP/JWt4eAAAAAHqRk/TeNIkvW+sbrSnIJKk0Wr5G0uEmHSapHWV5iBFlAAAAAAbQz6dJ/LlOvFFHaimMJl8ss++YBW/OV+DzuWQAAAAABtKn0yT+ZKfebFVLPXbXqFWfypd8ZD90WdZe8pG1ty9KLPkAAAAAMAA+J+lXO/mGHb10FUaT7zALrlYQHJBfIVsnBQsfGN3xwwEAAABAt1wm6ew0iZ/r5Juu+RmyxVrN+rZSuP4Bky7IX2HzIgAAAIC+d4ukM9Mknu/0G3c0yCSp1ax/rzRaLpl0LJsXAQAAAPS5+yWdkibxbBFv3vEgk6TSaDmW9CaTXr/QYLawe5EoAwAAANAfHpN0UprEDxZ1gMLKKIwmXyKzzWbBkWxeBAAAANBn5iWdnCbxDUUepCNbFvekUas+Kec2OeceXbJ5UWxeBAAAANDTMuUf/FxojEkFBpkkNWrVB+Wy8+Xcc85lci6TMkeUAQAAAOhlP5cm8Te6caBCniFbrNWsz5TC9TMmnZe/wuZFAAAAAD3rt9Ik/qNuHazwIJOkVrN+a2m0/BKTpti8CAAAAKBH/Y2kX3z6sQe6dsCuBJkklUbLV0mqmHTozhhj8yIAAACA3nCJpA+mSZx186BdraAwmnypzLaYBW9cunkxIMoAAAAA+HKz8vX2T3X7wF0voDCanJAFN5nZQRbkQaYgkIkoAwAAANB190o6Jk3iH/k4eKFbFvekUatOS9mFcm47mxcBAAAAePSopNN9xZjUxWfIFms16w+WwvLDJm3KX2HzIgAAAICuekrSqWkS3+5zCC9BJkmtZv2W0mh5zKR3sHkRAAAAQBftkHRemsTX+h6k67csLuHcLznnLpXLpCyTc05a+M6tiwAAAACK8ZE0ib/tewjJc5A1atXtcu59zmV3O5dJ7WfK8jCTiDIAAAAAHfZraRL/ne8hFvi9QiapUas25Nw5zrk5l+VRJpfJKSPKAAAAAHTSX0r6Hd9DLNYzD2qFr5w82RRcpiBYZxbIgnWSBe0lH1IPjQoAAACg/3xN0oVpEu/wPchi3pZ67K7VrN9fCsuPmnRW/gqbFwEAAAB0xPWSzk2T+Fnfg+yuZ4JMklrNerU0Wv5xk97G5kUAAAAAHXC3pHemSfy470H2xPszZM/j3Medc1eyeREAAADAGj2i/IOfH/M9yN705CWnMJock9mNZsEhFqyTWZA/T2YBz5MBAAAAWI4nJB2fJvGtvgfZl967QiapUavOyblNzrmmy/JV+GxeBAAAALBM2yVd0OsxJvVokElSo1a9S8oukst2OLcQZU5OfEYZAAAAgH362TSJr/A9xHL01FKP3bWa9ftKYXnOpDPyV9i8CAAAAGCffjlN4r/wPcRy9ewVsp1c9ufOuc/KOe26UpblV8q4SgYAAABgl/8t6Q98D7ESfXGJKYwmXyCzy8yCE80Cqb3ow2zhKllf/M8AAAAAUJwvSnpfr33w8/70TcmE0eRBMrvJLJhg8yIAAACARb4j6V1pErd8D7JSfVUxYTR5mCy4wSw40IJ2jAWBTEQZAAAAMKTukHRsmsRzvgdZjd5/hmyRRq16h5S9Ty7L9rx5EQAAAMAQeUj5Bz/3ZYxJPb5lcU9azfo9pbD8pEmn5a8s2rzIVTIAAABgWDwu6ZQ0ie/xPcha9F2QSVJpdP0Nkm002ZslSaZ8Db5ElAEAAACD71lJZ6dJfKPvQdaqb8sljCYPkNkVZsGxbF4EAAAAhsr70iT+N99DdEJfPUO2WKNWfUbOXeBc9uDCZ5PJZXJu4XkyHioDAAAABtDHByXGpD4OMklq1KqPyrlznHNPumzxh0ZnRBkAAAAweP4oTeI/8T1EJ/V1kElSo1b9vpR9QC5zbucVMjYvAgAAAAPmXyX9d99DdFpfLvXYXatZv7sUllsmvTN/hc2LAAAAwACJJb0nTeLtvgfptIEIMkkqja7fItmrTXaUJDYvAgAAAIPh+5JOS5P4Kd+DFGGgKiWMJksyu8osONqCQDI2LwIAAAB9rCZpKk3ih3wPUpSBK5QwmnyFzG42CzZaexW+LGj/KA3g/2QAAABgEM1JOiZN4jt9D1Kkvl/qsWCkrz8AACAASURBVLtGrfpDObfJOff0rs2Ljs2LAAAAQP94RtKmQY8xaQCDTJIateqtUvYhKQ+yXVHG5kUAAACgxzlJP5km8XW+B+mGgVnqsbtWs35nabS83aST81fYvAgAAAD0gY+lSfz3vofoloENMkkqjZavk3SoyY6QxOZFAAAAoLf9bprEn/Y9RDcN5C2LCxq1qpNz/8657Ga5TFp0+6KcE/cvAgAAAD3jHyR90vcQ3TYUl4jCaHJ9e/PiBjYvAgAAAD3nMknnpEn8rO9Bum1oSiSMJiuy4DsWBCP5Z5Otk4Igv4WRKAMAAAB8+a6kE9IkfsL3ID4M9DNki7Wa9YdL4frEpPfkryxa8qGFD44GAAAA0EUPSDo5TeJZ34P4MjRBJkmtZv2O0mjZTDqxveGjfXGMzYsAAABAlz2mPMYe9D2IT0MVZJJUGi1fK+kwk94oic2LAAAAQPfNSzotTeLbfA/i21DWRxhNvkhm3zEL3mJBIFm+6MNs4dbFofzHAgAAAHRDJun8NIm/7nuQXjDQa+/3plGrPi3nznUue8Rl+Tr8fCW+a2/CZx0+AAAAUJCfI8Z2Gcogk6RGrbpNzp3nnHvGLfp8MieiDAAAACjIb6VJ/FnfQ/SSoQ0ySWrUqjdK2YcXPjDaLVwp2xllAAAAADrk/0r6lO8hes3QLfXYXatZ/35ptPwCk45n8yIAAABQiEskfTBN4h2+B+k1Qx9kklQaLV8t6UiT3rDQYGxeBAAAADriZklnp0nc8j1IL6I02sJo8iUyu84sOIrNiwAAAEBH3CdpKk3iH/kepFdRGYuE0WQkC242s5dbkAeZLGj/KPGPCwAAAFi2R5XH2L2+B+llQ73UY3eNWrUml50v555l8yIAAACwak9LOosY2z+eIdtNq1mfKYXrayadn7/SXu5hlj9XZlwlAwAAAPZhh/IPfr7G9yD9gCDbg1azfltptPwik45h8yIAAACwIh9Jk/gLvofoF9yyuDfOfdI59w25TMp23b4o58StiwAAAMAe/XqaxH/re4h+QpDtRaNW3SHnPuBc9oOdHxjtMjnH82QAAADAHnxG0v/yPUS/4d67/QijyVfLgpvM7GU7Ny8GgUxsXgQAAADavi7pwjSJt/sepN9whWw/GrXq/VJ2gZx7bufmxYzNiwAAAEDbDZLeT4ytDks9lqHVrNdK4fq6SZvyV9i8CAAAAEhKJL0zTeKm70H6FUG2TK1m/bul0fKoSUezeREAAADQI5JOTJO47nuQfsYtiyvh3Cecc9/atXnRsXkRAAAAw+hJSWemSfyA70H6HZd1ViiMJkdldr1Z8AYL1kkWyNrfWfIBAACAIbBdeYxd7nuQQcAVshVq1KpNOXeOc27WZfk6fLlMThlLPgAAADAMPkyMdQ5BtgqNWvU+KXu3XLadzYsAAAAYIr+SJvE/+B5ikBBkq9R4sBo7uf+y6wOjF66UOXoMAAAAg+jPJf2+7yEGDVsW16DVrG8tjZYPMuntbF4EAADAAPuSpI+kSZz5HmTQcIVsrZz7b865y9m8CAAAgAH1HUkfTJN4h+9BBhGXcDogjCbHZHaDWXAomxcBAAAwQO6QdGyaxHO+BxlUlEKHhNHkobLgRrMgtKAdY0EgE1EGAACAvlSXdHSaxDXfgwwyblnskEatmkjZe+SyHbuWfLB5EQAAAH3pcUlnEGPFY6lHB7Wa9elSWH7MpDPzV9rLPcxkMrU3fQAAAAC97DlJZ6dJfKPvQYYBQdZhpdH1VcleYbJJSWxeBAAAQL/5YJrEF/seYlgQZB3Waj6s0mj5MknHmvTqnTGWXyPjeTIAAAD0sl9Mk/ivfA8xTCiDgoTR5EEyu9EseI0F69obF9m8CAAAgJ71x2kS/6LvIYYNSz0K0qhVH5Nz5zjnHnfZwpKPTE4ZSz4AAADQa/5N0id8DzGMCLICNWrVO6XsvXJZxuZFAAAA9KirJf10msSZ70GGEc+QFazVrN9bCsuPm3R6/gqbFwEAANAzvi/p9DSJn/I9yLAiyLqgNLr+Rsk2mOwtktqbF/P1i2xeBAAAgCczkk5Kk/hR34MMM0qgS8Jo8oUyu9wsON4skNqLPswWqox/FQAAAOiahqRj0yS+3fcgw44K6KIwmnyZzG42C17F5kUAAAB48oykU9Mk/o7vQcBSj65q1Kppe/Pik2xeBAAAgAdO0geIsd5BkHVZo1b9gZS9Xy5z+eZFt9vmRQAAAKAwH0uT+Eu+h8AuLPXwoNWsJ6Ww/JRJ78pfWbR5kVsXAQAAUIzfS5P4d3wPgaW4QuaLy/7IOff3ck5LPqPMOXGpDAAAAB32j5I+6XsIPB+XYjwKo8kDZHaVWTDF5kUAAAAU5ApJZ6VJ/KzvQfB8nPF7FkaTL29vXozYvAgAAIAOu1XSCWkSP+57EOwZtyx61qhVfyTnNjnnnmLzIgAAADroAUlnEGO9jSDrAY1a9TYp+6CUic2LAAAA6IBZSaenSfyI70Gwb2xZ7BGtZv2u0mj5WZNOyV9h8yIAAABWpSXptDSJb/U9CPaPIOshpdHyZkmvNdmRkiSTrB1iRBkAAACWIZP0njSJr/A9CJaHM/weE0aTJZldbRa83YJAMjYvAgAAYNk+mibxZ3wPgeXjGbIe06hVW3LuPOeybS7LF3xo53NlEg+VAQAAYC9+mxjrPwRZD2rUqo/IuXOdc/O7Ni86Ni8CAABgb/5W0v/0PQRWjmfIelSrWX+4FK6/20wX5a/YztsWTQu3LwIAAAD6lqQPpEm8w/cgWDmCrIe1mvU7SqNlZ9JJ7Q0f7c+KZvMiAAAAJElVSWenSdzyPQhWhyDrcaXR8rWSXm/S4ZLYvAgAAIAF90k6JU3iOd+DYPU4m+8DYTT5IpldYxZMsnkRAAAAkh6VNJUm8b2+B8HacCbfJ8JocoPMbjYL1luQB5ksaP8o8a8SAABgaDwt6aQ0iW/yPQjWji2LfaJRqz7U3rzYcm7x5kXW4QMAAAyRHZIuIsYGB8+Q9ZFWs14vhevvM+nd+Svt5R5sXgQAABgW/z5N4s/7HgKdQ5D1mVaz/oPSaHmdSSeweREAAGCo/M80if/U9xDoLG5Z7EfOfco59yW5TEs+ONo5cesiAADAQPqspN/2PQQ6j8spfSqMJl8ss+vMgjexeREAAGCgfUPSBWkSb/c9CDqPs/Y+FkaTG9ubF1/B5kUAAICBdKOkk9Mkftr3ICgGtyz2sUatOiPnzpNzz7B5EQAAYODcI+lsYmywsdSjz7Wa9W2lcP0DJl2Qv8LmRQAAgAHwQ+WfNfaQ70FQLIJsALSa9e+VRsslk45l8yIAAEDfe1LSqWkS3+F7EBSPIBsQpdFyLOlNJr1+ocHa18h4ngwAAKB/bJd0bprE1/keBN3BWfoACaPJA2W22Sw4gs2LAAAAfemn0iT+B99DoHtY6jFAGrXqE3LuHOfcoy7LJJd/Z8kHAABAX/gfxNjwIcgGTKNWfVAuu0DOPbdz82LG5kUAAIAe938k/Z7vIdB9PEM2gFrNeq0Urp8x6bz8FTYvAgAA9LCvSPpwmsSZ70HQfQTZgGo167eWRssvMWmKzYsAAAA9a7Ok89Ikftb3IPCDIBtgpdHyVZIqJh26M8bYvAgAANAr7lS+3v4J34PAH87IB1wYTb5UZtebBYct3bwYEGUAAAD+1CUdnSZxzfcg8IulHgOuUas+3t68+NjSzYsZSz4AAAD8eFzSGcQYJIJsKDRq1Wkpu1DObWfzIgAAgFfPSTo/TeLv+R4EvYFnyIZEq1l/sBSWHzHpnPwVNi8CAAB48KE0ib/hewj0DoJsiLSa9VtKo+Uxk97B5kUAAICu+6U0iT/rewj0Fm5ZHDbO/ZJz7lK5TMoyOeekhe/cuggAAFCUP5H0x76HQO/hksgQCqPJUGY3mAWvs2Cd1N66yOZFAACAQnxe0vv54GfsCWfeQyqMJg+RBTeaBWMWtGMsCGQiygAAADroakmnp0n8jO9B0Ju4ZXFINWrVe6Ts3XLZjp2bFx2bFwEAADroB8o3KhJj2CuWegyxVrN+fyksP2rSWfkrbF4EAADokG2STkqT+Ee+B0FvI8iGXKtZr5ZGyy836a1sXgQAAOiIhqST0yS+z/cg6H3csgjJuV9wzl3J5kUAAIA1e0bSuWkS3+57EPQHggxq1KrPybn3OJfdkz9Lln/Pw0wiygAAAJbFSfpgmsTX+h4E/YMggySpUavOyblNzrmmyxaWfGRyyogyAACA5fmvaRJ/0fcQ6C8EGXZq1Kp3SdlFclnG5kUAAIAV+f00if+37yHQf1jqgSVazfp9pbDcMOmM/BU2LwIAAOzHP0n6L08/9gB/e40VI8jwPKXR9TdJtt5kFUlsXgQAANi7KyVdlCbxdt+DoD9xZo09CqPJF8rsMrPgBLNACtbJLJDZwlUyvnQAAMDQu03S8WkSP+57EPQvzqqxV2E0eZDMbjILJqwdZLKg/aPElw8AABhiD0o6Ok3ih30Pgv7GUg/sVaNWfUzOneOce4LNiwAAADvNSjqdGEMnEGTYp0ateoeUvW/vmxcBAACGSkvSOWkS3+V7EAwGlnpgv1rN+j2lsPykSaflryzavMitiwAAYHhkyhd4XO57EAwOggzLUhpdf4NkkcneLKm9eTEPMaIMAAAMif+UJvE/+h4Cg4WzaCxbGE0eILMrzIJj2bwIAACGzP9Kk/jXfA+BwcMzZFi2Rq36jJy70LnswYUFH3KZnHMs+QAAAIPs7yT9uu8hMJi4pIEVC6PJI2TBFrPgJRa01+AHgUyswwcAAAPn25I2pUn8nO9BMJi4QoYVa9Sq35eyD8hlzu28QsbmRQAAMHC2SnoPMYYisdQDq9Jq1u8uheWWSe/MX2HzIgAAGCjTkk5Jk3jO9yAYbAQZVq00un6LZBMmO0oSmxcBAMCgSCWdlCZxzfcgGHycMWNNwmiyJLPYLHiHBYFkbF4EAAB97WnlMXaT70EwHHiGDGvSqFVbcu5857IZl7F5EQAA9LUdyj/4mRhD1xBkWLNGrfqInNvknHvaZZnylfhOThlRBgAA+slH0yT+pu8hMFwIMnREo1a9Vco+JOVBtivK2LwIAAD6wm+kSfzXvofA8GGpBzqm1azfWRotbzfpZEn5xsWFH1nyAQAAetdfSfrE04894HsODCGCDB1VGi1fJ+lQkx0hic2LAACg110s6afSJM58D4LhxNkxOi6MJkdkdo1Z8FY2LwIAgB52o/LPGnvK9yAYXpwZoxBhNFmW2U1mwQYL8iCTBe0fJb70AACAZ/dIOiZN4kd9D4LhxlIPFKJRq9bl3LnOufk9L/lg0wcAAPDmh5JOJ8bQC3iGDIVpNesPl8L195j0nvyV9nIPs/y5MuMqGQAA6LonJZ2aJvEdvgcBJIIMBWs167eXRstm0ontDR9sXgQAAL5sl3RumsTX+R4EWECQoXCl0fK1kt5o0mGS2LwIAAB8+dk0ib/sewhgMZ4hQ+EatWom537auewWuUxa9EyZnBPPkwEAgC74ZJrEn/M9BLA7ggxd0ahVn86XfGSPuCyPsjzMWPIBAAAK9/9L+l3fQwB7wr1i6Kowmny7LLjGguCA/LPJ1klB0F7yIfElCQAAOuyrkt6dJvEO34MAe8IzZOiqVrP+UClcP23ShfkrbF4EAACF2SzpvDSJn/U9CLA3BBm6rtWsf780Wn6hScexeREAABTkLuXr7Z/wPQiwLwQZvCiNlq+WdJRJr19oMDYvAgCADnlY0klpEj/iexBgfzjrhTdhNPkSmV1nFhxlQSDZOuXPlS3cusiXJwAAWLEnJB2XJvFtvgcBloMti/CmUas+Kec2Oed+xOZFAADQAc9JOp8YQz8hyOBVo1atyWXny7ln3aLPJ3MiygAAwIr9TJrEV/oeAlgJniGDd61mfaYUrq+ZdH7+CpsXAQDAin0iTeLP+B4CWCmCDD2h1azfVhotv8ikY9i8CAAAVuhPJH3q6cce8D0HsGIEGXpGabQcS3qLSYcu3ry4q8eIMgAA8Dyfl/Qf0iTmOQf0Jc5w0VPCaPJAmW0xCw5funkxIMoAAMDurpF0eprELd+DAKvF2S16ThhNvloW3GRmL7MgDzIFgUxEGQAA2Ol2ScemSdzwPQiwFmxZRM9p1Kr3S9kFcu65nZsXMzYvAgCAnbYpvzJGjKHv8QwZelKrWa+VwvV1kzblr7B5EQAASJKakk5Jk/he34MAnUCQoWe1mvXvlkbLoyYdzeZFAAAg6VlJZ6VJfLPvQYBO4ZZF9DbnPuGc+7ZcJmWZnHPSwnduXQQAYJg4SR9Mk/ga34MAnUSQoac1atUdcu59zmV3OpdJ7WfK8jCTiDIAAIbGL6RJ/AXfQwCdRpCh5zVq1aac2+Scm3VZHmVymZwyogwAgOHwB2kS/5nvIYAiEGToC41a9V4pe7dctp3NiwAADJV/lvQrvocAisJSD/SNVrP+QCks/8iks/NX2LwIAMCAu1LSRWkSb/c9CFAUggx9pdWsby2Nlg8y6e1sXgQAYKDdpvyzxp72PQhQJG5ZRP9x7r855y5n8yIAAAPrQUlnpkn8uO9BgKJxOQF9KYwmx2R2g1lwqAXrJAtk7e/iShkAAP1sVtIxaRLf5XsQoBu4Qoa+1KhV5+TcOc65BpsXAQAYGC1Jm4gxDBOCDH2rUasmUnaRXLZj5+ZFx+ZFAAD6VCbp/WkSb/Y9CNBNLPVAX2s169OlsDxr0pn5K2xeBACgT/3nNIn/0fcQQLcRZOh7pdH1N0v2CpNNSmLzIgAA/ed30iT+Pd9DAD5wyyL6XqO21cm5jzmXxWxeBACg7/y9pF/zPQTgC5cOMDDCaPIgmd1oFrzGgnXtjYtsXgQAoIddKumcNImf8z0I4AtnqBgoYTT5Bllwg1nwUgvaMRYEMhFlAAD0mK2STkyT+EnfgwA+ccsiBkqjVr1Tyt4rl2VsXgQAoGfdL+ksYgxgqQcGUKtZv7cUlh836fT8FTYvAgDQQ1JJJ6VJXPM9CNALCDIMpNLo+hslO9hkb5HU3ryYr19k8yIAAN7MSzotTeLv+R4E6BWclWJghdHkC2V2uVlwfP4sWb7ow2yhyvjyBwCgi3ZIOi9N4ot9DwL0Ep4hw8Bq1KrPyrkLncseyJ8ly7/nK/ElnicDAKCrPkqMAc9HkGGgNWrVVM6d45x70mULSz4yOWVEGQAA3fOpNIn/2vcQQC8iyDDwGrXqD6Ts/XKZc27Xh0bv2rwIAAAK9NeSfsv3EECvYqkHhkKrWU9KYflpk07NX1m0eZElHwAAFOWbkj6UJnHmexCgVxFkGBql0fXXS/Yqk71J0q7Ni2LzIgAABbhJ0jlpEj/jexCgl3EGiqESRpMHyOwqs2CKzYsAABTmHknHpEn8qO9BgF7H2SeGThhNvlxmN5sFkbWDTBa0f5T4YwEAwJr8SNLRaRJP+x4E6Acs9cDQadSqP5Jzm5xzT7F5EQCAjnpK0pnEGLB8BBmGUqNWvU3KPijlQcbmRQAA1my7pHenSbzV9yBAP2GpB4ZWq1m/qzRaftakU/JX2LwIAMAafDhN4i/5HgLoNwQZhlpptLxZ0mtNdqQkNi8CALA6v5om8Z/7HgLoR9yyiKHWqFWdnPuIc9lNWniWzGVS+xZG7l8EAGC//kLSp30PAfQr/vofkBRGk+tldpNZcDCbFwEAWLavKn9ubIfvQYB+xVkm0BZGk2+RBdeZBSMWBDJbJwUmE1EGAMAebJH0zjSJ530PAvQzniED2lrN+sOlcP3dZroof8V2fmC0aeGDowEAgKS7JJ2aJvHjvgcB+h1BBizSatbvKI2WnUkntTd8tC+OsXkRAIC2hyWdlCbxw74HAQYBQQbspjRavlbS6006XBKbFwEA2OUJ5bcp3u17EGBQcGYJ7EEYTb5IZteYBZMWBJLliz4WbmHkjw4AYAg9J+mMNImv9D0IMEhYew/sQaNWfVrOnedc9rDL8nX4+Up8196Ezzp8AMDQ+RliDOg8ggzYi0at+pCcO9c513KLPp/MiSgDAAydT6RJ/M++hwAGEUEG7EOjVr1Zyn524QOj3cKVsp1RBgDAwPtTSX/kewhgULHUA9iPVrP+g9Jo+cdMOp7NiwCAIfMFSf8+TWL+GhIoCEEGLENptHyNpMNNOkwSmxcBAMPgWkkXpkn8nO9BgEHGWSSwTGE0+WKZXWcWvInNiwCAAXe7pOPSJJ7zPQgw6DiDBFYgjCY3yuxms+AVFuRBJgvaP0r8kQIADICHJB2dJvGM70GAYcBSD2AFGrXqjJw7T849w+ZFAMAAako6nRgDuodnyIAVajXr20rh+gdMuiB/pb3cwyx/rsy4SgYA6EvPSjorTeKbfQ8CDBOCDFiFVrP+vdJouWTSsWxeBAAMACfpA2kSX+J7EGDYcMsisFrO/apz7utymZTtun1RzolbFwEAfebjaRJ/3vcQwDDir/GBNQijyQNlttksOILNiwCAPvWHaRJ/wvcQwLDiChmwBo1a9Qk5d45z7lGXZZLLv7PkAwDQJ/5F0i/7HgIYZvz1PdABYTR5rFlwlYLgBfkVsnVSELSXfEj8UQMA9KCrJJ2ZJvEzvgcBhhlLPYAOaDXrtVK4fsak8/JX2LwIAOhptylfb/+070GAYUeQAR3SatZvLY2WDzRpis2LAIAeVpN0cprEqe9BAPAMGdBZzv2yc+6SXZsXHZsXAQC9ZE75lbG670EA5Pgre6DDwmjypTK73iw4bOnmxYDnyQAAPrUkvTNN4s2+BwGwC1fIgA5r1KqPtzcvPrZ082LG5kUAgC9O0k8SY0DvIciAAjRq1Wkpu1DObXeu/aHRmWMdPgDAl59Pk/grvocA8Hws9QAK0mrWHyyF5UdMOid/hc2LAAAvPp0m8e/6HgLAnhFkQIFazfotpdHymEnvYPMiAMCDz0n62NOPPeB7DgB7wS2LQNGc+yXn3KVsXgQAdNmlkj6SJjH/ZwP0MP56HuiCMJoMZXaDWfA6C9ZJ7a2LbF4EABTkFkknpkn8hO9BAOwbZ4FAl4TR5CGy4EazYMyCdowFgUxEGQCgo+6XNJUm8SO+BwGwf9yyCHRJo1a9R8reLZft2Ll50bF5EQDQUY8p/+BnYgzoEyz1ALqo1azfXwrLj5p0Vv4KmxcBAB0zL+ldaRJ/z/cgAJaPIAO6rNWsV0uj5Zeb9FY2LwIAOiSTdGGaxLHvQQCsDLcsAj449wvOuSvZvAgA6JCPpkl8se8hAKwcQQZ40KhVn5NzFzmX3Zs/S5Z/z8NMIsoAACvwm2kS/5XvIQCsDkEGeNKoVWfl3DnOuabLFpZ8ZHLKiDIAwHL9jaTf9D0EgNUjyACPGrXqXVJ2kVyWsXkRALBClyi/VZH/swD6GEs9AM9azfp9pbDcMOmM/BU2LwIA9utmSWenSfyM70EArA1BBvSA0uj6myRbb7KKJDYvAgD25V5Jp6RJ3PA9CIC14ywP6BFhNPlCmV1mFpxgFkjBOpkFMlu4SsYfVwCAfiRpKk3i+3wPAqAzOMMDekgYTR4ks5vMgglrB5ksaP8o8UcWwP9r796j5rjr+45/vqMEhgDZjUkIz8JZaKDggKkDXQjGxvgCxjaWLF/ANiU4pJC0nKaBXCANTZMCLTkJJW0TSpM2IaElBNokkJ6AccDjC8i3tR1sfBvfxMhaXxjZs7YsrW7z7R+zzyPZSLb0aHd/Ozvv1+Gxzpk/pM8/7O7nmfl9Fo32mKQT8jTphw4CYHIY9QDmSJH1t8h9nbs/yvIiAGAfeySdSxkDFg+FDJgzRda/WSrPl5e+/+VFAEADvSdPk4tChwAweYx6AHNoNBzcEbc7W006pbqyz/Iijy4CQNP82zxN/iB0CADTwR0yYF55+Ul3/4zc9bg7Ze7iVhkANMZ/l/QfQ4cAMD38mh2YY+1u7+ky+7pZdBzLiwDQOF9SdW5sT+ggAKaHT3PAnGt3e88dLy++kOVFAGiMDZLelKfJ9tBBAEwXn+SAGmh3e6+URRvMomdZNC5jUSQTpQwAFtDtko7N02RL6CAApo8zZEANFFn/Jqn8Z3uXF53lRQBYTPdLOpUyBjQHK4tATYyGg9vjdmdk0puqKywvAsCCeVTVY4q3hQ4CYHYoZECNxK2lDZL9hMmOliSZZOMiRikDgFrbLWldniYbQgcBMFt8egNqpt3txTJLzKLXWRRJxvIiACyAd+Zp8rnQIQDMHmfIgJopsv5I7me5l5u8LCWvfqpzZRKHygCgdj5IGQOai0IG1FCR9e+X+zp33+blPl8arZJSBgD18l8lfSJ0CADhcIYMqKnRcHB/3F66zUznVVds5bFF0/LjiwCAOfZ/Jb03T5MydBAA4VDIgBobDQe3xq3OHpNOkjQuY2J5EQDm3xWSzs7TZFfoIADCopABNRe3OldIepnJjpLE8iIAzL9bJJ2Sp8nW0EEAhMcnNWABtLu9Z8jsMrPoNSwvAsBc2yzpmDxNNoUOAmA+8CkNWBDtbq8js2vMoudbVBUyWTT+U+L/7gAQ3FDSG/I0uSl0EADzg5VFYEEUWX8g9zPdfbv7vsuLzOEDwBzYKWk9ZQzAE3GGDFggo+Hgvri9dIdJb6uujMc9WF4EgNDekafJ34UOAWD+UMiABTMaDm6OWx0z6YTxwgfLiwAQ1gfyNPmT0CEAzCcKGbCA4lbnckmvMOnlklheBIBw/lOeJh8JHQLA/OIMGbCAiqxfyv1C9/J6eSntc6ZM7uI8GQDMxF9K+mDoEADmG78mBxZYu9t7gcyuNYuex/IiAMxUIum0PE12hA4CYL5xhwxYYEXWv1fu6919B8uLADAzN0o6izIG4GBwhgxYcKPhYHPcXrrbpHOqKywvAsAUZZJOzNMkDx0EQD1QyIAGGA0HN8WtztNMegPLiwAwNQ9LOilPk3tCBwFQHxQyoCHiVudSSUebdORyB2N5EQAmZoeqM2PXmOifrwAAGihJREFUhw4CoF74BAY0SLvbe5bMvmkWHW1RJFk19GG2/OgiLwkAsAou6dw8Tf46dBAA9cOoB9AgRdbfKvd17v6gl9Ucvrxk5AMADs8vUsYArBaFDGiYIutn8vIsue9cWV4sWV4EgFX6eJ4mnwodAkB9UciABiqy/gZX+d7lL4z277tTBgA4CJ+V9OHQIQDUG6MeQEONhoNvx63OD5l0LMuLAHDILpZ0fp4me0IHAVBvFDKgweJWJ5H0apNeuu/y4t4+RikDgP24QdLpeZpsDx0EQP3xaQtouHa392yZbTCLjnr88mJEKQOA77dR0jF5mtwfOgiAxcAZMqDhiqz/6Hh5MX/88mLJyAcAPN4WSadSxgBMEoUMgIqsf49Uni33XSwvAsB+bZd0Rp4mt4cOAmCxcIYMgCRpNBxkcbszMGlddWU87mHjU2XGo4sAGqtU9cXPl4QOAmDxUMgArBgNBzfErU7LpGNYXgSAFf8iT5PPhw4BYDHxyCKAx3P/NXe/SF5KZSl3l5Z/eHQRQPN8JE+TPw4dAsDiopABeJwi6++R+/nu5a0rXxjty8VMopQBaJA/lfTboUMAWGw8fwRgv9rd3ktk0dVm0REWjWfwo0gm5vABNMJXJK3P02RX6CAAFht3yADsV5H175TKc+XlbpYXATTMtZLeThkDMAuMegA4oNFwsDFudx406YzqCsuLABbenZLelKdJEToIgGagkAF4UqPh4Lq41XmOST/N8iKABfc9SSfmaXJv6CAAmoNHFgE8Nfdfdve/Z3kRwAJ7TNLpeZrcFToIgGbhV9sADkq72/sRmV1lFr3UojWSVUMfZox8AKi9PZLW5mny1dBBADQPd8gAHJQi6z8s97XuXnhZzeHLS7lKRj4A1N17KWMAQqGQAThoRdZPpfJt8nLPyvKis7wIoNZ+M0+Tz4QOAaC5GPUAcEhGw8HdcbuzxaTTqyssLwKorT+S9KFtWzaGzgGgwShkAA5Z3FrqS/bjJutJYnkRQB19WdKFeZqUoYMAaDY+NQFYlXa394My+5pZdKJZJEVrxiMfy3fJeHkBMLeuVPVdY9tCBwEAPjEBWLV2t/ccmV1tFr3YxoVMLC8CmG+3Szo2T5MtoYMAgMSoB4DDUGT9LePlxUe8XB75YHkRwNy6X9KplDEA84RCBuCwFFn/Vqk8T16WLC8CmGNbVX3x88bQQQBgX4x6ADhso+HgzrjdecSkU6srLC8CmCu7Ja3L0+RboYMAwBNRyABMRNxaulqyF5js1ZLGy4vV/CLLiwACuzBPky+FDgEA+0MhAzARo+F9iludiyS90aQXrszgV7WMkQ8AoXwoT5NPhw4BAAfCGTIAE1Nk/Z1yP8e93Lg88CEv5c55MgBB/IGk3wsdAgCeDL+uBjBx7W7vKFl0pVn0LIvGM/hRJBNz+ABm5q8knZenyZ7QQQDgyXCHDMDEFVn/O1J5gbx0X7lDtu/yIgBM1RWS3kkZA1AHnCEDMBWj4SCN251tJr25urLP8iJ3yQBMzy2STsnTZGvoIABwMChkAKYmbi1dKdmLTPZTkvYuL4rlRQBTsVnSSXmaPBA6CAAcLD4NAZiqdrf3dJldYha93qJIsjUyi2S2vIfPyxCAiXhE0nF5mtwUOggAHArOkAGYqiLr75D7We5l5iXLiwCmYqek9ZQxAHVEIQMwdUXWf1Du69z9MS9LLU/iu0pKGYBJeFeeJknoEACwGhQyADNRZP1vS+U7paqQsbwIYEJ+OU+TL4QOAQCrxagHgJkZDQe3xa3OTpNOrq6wvAjgsHwyT5N/HzoEABwO7pABmC3333H3z8l9fKesrO6UuYtbZQAOwRck/VroEABwuPh1NICZa3d7scwuM4tey/IigFVIJJ2Wp8mO0EEA4HDxqQdAEO1ub0lm15hFL7CoKmSyaPynxMsTgAO4SdIb8jQZhg4CAJPAI4sAgiiy/n1yP9Pdt+9dXnSWFwE8mU2q7oxRxgAsDAoZgGCKrH+9VL5r7/JiyfIigAMpJJ2ap8nm0EEAYJJYWQQQ1Gg4uCVuddykEyVb/h/LiwD2tUPS6XmaXBc6CABMGoUMQHBxq3O5pCNNOkrSuJRVRYxSBjSeSzo/T5OLQgcBgGngkUUAwRVZ3+X+c+5lX15K+zy+KObwgab713ma/FXoEAAwLRQyAHOhyPrb5L7evbzPy6qUVcXMGfkAmut38jT5w9AhAGCaKGQA5kaR9TePlxdH+x/5oJQBDfK/JP1G6BAAMG2cIQMwV0bDwSBuL91l0rnVlfG4h1l1rsw4TwY0wN+rOje2J3QQAJg2ChmAuTMaDr4Ttzo/YNLxLC8CjXODqu8a2x46CADMAoUMwFyKW53LJB1l0sslsbwINMNGSSflafJQ6CAAMCt8ogEwt9rd3jNl9k2z6KcsiiRbI7NIZsuPLvISBiyQhyS9Pk+T20MHAYBZYtQDwNwqsv5jcl/nXj7A8iKw0LZLOoMyBqCJKGQA5lqR9TfJfb3cd7C8CCykUtWAx5WhgwBACJwhAzD3RsPBvXF7aaNJZ1dXWF4EFsi/zNPkL0KHAIBQKGQAamE0HNwYtzqxScexvAgsjI/mafKJ0CEAICQeWQRQH+4fdve/lZdSuffxRbmLRxeB2vmMpN8KHQIAQuNXygBqpd3tPVtm3zKLXsnyIlBbX5V0Zp4mu0IHAYDQ+OQCoHba3d6LZNE1ZvZjFlWFTFEkU7T8HGPoiAAOrC/pxDxNtoYOAgDzgEcWAdROkfU3ysuz5b5rZXmxZHkRqIG7JL2VMgYAezHqAaCWRsNBFreXNpm0vrrC8iIw576n6s7YptBBAGCeUMgA1NZoOPiHuNV5tkmvZ3kRmGvbJJ2Sp8l3QgcBgHnDI4sA6s39Q+7+lb3Li87yIjBf9kh6W54m14YOAgDziEIGoNaKrL9H7he4l7dUM/h7VJ0r4zwZMCd+Pk+Tr4QOAQDzikIGoPaKrP+I3Ne6+xYvS8mrH1dJKQPC+nd5mvxp6BAAMM8oZAAWQpH175bKc+W+m+VFYC78saSPhQ4BAPOOUQ8AC2M0HGyM2537TVpbXWF5EQjkbyVdmKdJGToIAMw7ChmAhTIaDq6PW50fMel1LC8CQVwlaV2eJjtCBwGAOuCRRQCLx/1X3f1rLC8CM5dKWpunybbQQQCgLvhVMYCF1O722jK7yix6mUVrJItk4x9xpwyYhgckHZOnyT2hgwBAnXCHDMBCKrJ+MV5efJjlRWDqtko6nTIGAIeOQgZgYRVZ/w6pfJu83LOyvOgsLwITtlvSOXmaXB86CADUEaMeABbaaDi4J253cpPeWl1heRGYsJ/N0+RvQocAgLqikAFYeKPh4Nq41XmuSa9heRGYqF/P0+S/hQ4BAHXGI4sAmsH9/e7+DZYXgYn5Q0m/GzoEANQdvxYG0Bjtbu8ImV1tFr3EojXjxUWWF4FV+GtJb8/TZE/oIABQd3z6ANAo7W7vSFl0lVnUsmhcxqJIJkoZcJC+KemUPE22hw4CAIuARxYBNEqR9W+TyrfLy5LlReCQ3SrpTMoYAEwOox4AGmc0HNwVtzuFSadVV1heBA7CQNKJeZrcHzoIACwSChmARopbS9dI1jHZP5XE8iLw5B6RdHKeJmnoIACwaPjEAaCx2t3e02R2sVn0xuosWTX0YbZ8l4yXSEDSLklvydMkCR0EABYRZ8gANFaR9XfK/Vz38u7qLFn1U03iS5wnAyRJ76KMAcD0UMgANFqR9XO5r3P3R71cHvko5SopZYD0K3ma/GXoEACwyChkABqvyPo3S+X58tL3v7wINNLv52nyydAhAGDRMeoBAJJGw8Edcbuz1aRTqiv7LC8y8oHm+aKkX9i2ZSO/kgCAKaOQAcBY3Fq6SrKuyV4laby8WBUxShka5FJJ5+Rpsjt0EABoAj5dAMA+2t3e02X2dbPoOJYX0UA3STo+T5MidBAAaAo+WQDAE7S7vefK7Bqz6IU2LmSyaPynxEsnFtQmScfkabI5dBAAaBJGPQDgCYqs/+B4efExlhfREIWk0yhjADB7FDIA2I8i698ole/Yu7zoLC9iUe2QtC5Pk5tDBwGAJmLUAwAOYDQc3B63OyOT3lRdYXkRC8clXZCnyUWhgwBAU1HIAOBJxK2lDZL9hMmOlsTyIhbNL+Vp8mehQwBAk/FJAgCeQrvbi2WWmEWvsyiSjOVFLITfzdPkQ6FDAEDTcYYMAJ5CkfVHcj/LvdzkZTXwoZVzZRKHylBD/1vSvwkdAgDAr3UB4KC1u71XyaJvmkU/ZFEkszVSZDIxh49a+bqkt+ZpsjN0EAAAZ8gA4KCNhoP74/bSbWY6r7piK48tmpYfXwTm2j+omrffFjoIAKBCIQOAQzAaDm6NW509Jp0kaVzGxPIi6uC7kk7K02RL6CAAgL0oZABwiOJW5wpJLzPZUZJYXkQdPKSqjG0MHQQA8Hh8agCAVWh3e8+Q2WVm0WtYXsScG0k6OU+TDaGDAAC+HyuLALAKRdbfLvf17uWA5UXMsVLS+ZQxAJhfFDIAWKUi6w/kfqa7b3cv5V5K7nJRyjA33penyZdDhwAAHBiFDAAOQ5H1+1L5sxoXMl++U7ZSyoBgPpanyR+FDgEAeHKMegDAYRoNBzfHrU5k0hvHCx8sLyK0P5P0/m1bNgaOAQB4KhQyAJiAuNW5XNIrTHq5JJYXEdJFkt6Rp8me0EEAAE+NTwgAMCHtbu+ZMrvCLHoVy4sI5DpJJ+RpsjV0EADAweHTAQBMULvbe4HMrjWLnmdRVchk0fhPiZddTNFdko7N0+SB0EEAAAePUQ8AmKAi699bzeH7DpYXMUPfk3QqZQwA6oczZAAwYaPhYHPcXrrbpHOqK+NxD7PqXJlxlwwTtU3SW/I0uSl0EADAoaOQAcAUjIaDm+JW52kmvYHlRUzRHknn5GlyaeggAIDVoZABwJTErc6lko426cjlDsbyIibs5/M0+ULoEACA1eMMGQBMSZH1S7n/jHt548oXRo/PlMldnCfDYfqtPE3+JHQIAMDhoZABwBQVWX+r3Ne5+4NeVqWsKmaMfOCw/A9JHw0dAgBw+HheBgBmoN3tvd4sShRFT6u+m2yNFEXjkQ+Jl2Mcgv8n6ew8TXaHDgIAOHycIQOAGRgNB5vi9tImk9ZXV1hexKpcLWltniY7QgcBAEwGhQwAZmQ0HHw7bnWeadKxLC9iFe6QdHKeJsPQQQAAk0MhA4AZiludSyS92qSX7ru8uLePUcqwXw9IOjFPk82hgwAAJot3fgCYsXa398My22AWvcKiSLI1qs6VRZQy7M9jkt6Yp8l1oYMAACaPlUUAmLEi6z8i97XuvuVxy4sqWV7EE+1WNeBBGQOABUUhA4AAiqx/j1SeLfddvvz9ZKXLxRw+Huef52lycegQAIDp4QwZAAQyGg6+G7c7A5PWVVdYXsTj/EaeJp8KHQIAMF0UMgAIaDQc3BC3Om2TXsfyIvbxKUkf3rZlY+gcAIApo5ABQGBxq/MNSa816SUrZYzlxSb7G0k/l6dJGToIAGD6eJcHgDnQ7vZaMrvKLDrSojXSeHWR5cXG+ZakN+dpsj10EADAbPAODwBzot3tvUQWXW0WHWHRuIxFkUyUsoa4TdKxeZo8FDoIAGB2WFkEgDlRZP07pfJcebmb5cXGuU/SqZQxAGgezpABwBwZDQcb43bneyadUV1hebEBHpV0cp4mt4cOAgCYPQoZAMyZ0XDQj1udHzXptSwvLrxdks7I0+Sq0EEAAGHwyCIAzCP3D7j71+WlVJZyd2n5h0cXF8mFeZpcEjoEACAcChkAzKEi6++W+9vdyzvcS2l8pqwqZhKlbCH8ap4mnw8dAgAQFoUMAOZUkfUflvtady+8rEqZvJSrpJTV33+W9MnQIQAA4XEQAQDmXPuFvTeboq8qitaYRVr5nrK9h8tCR8Sh+aKkC/jiZwCAxKgHAMy90XBwd9zuPGTS6dUVlhdr7DJJ5+Zpsit0EADAfKCQAUANxK2layV7nsl6klherKebJZ2Sp8nW0EEAAPODd3AAqIl2t/eDMrvYLDrBLJKiNTKLZLZ8l4yX9Dl2r6Rj8jS5N3QQAMB84d0bAGqk3e09R2ZXm0UvtnEhk0XjPyVe1udSIem4PE1uDh0EADB/WFkEgBopsv6W8fLiI15WU/gsL861nZLOpIwBAA6EQgYANVNk/Vul8nx5WbovlzKXi+8omzMu6Z15mlweOggAYH4x6gEANTQaDu6M251HTXpLdYXlxTn0/jxNPhM6BABgvlHIAKCm4tbS1ZK9wGSvljReXqzmF1leDO738jT5WOgQAID5xyOLAFBTRXady/197uUV8lIq9z6+KHfx6GIwfyHp10OHAADUA78+BYCaa3d7Pyaza8yiF7G8GNw3JJ2ep8nO0EEAAPXAuzQALIB2t3eULLrSLHqWReMyFkUyUcpm6NuSjs/T5JHQQQAA9cEjiwCwAIqs/x2pfIe89Gp50Z+wvIgp+66qO2OUMQDAIWHUAwAWxGg4SON2Z7tJb66u7LO8yF2yaXpI0kl5mtwTOggAoH4oZACwQOLW0gbJ/pHJjpa0d3lRLC9OyUjSaXma3BA6CACgnnhnBoAF0+72ni6zxCw6xqJIsmrow2x5D5+X/gkpJZ2Tp8mXQgcBANQXZ8gAYMEUWX+H3M9yLzMvS8mrn+pcmcShson5V5QxAMDhopABwAIqsv4Dcl/n7tt85fvJSrlKStlk/Ic8TT4dOgQAoP4oZACwoIqs/22pfKdUFTKWFyfmzyX9ZugQAIDFwKgHACyw0XBwW9zq7DLp5OoKy4uH6WuSLsjTZE/oIACAxUAhA4AFF7c635T0j032SkksL67edaq+a2wUOggAYHHwLgwADdDu9p4hs0vNoteyvLgq90g6Jk+TB0IHAQAsFt6BAaAh2t3eksyuNYueb1FVyGTR+E+Jt4QDyiW9Pk+TO0IHAQAsHkY9AKAhiqx/33h5cfve5UVnefHJbZN0BmUMADAtFDIAaJAi618vlRfuXV4sWV48sD2S3p6nydWhgwAAFhejHgDQMKPh4Ja41ZFJJ4wXPsZPLLK8+AS/kKfJF0KHAAAsNgoZADRQ3OpcLuknTXqFJJYXv99v52ny+6FDAAAWH48sAkADFVnf5f5u9/I6eSnt8/ii3NXw5xf/p6SPhA4BAGiGxv8KFACarN3tPX+8vLjE8qIk6e8krc/TZHfoIACAZuAOGQA0WJH1N8t9vbuP9j/y0ag7ZddIOo8yBgCYJc6QAUDDjYaDzXF76W6TzqmujMc9zKpzZdaIu2R3SHpTniZF6CAAgGahkAEANBoOvhO3Oj9g0vENXF58UNKJeZpsDh0EANA8FDIAgCQpbnUuk/RPTPpJSU1ZXnxM0pvzNLkldBAAQDMt5LsrAGB12t3eM2X2LbPoaIsiyaqhD7PlRxcX6m1jt6S1eZpcFDoIAKC5GPUAAKwosv5jcl/n7g94Wc3hV5P4Czny8R7KGAAgNAoZAOBxiqyfycuz5L5zgZcXP5ynyZ+HDgEAAIUMAPB9iqx/pat8z/IXRvvynbKVUlZrn5b08dAhAACQGPUAABzAaDi4MW51nmHScQu0vPglSe/O06QMHQQAAIlCBgB4EnGrk0h6lUkvW+5gtry9WL9StkHSmXma7AwdBACAZbV6JwUAzF6723v2eHnxlTVeXrxN0nF5mmwJHQQAgH3V4l0UABBWu9t7kSy61sx+1KKqkCmKZIrqcKfsPknH5Gny3dBBAAB4IkY9AABPqcj6G6XyLLnvWhn5KGuxvPiopNMpYwCAecUZMgDAQRkNB1ncXtps0pnVlfG4h41Pldnc3SXbpeqLn68MHQQAgAOhkAEADtpoOLghbnV+2KRjarC8eGGeJl8OHQIAgCfDI4sAgEPj/kF3/6q8lMpS7i4t/8zPo4sfzNPkc6FDAADwVChkAIBDUmT9PXK/wL28deULo325mElzUMr+i6RPhA4BAMDBmKtnSwAA9dHu9l4si64xsyPmaHnx/0g6ny9+BgDUBXfIAACrUmT9u6TyHLnvnpPlxcslvYsyBgCoE0Y9AACrNhoONsbtzgMmra2uBFtevFnSW/I02TqrfxAAgEmgkAEADstoOLgubnWOMOmnAy0vbpZ0Yp4mD0z7HwIAYNJ4ZBEAcPjcf8XdLw6wvDiUdFqeJpum+Y8AADAtjHoAACai3e21ZXa1WfRSi9ZIFsnGP1Ma+dip6jHFSyf9FwMAMCvcIQMATESR9Qu5r3X3wstqDl9eylVOY+TDJf0MZQwAUHcUMgDAxBRZP5XKt8nLPSvLiz6V5cUP5GnyxUn9ZQAAhMKoBwBgokbDwd1xu7PFpNOrKxNfXvxEniYfPdy/BACAeUAhAwBM3Gg4uDZudX7cZK+RNMnlxc9Let+2LRtn/iVnAABMA48sAgCmw/2X3MtLJri8eImkd/PFzwCARcLKIgBgatrd3hHj5cWXWLRmvLi4quXFGyUdn6fJcGphAQAIgEIGAJiqdrd3pCy6yixqWTQuY1Ek00GXskzSMXmaDKYeFgCAGeORRQDAVBVZ/zapPF9elqtYXnxY0qmUMQDAomLUAwAwdaPh4M643RmadGp15aCWF0eSTsvT5PrZJQUAYLYoZACAmYhbS9dI9nyTvVrSUy0vuqTz8jS5eNY5AQCYJQoZAGAmRsP7FLc6X5N0vEkvWilj1T2yJ54n+8U8TT4bJCgAADPEGTIAwMwUWX+n3M91L++pzpJVP9UkvjT+z8fzNPlU2KQAAMwGhQwAMFNF1s/lvtbdH/VyeeSjlKuUXJ+V/MOhMwIAMCsUMgDAzBVZ/2apvEBe+j7Lixe7/D15eumqvjUaAIA64gwZACCI0XBwR9zuPGbSKZKul+z0h+66YnvoXAAAzBKFDAAQTNxaulKyNSZ7/8P3XPlQ6DwAAMza/wd/vWlpamWj9AAAAABJRU5ErkJggg=="/>
        <image id="_Image2" width="1045px" height="842px" xlink:href="data:image/png;base64,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"/>
    </defs>
</svg>
````

## File: docs/README.md
````markdown
<p align="center">
  <img src="logo.svg" width="200px" align="center" />
  <h1 align="center">Zod</h1>
</p>
<p align="center">
<a href="https://github.com/edgedb/edgedb-js/actions"><img src="https://github.com/colinhacks/zod/actions/workflows/test.yml/badge.svg?event=push&branch=master" alt="Zod CI status" /></a>
<a href="https://twitter.com/colinhacks" rel="nofollow"><img src="https://img.shields.io/badge/created%20by-@colinhacks-4BBAAB.svg" alt="Created by Colin McDonnell"></a>
<a href="https://opensource.org/licenses/MIT" rel="nofollow"><img src="https://img.shields.io/github/license/colinhacks/zod" alt="License"></a>
<a href="https://www.npmjs.com/package/zod" rel="nofollow"><img src="https://img.shields.io/npm/dw/zod.svg" alt="npm"></a>
<a href="https://www.npmjs.com/package/zod" rel="nofollow"><img src="https://img.shields.io/github/stars/colinhacks/zod" alt="stars"></a>
<a href="https://discord.gg/KaSRdyX2vc" rel="nofollow"><img src="https://img.shields.io/discord/893487829802418277?label=Discord&logo=discord&logoColor=white" alt="discord server"></a>
</p>

<div align="center">
  <a href="https://discord.gg/RcG33DQJdf">Discord</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://www.npmjs.com/package/zod">NPM</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://github.com/colinhacks/zod/issues/new">Issues</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://twitter.com/colinhacks">@colinhacks</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://trpc.io">tRPC</a>
  <br />
</div>

<br/>

These docs have been translated into [Chinese](./README_ZH.md).

## Table of contents

<!-- The full documentation is available both on the [official documentation site](https://zod.js.org/) (recommended) and in `README.md`.

### Go to [zod.js.org](https://zod.js.org) >> -->

- [What is Zod](#what-is-zod)
- [Installation](#installation)
- [Ecosystem](#ecosystem)
- [Basic usage](#basic-usage)
- [Defining schemas](#defining-schemas)
  - [Primitives](#primitives)
  - [Literals](#literals)
  - [Strings](#strings)
  - [Numbers](#numbers)
  - [NaNs](#nans)
  - [Booleans](#booleans)
  - [Dates](#dates)
  - [Zod enums](#zod-enums)
  - [Native enums](#native-enums)
  - [Optionals](#optionals)
  - [Nullables](#nullables)
  - [Objects](#objects)
    - [.shape](#shape)
    - [.extend](#extend)
    - [.merge](#merge)
    - [.pick/.omit](#pickomit)
    - [.partial](#partial)
    - [.deepPartial](#deepPartial)
    - [.passthrough](#passthrough)
    - [.strict](#strict)
    - [.strip](#strip)
    - [.catchall](#catchall)
  - [Arrays](#arrays)
    - [.element](#element)
    - [.nonempty](#nonempty)
    - [.min/.max/.length](#minmaxlength)
  - [Tuples](#tuples)
  - [Records](#records)
  - [Maps](#maps)
  - [Sets](#sets)
  - [Unions](#unions)
    - [Discriminated Unions](#discriminated-unions)
  - [Recursive types](#recursive-types)
    - [JSON type](#json-type)
    - [Cyclical data](#cyclical-objects)
  - [Promises](#promises)
  - [Instanceof](#instanceof)
  - [Function schemas](#function-schemas)
  - [Preprocess](#preprocess)
- [Common methods](#common-methods)
  - [.parse](#parse)
  - [.parseAsync](#parseasync)
  - [.safeParse](#safeparse)
  - [.safeParseAsync](#safeparseasync)
  - [.refine](#refine)
  - [.superRefine](#superRefine)
  - [.transform](#transform)
  - [.default](#default)
  - [.optional](#optional)
  - [.nullable](#nullable)
  - [.nullish](#nullish)
  - [.array](#array)
  - [.promise](#promise)
  - [.or](#or)
  - [.and](#and)
- [Guides and concepts](#guides-and-concepts)
  - [Type inference](#type-inference)
  - [Writing generic functions](#writing-generic-functions)
  - [Error handling](#error-handling)
- [Comparison](#comparison)
  - [Joi](#joi)
  - [Yup](#yup)
  - [io-ts](#io-ts)
  - [Runtypes](#runtypes)
- [Changelog](#changelog)

<!-- **Zod 2 is coming! Follow [@colinhacks](https://twitter.com/colinhacks) to stay updated and discuss the future of Zod.** -->

## What is Zod

Zod is a TypeScript-first schema declaration and validation library. I'm using the term "schema" to broadly refer to any data type, from a simple `string` to a complex nested object.

Zod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator _once_ and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures.

Some other great aspects:

- Zero dependencies
- Works in Node.js and all modern browsers
- Tiny: 8kb minified + zipped
- Immutable: methods (i.e. `.optional()`) return a new instance
- Concise, chainable interface
- Functional approach: [parse, don't validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)
- Works with plain JavaScript too! You don't need to use TypeScript.

## Sponsorship

Sponsorship at any level is appreciated and encouraged. Zod is maintained by a solo developer ([hi!](https://twitter.com/colinhacks)). For individual developers, consider the [Cup of Coffee tier](https://github.com/sponsors/colinhacks). If you built a paid product using Zod, consider the [Startup tier](https://github.com/sponsors/colinhacks). You can learn more about the tiers at [github.com/sponsors/colinhacks](https://github.com/sponsors/colinhacks).

<table>
  <tr>
   <td align="center">
      <a href="https://deletype.com/">
        <img src="https://avatars0.githubusercontent.com/u/15068039?s=200&v=4" width="100px;" alt="" />
      </a>
      <br>
      <b>Deletype</b>
      <br>
      <a href="https://deletype.com/">deletype.com/</a>
    </td>
  <td align="center">
      <a href="https://github.com/kevinsimper">
        <img src="https://avatars1.githubusercontent.com/u/1126497?s=460&v=4" width="100px;" alt="" />
      </a>
      <br>
      <b>Kevin Simper</b>
      <br>
      <a href="https://github.com/kevinsimper">@kevinsimper</a>
    </td>
    <td align="center">
      <a href="https://twitter.com/flybayer">
        <img src="https://avatars2.githubusercontent.com/u/8813276?s=460&u=4ff8beb9a67b173015c4b426a92d89cab960af1b&v=4" width="100px;" alt=""/>
      </a>
      <br>
      <b>Brandon Bayer</b>
      <br/>
      <a href="https://twitter.com/flybayer">@flybayer</a>,
      <span>creator of <a href="https://blitzjs.com">Blitz.js</a></span>
      <br />
    </td>

  </tr>
  <tr>
    <td align="center">
      <a href="https://www.bamboocreative.nz/">
        <img src="https://avatars1.githubusercontent.com/u/41406870?s=460&v=4" width="100px;" alt="" />
      </a>
      <br>
      <b>Bamboo Creative</b>
      <br>
      <a href="https://www.bamboocreative.nz/">bamboocreative.nz</a>
    </td>
    <td align="center">
      <a href="https://github.com/jeremyBanks">
        <img src="https://avatars.githubusercontent.com/u/18020?s=400&u=dba6c1402ae1746a276a5d256e01d68e774a0e9d&v=4" width="100px;" alt="" />
      </a>
      <br>
      <b>Jeremy Banks</b>
      <br>
      <a href="https://github.com/jeremyBanks">github.com/jeremyBanks</a>
    </td>
     <td align="center">
      <a href="https://marcatopartners.com/">
        <img src="https://avatars.githubusercontent.com/u/84106192?s=200&v=4" width="100px;" alt="Marcato Partners" />
      </a>
      <br>
      <b>Marcato Partners</b>
      <br>
      <a href="https://marcatopartners.com/">marcatopartners.com</a>
    </td>
  </tr>
</table>

_To get your name + Twitter + website here, sponsor Zod at the [Freelancer](https://github.com/sponsors/colinhacks) or [Consultancy](https://github.com/sponsors/colinhacks) tier._

## Installation

To install Zod v3:

```sh
npm install zod
```

⚠️ IMPORTANT: You must enable `strict` mode in your `tsconfig.json`. This is a best practice for all TypeScript projects.

```ts
// tsconfig.json
{
  // ...
  "compilerOptions": {
    // ...
    "strict": true
  }
}
```

**TypeScript requirements**

- Zod 3.x requires TypeScript 4.1+
- Zod 2.x requires TypeScript 3.7+
- Zod 1.x requires TypeScript 3.3+

## Ecosystem

There are a growing number of tools that are built atop or support Zod natively! If you've built a tool or library on top of Zod, tell me about it [on Twitter](https://twitter.com/colinhacks) or [start a Discussion](https://github.com/colinhacks/zod/discussions). I'll add it below and tweet it out.

- [`tRPC`](https://github.com/trpc/trpc): Build end-to-end typesafe APIs without GraphQL.
- [`ts-to-zod`](https://github.com/fabien0102/ts-to-zod): Convert TypeScript definitions into Zod schemas.
- [`zod-to-ts`](https://github.com/sachinraja/zod-to-ts): Generate TypeScript definitions from Zod schemas.
- [`@anatine/zod-openapi`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-openapi): Converts a Zod schema to an OpenAPI v3.x `SchemaObject`.
- [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/Marak/Faker.js).
- [`@anatine/zod-nestjs`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-nestjs): Helper methods for using Zod in a NestJS project.
- [`zod-mocking`](https://github.com/dipasqualew/zod-mocking): Generate mock data from your Zod schemas.
- [`zod-fast-check`](https://github.com/DavidTimms/zod-fast-check): Generate `fast-check` arbitraries from Zod schemas.
- [`zod-endpoints`](https://github.com/flock-community/zod-endpoints): Contract-first strictly typed endpoints with Zod. OpenAPI compatible.
- [`express-zod-api`](https://github.com/RobinTail/express-zod-api): Build Express-based APIs with I/O schema validation and custom middlewares.
- [`zod-to-json-schema`](https://github.com/StefanTerdell/zod-to-json-schema): Convert your Zod schemas into [JSON Schemas](https://json-schema.org/).
- [`json-schema-to-zod`](https://github.com/StefanTerdell/json-schema-to-zod): Convert your [JSON Schemas](https://json-schema.org/) into Zod schemas. Use it live [here](https://StefanTerdell.github.io/json-schema-to-zod-react/).
- [`json-to-zod`](https://github.com/rsinohara/json-to-zod): Convert JSON objects into Zod schemas. Use it live [here](https://rsinohara.github.io/json-to-zod-react/).
- [`zod-dto`](https://github.com/kbkk/abitia/tree/master/packages/zod-dto): Generate Nest.js DTOs from a Zod schema.
- [`soly`](https://github.com/mdbetancourt/soly): Create CLI applications with zod.
- [`graphql-codegen-typescript-validation-schema`](https://github.com/Code-Hex/graphql-codegen-typescript-validation-schema): GraphQL Code Generator plugin to generate form validation schema from your GraphQL schema
- [`zod-prisma`](https://github.com/CarterGrimmeisen/zod-prisma): Generate Zod schemas from your Prisma schema.
- [`fastify-type-provider-zod`](https://github.com/turkerdev/fastify-type-provider-zod): Create Fastify type providers from Zod schemas
- [`Supervillain`](https://github.com/Southclaws/supervillain): Generate Zod schemas from your Go structs

**Form integrations**

- [`react-hook-form`](https://github.com/react-hook-form/resolvers#zod): A first-party Zod resolver for React Hook Form
- [`zod-formik-adapter`](https://github.com/robertLichtnow/zod-formik-adapter): A community-maintained Formik adapter for Zod
- [`react-zorm`](https://github.com/esamattis/react-zorm): Standalone `<form>` generation and validation for React using Zod

## Basic usage

Create a string schema

```ts
import { z } from "zod";

// creating a schema for strings
const mySchema = z.string();

// parsing
mySchema.parse("tuna"); // => "tuna"
mySchema.parse(12); // => throws ZodError

// "safe" parsing (doesn't throw error if validation fails)
mySchema.safeParse("tuna"); // => { success: true; data: "tuna" }
mySchema.safeParse(12); // => { success: false; error: ZodError }
```

Create an object schema

```ts
import { z } from "zod";

const User = z.object({
  username: z.string(),
});
```

Parse a value

```ts
User.parse({ username: "Ludwig" });
// => { username: "Ludwig" }

User.parse({ usrnm: "Ludwig" });
// error
```

Extract an inferred type

```ts
type User = z.infer<typeof User>;
// { username: string }

const bobby: User = { username: "bobby" };
```

### <hr />

## Primitives

```ts
import { z } from "zod";

// primitive values
z.string();
z.number();
z.bigint();
z.boolean();
z.date();

// empty types
z.undefined();
z.null();
z.void(); // accepts undefined

// catch-all types
// allows any value
z.any();
z.unknown();

// never type
// allows no values
z.never();
```

## Literals

```ts
const tuna = z.literal("tuna");
const twelve = z.literal(12);
const tru = z.literal(true);

// retrieve literal value
tuna.value; // "tuna"
```

> Currently there is no support for Date or bigint literals in Zod. If you have a use case for this feature, please file an issue.

## Strings

Zod includes a handful of string-specific validations.

```ts
z.string().max(5);
z.string().min(5);
z.string().length(5);
z.string().email();
z.string().url();
z.string().uuid();
z.string().cuid();
z.string().regex(regex);

// deprecated, equivalent to .min(1)
z.string().nonempty();

// optional custom error message
z.string().nonempty({ message: "Can't be empty" });
```

> Check out [validator.js](https://github.com/validatorjs/validator.js) for a bunch of other useful string validation functions.

### Custom error messages

You can customize certain errors when creating a string schema.

```ts
const name = z.string({
  required_error: "Name is required",
  invalid_type_error: "Name must be a string",
});
```

When using validation methods, you can pass in an additional argument to provide a custom error message.

```ts
z.string().min(5, { message: "Must be 5 or more characters long" });
z.string().max(5, { message: "Must be 5 or fewer characters long" });
z.string().length(5, { message: "Must be exactly 5 characters long" });
z.string().email({ message: "Invalid email address" });
z.string().url({ message: "Invalid url" });
z.string().uuid({ message: "Invalid UUID" });
```

## Numbers

You can customize certain error messages when creating a number schema.

```ts
const age = z.number({
  required_error: "Age is required",
  invalid_type_error: "Age must be a number",
});
```

Zod includes a handful of number-specific validations.

```ts
z.number().gt(5);
z.number().gte(5); // alias .min(5)
z.number().lt(5);
z.number().lte(5); // alias .max(5)

z.number().int(); // value must be an integer

z.number().positive(); //     > 0
z.number().nonnegative(); //  >= 0
z.number().negative(); //     < 0
z.number().nonpositive(); //  <= 0

z.number().multipleOf(5); // Evenly divisible by 5. Alias .step(5)
```

Optionally, you can pass in a second argument to provide a custom error message.

```ts
z.number().lte(5, { message: "this👏is👏too👏big" });
```

## NaNs

You can customize certain error messages when creating a nan schema.

```ts
const isNaN = z.nan({
  required_error: "isNaN is required",
  invalid_type_error: "isNaN must be not a number",
});
```

## Booleans

You can customize certain error messages when creating a boolean schema.

```ts
const isActive = z.boolean({
  required_error: "isActive is required",
  invalid_type_error: "isActive must be a boolean",
});
```

## Dates

z.date() accepts a date, not a date string

```ts
z.date().safeParse(new Date()); // success: true
z.date().safeParse("2022-01-12T00:00:00.000Z"); // success: false
```

To allow for dates or date strings, you can use preprocess

```ts
const dateSchema = z.preprocess((arg) => {
  if (typeof arg == "string" || arg instanceof Date) return new Date(arg);
}, z.date());
type DateSchema = z.infer<typeof dateSchema>;
// type DateSchema = Date

dateSchema.safeParse(new Date("1/12/22")); // success: true
dateSchema.safeParse("2022-01-12T00:00:00.000Z"); // success: true
```

## Zod enums

```ts
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
type FishEnum = z.infer<typeof FishEnum>;
// 'Salmon' | 'Tuna' | 'Trout'
```

`z.enum` is a Zod-native way to declare a schema with a fixed set of allowable _string_ values. Pass the array of values directly into `z.enum()`. Alternatively, use `as const` to define your enum values as a tuple of strings. See the [const assertion docs](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) for details.

```ts
const VALUES = ["Salmon", "Tuna", "Trout"] as const;
const FishEnum = z.enum(VALUES);
```

This is not allowed, since Zod isn't able to infer the exact values of each elements.

```ts
const fish = ["Salmon", "Tuna", "Trout"];
const FishEnum = z.enum(fish);
```

**Autocompletion**

To get autocompletion with a Zod enum, use the `.enum` property of your schema:

```ts
FishEnum.enum.Salmon; // => autocompletes

FishEnum.enum;
/*
=> {
  Salmon: "Salmon",
  Tuna: "Tuna",
  Trout: "Trout",
}
*/
```

You can also retrieve the list of options as a tuple with the `.options` property:

```ts
FishEnum.options; // ["Salmon", "Tuna", "Trout"]);
```

## Native enums

Zod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-party library (or you don't want to rewrite your existing enums) you can use `z.nativeEnum()` .

**Numeric enums**

```ts
enum Fruits {
  Apple,
  Banana,
}

const FruitEnum = z.nativeEnum(Fruits);
type FruitEnum = z.infer<typeof FruitEnum>; // Fruits

FruitEnum.parse(Fruits.Apple); // passes
FruitEnum.parse(Fruits.Banana); // passes
FruitEnum.parse(0); // passes
FruitEnum.parse(1); // passes
FruitEnum.parse(3); // fails
```

**String enums**

```ts
enum Fruits {
  Apple = "apple",
  Banana = "banana",
  Cantaloupe, // you can mix numerical and string enums
}

const FruitEnum = z.nativeEnum(Fruits);
type FruitEnum = z.infer<typeof FruitEnum>; // Fruits

FruitEnum.parse(Fruits.Apple); // passes
FruitEnum.parse(Fruits.Cantaloupe); // passes
FruitEnum.parse("apple"); // passes
FruitEnum.parse("banana"); // passes
FruitEnum.parse(0); // passes
FruitEnum.parse("Cantaloupe"); // fails
```

**Const enums**

The `.nativeEnum()` function works for `as const` objects as well. ⚠️ `as const` required TypeScript 3.4+!

```ts
const Fruits = {
  Apple: "apple",
  Banana: "banana",
  Cantaloupe: 3,
} as const;

const FruitEnum = z.nativeEnum(Fruits);
type FruitEnum = z.infer<typeof FruitEnum>; // "apple" | "banana" | 3

FruitEnum.parse("apple"); // passes
FruitEnum.parse("banana"); // passes
FruitEnum.parse(3); // passes
FruitEnum.parse("Cantaloupe"); // fails
```

You can access the underlying object with the `.enum` property:

```ts
FruitEnum.enum.Apple; // "apple"
```

## Optionals

You can make any schema optional with `z.optional()`:

```ts
const schema = z.optional(z.string());

schema.parse(undefined); // => returns undefined
type A = z.infer<typeof schema>; // string | undefined
```

You can make an existing schema optional with the `.optional()` method:

```ts
const user = z.object({
  username: z.string().optional(),
});
type C = z.infer<typeof user>; // { username?: string | undefined };
```

### `.unwrap`

```ts
const stringSchema = z.string();
const optionalString = stringSchema.optional();
optionalString.unwrap() === stringSchema; // true
```

## Nullables

Similarly, you can create nullable types like so:

```ts
const nullableString = z.nullable(z.string());
nullableString.parse("asdf"); // => "asdf"
nullableString.parse(null); // => null
```

You can make an existing schema nullable with the `nullable` method:

```ts
const E = z.string().nullable(); // equivalent to D
type E = z.infer<typeof E>; // string | null
```

### `.unwrap`

```ts
const stringSchema = z.string();
const nullableString = stringSchema.nullable();
nullableString.unwrap() === stringSchema; // true
```

## Objects

```ts
// all properties are required by default
const Dog = z.object({
  name: z.string(),
  age: z.number(),
});

// extract the inferred type like this
type Dog = z.infer<typeof Dog>;

// equivalent to:
type Dog = {
  name: string;
  age: number;
};
```

### `.shape`

Use `.shape` to access the schemas for a particular key.

```ts
Dog.shape.name; // => string schema
Dog.shape.age; // => number schema
```

### `.extend`

You can add additional fields an object schema with the `.extend` method.

```ts
const DogWithBreed = Dog.extend({
  breed: z.string(),
});
```

You can use `.extend` to overwrite fields! Be careful with this power!

### `.merge`

Equivalent to `A.extend(B.shape)`.

```ts
const BaseTeacher = z.object({ students: z.array(z.string()) });
const HasID = z.object({ id: z.string() });

const Teacher = BaseTeacher.merge(HasID);
type Teacher = z.infer<typeof Teacher>; // => { students: string[], id: string }
```

> If the two schemas share keys, the properties of B overrides the property of A. The returned schema also inherits the "unknownKeys" policy (strip/strict/passthrough) and the catchall schema of B.

### `.pick/.omit`

Inspired by TypeScript's built-in `Pick` and `Omit` utility types, all Zod object schemas have `.pick` and `.omit` methods that return a modified version. Consider this Recipe schema:

```ts
const Recipe = z.object({
  id: z.string(),
  name: z.string(),
  ingredients: z.array(z.string()),
});
```

To only keep certain keys, use `.pick` .

```ts
const JustTheName = Recipe.pick({ name: true });
type JustTheName = z.infer<typeof JustTheName>;
// => { name: string }
```

To remove certain keys, use `.omit` .

```ts
const NoIDRecipe = Recipe.omit({ id: true });

type NoIDRecipe = z.infer<typeof NoIDRecipe>;
// => { name: string, ingredients: string[] }
```

### `.partial`

Inspired by the built-in TypeScript utility type [Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt), the `.partial` method makes all properties optional.

Starting from this object:

```ts
const user = z.object({
  email: z.string()
  username: z.string(),
});
// { email: string; username: string }
```

We can create a partial version:

```ts
const partialUser = user.partial();
// { email?: string | undefined; username?: string | undefined }
```

You can also specify which properties to make optional:

```ts
const optionalEmail = user.partial({
  email: true,
});
/*
{
  email?: string | undefined;
  username: string
}
*/
```

### `.deepPartial`

The `.partial` method is shallow — it only applies one level deep. There is also a "deep" version:

```ts
const user = z.object({
  username: z.string(),
  location: z.object({
    latitude: z.number(),
    longitude: z.number(),
  }),
  strings: z.array(z.object({ value: z.string() })),
});

const deepPartialUser = user.deepPartial();

/*
{
  username?: string | undefined,
  location?: {
    latitude?: number | undefined;
    longitude?: number | undefined;
  } | undefined,
  strings?: { value?: string}[]
}
*/
```

> Important limitation: deep partials only work as expected in hierarchies of objects, arrays, and tuples.

### Unrecognized keys

By default Zod objects schemas strip out unrecognized keys during parsing.

```ts
const person = z.object({
  name: z.string(),
});

person.parse({
  name: "bob dylan",
  extraKey: 61,
});
// => { name: "bob dylan" }
// extraKey has been stripped
```

### `.passthrough`

Instead, if you want to pass through unknown keys, use `.passthrough()` .

```ts
person.passthrough().parse({
  name: "bob dylan",
  extraKey: 61,
});
// => { name: "bob dylan", extraKey: 61 }
```

### `.strict`

You can _disallow_ unknown keys with `.strict()` . If there are any unknown keys in the input, Zod will throw an error.

```ts
const person = z
  .object({
    name: z.string(),
  })
  .strict();

person.parse({
  name: "bob dylan",
  extraKey: 61,
});
// => throws ZodError
```

### `.strip`

You can use the `.strip` method to reset an object schema to the default behavior (stripping unrecognized keys).

### `.catchall`

You can pass a "catchall" schema into an object schema. All unknown keys will be validated against it.

```ts
const person = z
  .object({
    name: z.string(),
  })
  .catchall(z.number());

person.parse({
  name: "bob dylan",
  validExtraKey: 61, // works fine
});

person.parse({
  name: "bob dylan",
  validExtraKey: false, // fails
});
// => throws ZodError
```

Using `.catchall()` obviates `.passthrough()` , `.strip()` , or `.strict()`. All keys are now considered "known".

## Arrays

```ts
const stringArray = z.array(z.string());

// equivalent
const stringArray = z.string().array();
```

Be careful with the `.array()` method. It returns a new `ZodArray` instance. This means the _order_ in which you call methods matters. For instance:

```ts
z.string().optional().array(); // (string | undefined)[]
z.string().array().optional(); // string[] | undefined
```

### `.element`

Use `.element` to access the schema for an element of the array.

```ts
stringArray.element; // => string schema
```

### `.nonempty`

If you want to ensure that an array contains at least one element, use `.nonempty()`.

```ts
const nonEmptyStrings = z.string().array().nonempty();
// the inferred type is now
// [string, ...string[]]

nonEmptyStrings.parse([]); // throws: "Array cannot be empty"
nonEmptyStrings.parse(["Ariana Grande"]); // passes
```

You can optionally specify a custom error message:

```ts
// optional custom error message
const nonEmptyStrings = z.string().array().nonempty({
  message: "Can't be empty!",
});
```

### `.min/.max/.length`

```ts
z.string().array().min(5); // must contain 5 or more items
z.string().array().max(5); // must contain 5 or fewer items
z.string().array().length(5); // must contain 5 items exactly
```

Unlike `.nonempty()` these methods do not change the inferred type.

## Tuples

Unlike arrays, tuples have a fixed number of elements and each element can have a different type.

```ts
const athleteSchema = z.tuple([
  z.string(), // name
  z.number(), // jersey number
  z.object({
    pointsScored: z.number(),
  }), // statistics
]);

type Athlete = z.infer<typeof athleteSchema>;
// type Athlete = [string, number, { pointsScored: number }]
```

## Unions

Zod includes a built-in `z.union` method for composing "OR" types.

```ts
const stringOrNumber = z.union([z.string(), z.number()]);

stringOrNumber.parse("foo"); // passes
stringOrNumber.parse(14); // passes
```

Zod will test the input against each of the "options" in order and return the first value that validates successfully.

For convenience, you can also use the `.or` method:

```ts
const stringOrNumber = z.string().or(z.number());
```

## Discriminated unions

If the union consists of object schemas all identifiable by a common property, it is possible to use the `z.discriminatedUnion` method.

```ts
const item = z
  .discriminatedUnion("type", [
    z.object({ type: z.literal("a"), a: z.string() }),
    z.object({ type: z.literal("b"), b: z.string() }),
  ])
  .parse({ type: "a", a: "abc" });
```

This provides more efficient evaluation and more human-friendly errors. Using simple unions, the input is tested against each of the provided "options" in order. If all options fail validation, the returned error contains the "suberrors" thrown by each option.

By contrast, the discriminated union uses the discriminator key to determine which option to testing against.

## Records

Record schemas are used to validate types such as `{ [k: string]: number }`.

If you want to validate the _values_ of an object against some schema but don't care about the keys, use `Record`.

```ts
const NumberCache = z.record(z.number());

type NumberCache = z.infer<typeof NumberCache>;
// => { [k: string]: number }
```

This is particularly useful for storing or caching items by ID.

```ts
const userStore: UserStore = {};

userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
  name: "Carlotta",
}; // passes

userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
  whatever: "Ice cream sundae",
}; // TypeError
```

### A note on numerical keys

You may have expected `z.record()` to accept two arguments, one for the keys and one for the values. After all, TypeScript's built-in Record type does: `Record<KeyType, ValueType>` . Otherwise, how do you represent the TypeScript type `Record<number, any>` in Zod?

As it turns out, TypeScript's behavior surrounding `[k: number]` is a little unintuitive:

```ts
const testMap: { [k: number]: string } = {
  1: "one",
};

for (const key in testMap) {
  console.log(`${key}: ${typeof key}`);
}
// prints: `1: string`
```

As you can see, JavaScript automatically casts all object keys to strings under the hood.

Since Zod is trying to bridge the gap between static and runtime types, it doesn't make sense to provide a way of creating a record schema with numerical keys, since there's no such thing as a numerical key in runtime JavaScript.

## Maps

```ts
const stringNumberMap = z.map(z.string(), z.number());

type StringNumberMap = z.infer<typeof stringNumberMap>;
// type StringNumberMap = Map<string, number>
```

## Sets

```ts
const numberSet = z.set(z.number());
type NumberSet = z.infer<typeof numberSet>;
// type NumberSet = Set<number>
```

### `.nonempty/.min/.max/.size`

```ts
z.set(z.string()).nonempty(); // must contain at least one item
z.set(z.string()).min(5); // must contain 5 or more items
z.set(z.string()).max(5); // must contain 5 or fewer items
z.set(z.string()).size(5); // must contain 5 items exactly
```

## Intersections

<!-- > ⚠️ Intersections are deprecated. If you are trying to merge objects, use the `.merge` method instead. -->

Intersections are useful for creating "logical AND" types. This is useful for intersecting two object types.

```ts
const Person = z.object({
  name: z.string(),
});

const Employee = z.object({
  role: z.string(),
});

const EmployedPerson = z.intersection(Person, Employee);

// equivalent to:
const EmployedPerson = Person.and(Employee);
```

Though in many cases, it is recommended to use `A.merge(B)` to merge two objects. The `.merge` method returns a new `ZodObject` instance, whereas `A.and(B)` returns a less useful `ZodIntersection` instance that lacks common object methods like `pick` and `omit`.

```ts
const a = z.union([z.number(), z.string()]);
const b = z.union([z.number(), z.boolean()]);
const c = z.intersection(a, b);

type c = z.infer<typeof c>; // => number
```

<!-- Intersections in Zod are not smart. Whatever data you pass into `.parse()` gets passed into the two intersected schemas. Because Zod object schemas don't allow any unknown keys by default, there are some unintuitive behavior surrounding intersections of object schemas. -->

<!--

``` ts
const A = z.object({
  a: z.string(),
});

const B = z.object({
  b: z.string(),
});

const AB = z.intersection(A, B);

type Teacher = z.infer<typeof Teacher>;
// { id:string; name:string };
```  -->

## Recursive types

You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a "type hint".

```ts
interface Category {
  name: string;
  subcategories: Category[];
}

// cast to z.ZodType<Category>
const Category: z.ZodType<Category> = z.lazy(() =>
  z.object({
    name: z.string(),
    subcategories: z.array(Category),
  })
);

Category.parse({
  name: "People",
  subcategories: [
    {
      name: "Politicians",
      subcategories: [{ name: "Presidents", subcategories: [] }],
    },
  ],
}); // passes
```

Unfortunately this code is a bit duplicative, since you're declaring the types twice: once in the interface and again in the Zod definition.

<!-- If your schema has lots of primitive fields, there's a way of reducing the amount of duplication:

```ts
// define all the non-recursive stuff here
const BaseCategory = z.object({
  name: z.string(),
  tags: z.array(z.string()),
  itemCount: z.number(),
});

// create an interface that extends the base schema
interface Category extends z.infer<typeof BaseCategory> {
  subcategories: Category[];
}

// merge the base schema with
// a new Zod schema containing relations
const Category: z.ZodType<Category> = BaseCategory.merge(
  z.object({
    subcategories: z.lazy(() => z.array(Category)),
  })
);
``` -->

### JSON type

If you want to validate any JSON value, you can use the snippet below.

```ts
type Literal = boolean | null | number | string;
type Json = Literal | { [key: string]: Json } | Json[];
const literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);
const jsonSchema: z.ZodType<Json> = z.lazy(() =>
  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])
);

jsonSchema.parse(data);
```

Thanks to [ggoodman](https://github.com/ggoodman) for suggesting this.

### Cyclical objects

Despite supporting recursive schemas, passing cyclical data into Zod will cause an infinite loop.

## Promises

```ts
const numberPromise = z.promise(z.number());
```

"Parsing" works a little differently with promise schemas. Validation happens in two parts:

1. Zod synchronously checks that the input is an instance of Promise (i.e. an object with `.then` and `.catch` methods.).
2. Zod uses `.then` to attach an additional validation step onto the existing Promise. You'll have to use `.catch` on the returned Promise to handle validation failures.

```ts
numberPromise.parse("tuna");
// ZodError: Non-Promise type: string

numberPromise.parse(Promise.resolve("tuna"));
// => Promise<number>

const test = async () => {
  await numberPromise.parse(Promise.resolve("tuna"));
  // ZodError: Non-number type: string

  await numberPromise.parse(Promise.resolve(3.14));
  // => 3.14
};
```

<!-- #### Non-native promise implementations

When "parsing" a promise, Zod checks that the passed value is an object with `.then` and `.catch` methods — that's it. So you should be able to pass non-native Promises (Bluebird, etc) into `z.promise(...).parse` with no trouble. One gotcha: the return type of the parse function will be a _native_ `Promise` , so if you have downstream logic that uses non-standard Promise methods, this won't work. -->

## Instanceof

You can use `z.instanceof` to check that the input is an instance of a class. This is useful to validate inputs against classes that are exported from third-party libraries.

```ts
class Test {
  name: string;
}

const TestSchema = z.instanceof(Test);

const blob: any = "whatever";
TestSchema.parse(new Test()); // passes
TestSchema.parse("blob"); // throws
```

## Function schemas

Zod also lets you define "function schemas". This makes it easy to validate the inputs and outputs of a function without intermixing your validation code and "business logic".

You can create a function schema with `z.function(args, returnType)` .

```ts
const myFunction = z.function();

type myFunction = z.infer<typeof myFunction>;
// => ()=>unknown
```

**Define inputs and output**

```ts
const myFunction = z
  .function()
  .args(z.string(), z.number()) // accepts an arbitrary number of arguments
  .returns(z.boolean());
type myFunction = z.infer<typeof myFunction>;
// => (arg0: string, arg1: number)=>boolean
```

**Extract the input and output schemas**
You can extract the parameters and return type of a function schema.

```ts
myFunction.parameters();
// => ZodTuple<[ZodString, ZodNumber]>

myFunction.returnType();
// => ZodBoolean
```

<!-- `z.function()` accepts two arguments:

* `args: ZodTuple` The first argument is a tuple (created with `z.tuple([...])` and defines the schema of the arguments to your function. If the function doesn't accept arguments, you can pass an empty tuple (`z.tuple([])`).
* `returnType: any Zod schema` The second argument is the function's return type. This can be any Zod schema. -->

> You can use the special `z.void()` option if your function doesn't return anything. This will let Zod properly infer the type of void-returning functions. (Void-returning functions actually return undefined.)

<!--

``` ts
const args = z.tuple([z.string()]);

const returnType = z.number();

const myFunction = z.function(args, returnType);
type myFunction = z.infer<typeof myFunction>;
// => (arg0: string)=>number
``` -->

Function schemas have an `.implement()` method which accepts a function and returns a new function that automatically validates it's inputs and outputs.

```ts
const trimmedLength = z
  .function()
  .args(z.string()) // accepts an arbitrary number of arguments
  .returns(z.number())
  .implement((x) => {
    // TypeScript knows x is a string!
    return x.trim().length;
  });

trimmedLength("sandwich"); // => 8
trimmedLength(" asdf "); // => 4
```

If you only care about validating inputs, that's fine:

```ts
const myFunction = z
  .function()
  .args(z.string())
  .implement((arg) => {
    return [arg.length]; //
  });
myFunction; // (arg: string)=>number[]
```

## Preprocess

Typically Zod operates under a "parse then transform" paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the [.transform docs](#transform).)

But sometimes you want to apply some transform to the input _before_ parsing happens. A common use case: type coercion. Zod enables this with the `z.preprocess()`.

```ts
const castToString = z.preprocess((val) => String(val), z.string());
```

This returns a `ZodEffects` instance. `ZodEffects` is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.

### <hr />

## Common methods

All Zod schemas extend the `ZodType` base class, which provides the following methods.

### `.parse`

`.parse(data:unknown): T`

Given any Zod schema, you can call its `.parse` method to check `data` is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.

> IMPORTANT: In Zod 2 and Zod 1.11+, the value returned by `.parse` is a _deep clone_ of the variable you passed in. This was also the case in zod@1.4 and earlier.

```ts
const stringSchema = z.string();
stringSchema.parse("fish"); // => returns "fish"
stringSchema.parse(12); // throws Error('Non-string type: number');
```

### `.parseAsync`

`.parseAsync(data:unknown): Promise<T>`

If you use asynchronous [refinements](#refine) or [transforms](#transform) (more on those later), you'll need to use `.parseAsync`

```ts
const stringSchema = z.string().refine(async (val) => val.length > 20);
const value = await stringSchema.parseAsync("hello"); // => hello
```

### `.safeParse`

`.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }`

If you don't want Zod to throw errors when validation fails, use `.safeParse`. This method returns an object containing either the successfully parsed data or a ZodError instance containing detailed information about the validation problems.

```ts
stringSchema.safeParse(12);
// => { success: false; error: ZodError }

stringSchema.safeParse("billie");
// => { success: true; data: 'billie' }
```

The result is a _discriminated union_ so you can handle errors very conveniently:

```ts
const result = stringSchema.safeParse("billie");
if (!result.success) {
  // handle error then return
  result.error;
} else {
  // do something
  result.data;
}
```

### `.safeParseAsync`

> Alias: `.spa`

An asynchronous version of `safeParse`.

```ts
await stringSchema.safeParseAsync("billie");
```

For convenience, this has been aliased to `.spa`:

```ts
await stringSchema.spa("billie");
```

### `.refine`

`.refine(validator: (data:T)=>any, params?: RefineParams)`

Zod lets you provide custom validation logic via _refinements_. (For advanced features like creating multiple issues and customizing error codes, see [`.superRefine`](#superrefine).)

Zod was designed to mirror TypeScript as closely as possible. But there are many so-called "refinement types" you may wish to check for that can't be represented in TypeScript's type system. For instance: checking that a number is an integer or that a string is a valid email address.

For example, you can define a custom validation check on _any_ Zod schema with `.refine` :

```ts
const myString = z.string().refine((val) => val.length <= 255, {
  message: "String can't be more than 255 characters",
});
```

> ⚠️ Refinement functions should not throw. Instead they should return a falsy value to signal failure.

#### Arguments

As you can see, `.refine` takes two arguments.

1. The first is the validation function. This function takes one input (of type `T` — the inferred type of the schema) and returns `any`. Any truthy value will pass validation. (Prior to zod@1.6.2 the validation function had to return a boolean.)
2. The second argument accepts some options. You can use this to customize certain error-handling behavior:

```ts
type RefineParams = {
  // override error message
  message?: string;

  // appended to error path
  path?: (string | number)[];

  // params object you can use to customize message
  // in error map
  params?: object;
};
```

For advanced cases, the second argument can also be a function that returns `RefineParams`/

```ts
z.string().refine(
  (val) => val.length > 10,
  (val) => ({ message: `${val} is not more than 10 characters` })
);
```

#### Customize error path

```ts
const passwordForm = z
  .object({
    password: z.string(),
    confirm: z.string(),
  })
  .refine((data) => data.password === data.confirm, {
    message: "Passwords don't match",
    path: ["confirm"], // path of error
  })
  .parse({ password: "asdf", confirm: "qwer" });
```

Because you provided a `path` parameter, the resulting error will be:

```ts
ZodError {
  issues: [{
    "code": "custom",
    "path": [ "confirm" ],
    "message": "Passwords don't match"
  }]
}
```

#### Asynchronous refinements

Refinements can also be async:

```ts
const userId = z.string().refine(async (id) => {
  // verify that ID exists in database
  return true;
});
```

> ⚠️If you use async refinements, you must use the `.parseAsync` method to parse data! Otherwise Zod will throw an error.

#### Relationship to transforms

Transforms and refinements can be interleaved:

```ts
z.string()
  .transform((val) => val.length)
  .refine((val) => val > 25);
```

<!-- Note that the `path` is set to `["confirm"]` , so you can easily display this error underneath the "Confirm password" textbox.


```ts
const allForms = z.object({ passwordForm }).parse({
  passwordForm: {
    password: "asdf",
    confirm: "qwer",
  },
});
```

would result in

```

ZodError {
  issues: [{
    "code": "custom",
    "path": [ "passwordForm", "confirm" ],
    "message": "Passwords don't match"
  }]
}
``` -->

### `.superRefine`

The `.refine` method is actually syntactic sugar atop a more versatile (and verbose) method called `superRefine`. Here's an example:

```ts
const Strings = z.array(z.string()).superRefine((val, ctx) => {
  if (val.length > 3) {
    ctx.addIssue({
      code: z.ZodIssueCode.too_big,
      maximum: 3,
      type: "array",
      inclusive: true,
      message: "Too many items 😡",
    });
  }

  if (val.length !== new Set(val).size) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `No duplicated allowed.`,
    });
  }
});
```

You can add as many issues as you like. If `ctx.addIssue` is NOT called during the execution of the function, validation passes.

Normally refinements always create issues with a `ZodIssueCode.custom` error code, but with `superRefine` you can create any issue of any code. Each issue code is described in detail in the Error Handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md).

#### Abort early

By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to _abort early_ to prevent later refinements from being executed. To achieve this, pass the `fatal` flag to `ctx.addIssue`:

```ts
const Strings = z
  .number()
  .superRefine((val, ctx) => {
    if (val < 10) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "foo",
        fatal: true,
      });
    }
  })
  .superRefine((val, ctx) => {
    if (val !== " ") {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "bar",
      });
    }
  });
```

### `.transform`

`.transform<Out>((val: T) => Out)`

To transform data after parsing, use the `transform` method.

```ts
const stringToNumber = z.string().transform((val) => myString.length);
stringToNumber.parse("string"); // => 6
```

> ⚠️ Transform functions must not throw. Make sure to use refinements before the transform to make sure the input can be parsed by the transform.

#### Chaining order

Note that `stringToNumber` above is an instance of the `ZodEffects` subclass. It is NOT an instance of `ZodString`. If you want to use the built-in methods of `ZodString` (e.g. `.email()`) you must apply those methods _before_ any transforms.

```ts
const emailToDomain = z
  .string()
  .email()
  .transform((val) => val.split("@")[1]);

emailToDomain.parse("colinhacks@example.com"); // => example.com
```

#### Relationship to refinements

Transforms and refinements can be interleaved:

```ts
z.string()
  .transform((val) => val.length)
  .refine((val) => val > 25);
```

#### Async transforms

Transforms can also be async.

```ts
const IdToUser = z
  .string()
  .uuid()
  .transform(async (id) => {
    return await getUserById(id);
  });
```

> ⚠️ If your schema contains asynchronous transforms, you must use .parseAsync() or .safeParseAsync() to parse data. Otherwise Zod will throw an error.

### `.default`

You can use transforms to implement the concept of "default values" in Zod.

```ts
const stringWithDefault = z.string().default("tuna");

stringWithDefault.parse(undefined); // => "tuna"
```

Optionally, you can pass a function into `.default` that will be re-executed whenever a default value needs to be generated:

```ts
const numberWithRandomDefault = z.number().default(Math.random);

numberWithRandomDefault.parse(undefined); // => 0.4413456736055323
numberWithRandomDefault.parse(undefined); // => 0.1871840107401901
numberWithRandomDefault.parse(undefined); // => 0.7223408162401552
```

### `.optional`

A convenience method that returns an optional version of a schema.

```ts
const optionalString = z.string().optional(); // string | undefined

// equivalent to
z.optional(z.string());
```

### `.nullable`

A convenience method that returns an nullable version of a schema.

```ts
const nullableString = z.string().nullable(); // string | null

// equivalent to
z.nullable(z.string());
```

### `.nullish`

A convenience method that returns a "nullish" version of a schema. Nullish schemas will accept both `undefined` and `null`. Read more about the concept of "nullish" [here](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing).

```ts
const nullishString = z.string().nullish(); // string | null | undefined

// equivalent to
z.string().optional().nullable();
```

### `.array`

A convenience method that returns an array schema for the given type:

```ts
const nullableString = z.string().array(); // string[]

// equivalent to
z.array(z.string());
```

### `.promise`

A convenience method for promise types:

```ts
const stringPromise = z.string().promise(); // Promise<string>

// equivalent to
z.promise(z.string());
```

### `.or`

A convenience method for union types.

```ts
z.string().or(z.number()); // string | number

// equivalent to
z.union([z.string(), z.number()]);
```

### `.and`

A convenience method for creating intersection types.

```ts
z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } & { age: number }

// equivalent to
z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));
```

## Guides and concepts

### Type inference

You can extract the TypeScript type of any schema with `z.infer<typeof mySchema>` .

```ts
const A = z.string();
type A = z.infer<typeof A>; // string

const u: A = 12; // TypeError
const u: A = "asdf"; // compiles
```

**What about transforms?**

In reality each Zod schema internally tracks **two** types: an input and an output. For most schemas (e.g. `z.string()`) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance `z.string().transform(val => val.length)` has an input of `string` and an output of `number`.

You can separately extract the input and output types like so:

```ts
const stringToNumber = z.string().transform((val) => val.length);

// ⚠️ Important: z.infer returns the OUTPUT type!
type input = z.input<typeof stringToNumber>; // string
type output = z.output<typeof stringToNumber>; // number

// equivalent to z.output!
type inferred = z.infer<typeof stringToNumber>; // number
```

### Writing generic functions

When attempting to write a functions that accepts a Zod schemas as an input, it's common to try something like this:

```ts
function makeSchemaOptional<T>(schema: z.ZodType<T>) {
  return schema.optional();
}
```

This approach has some issues. The `schema` variable in this function is typed as an instance of `ZodType`, which is an abstract class that all Zod schemas inherit from. This approach loses type information, namely _which subclass_ the input actually is.

```ts
const arg = makeSchemaOptional(z.string());
arg.unwrap();
```

A better approach is for the generate parameter to refer to _the schema as a whole_.

```ts
function makeSchemaOptional<T extends z.ZodTypeAny>(schema: T) {
  return schema.optional();
}
```

> `ZodTypeAny` is just a shorthand for `ZodType<any, any, any>`, a type that is broad enough to match any Zod schema.

As you can see, `schema` is now fully and properly typed.

```ts
const arg = makeSchemaOptional(z.string());
arg.unwrap(); // ZodString
```

**Restricting valid schemas**

The `ZodType` class has three generic parameters.

```ts
class ZodType<
  Output,
  Def extends ZodTypeDef = ZodTypeDef,
  Input = Output
> { ... }
```

By contraining these in your generic input, you can limit what schemas are allowable as inputs to your function:

```ts
function makeSchemaOptional<T extends z.ZodType<string>>(schema: T) {
  return schema.optional();
}

makeSchemaOptional(z.string());
// works fine

makeSchemaOptional(z.number());
// Error: 'ZodNumber' is not assignable to parameter of type 'ZodType<string, ZodTypeDef, string>'
```

### Error handling

Zod provides a subclass of Error called `ZodError`. ZodErrors contain an `issues` array containing detailed information about the validation problems.

```ts
const data = z.object({ name: z.string() }).safeParse({ name: 12 });

if (!data.success) {
  data.error.issues;
  /* [
      {
        "code": "invalid_type",
        "expected": "string",
        "received": "number",
        "path": [ "name" ],
        "message": "Expected string, received number"
      }
  ] */
}
```

**Error formatting**

You can use the `.format()` method to convert this error into a nested object.

```ts
data.error.format();
/* {
  name: { _errors: [ 'Expected string, received number' ] }
} */
```

For detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md)

## Comparison

There are a handful of other widely-used validation libraries, but all of them have certain design limitations that make for a non-ideal developer experience.

<!-- The table below summarizes the feature differences. Below the table there are more involved discussions of certain alternatives, where necessary. -->

<!-- | Feature                                                                                                                | [Zod](https://github.com/colinhacks) | [Joi](https://github.com/hapijs/joi) | [Yup](https://github.com/jquense/yup) | [io-ts](https://github.com/gcanti/io-ts) | [Runtypes](https://github.com/pelotom/runtypes) | [ow](https://github.com/sindresorhus/ow) | [class-validator](https://github.com/typestack/class-validator) |
| ---------------------------------------------------------------------------------------------------------------------- | :-----------------------------: | :----------------------------------: | :-----------------------------------: | :--------------------------------------: | :---------------------------------------------: | :--------------------------------------: | :-------------------------------------------------------------: |
| <abbr title='Any ability to extract a TypeScript type from a validator instance counts.'>Type inference</abbr>         |               🟢                |                  🔴                  |                  🟢                   |                    🟢                    |                       🟢                        |                    🟢                    |                               🟢                                |
| <abbr title="Yup's inferred types are incorrect in certain cases, see discussion below.">Correct type inference</abbr> |               🟢                |                  🔴                  |                  🔴                   |                    🟢                    |                       🟢                        |                    🟢                    |                               🟢                                |

<abbr title="number, string, boolean, null, undefined">Primitive Types</abbr>
<abbr title="Includes any checks beyond 'Is this a string?', e.g. min/max length, isEmail, isURL, case checking, etc.">String Validation</abbr>
<abbr title="Includes any checks beyond 'Is this a number?', e.g. min/max, isPositive, integer vs float, etc.">Number Validation</abbr>
Dates

Primitive Literals
Object Literals
Tuple Literals
Objects
Arrays
Non-empty arrays
Unions
Optionals
Nullable
Enums
Enum Autocomplete
Intersections
Object Merging
Tuples
Recursive Types
Function Schemas

<abbr title="For instance, Yup allows custom error messages with the syntax yup.number().min(5, 'Number must be more than 5!')">Validation Messages</abbr>
Immutable instances
Type Guards
Validity Checking
Casting
Default Values
Rich Errors
Branded -->

<!-- - Missing object methods: (pick, omit, partial, deepPartial, merge, extend)

* Missing nonempty arrays with proper typing (`[T, ...T[]]`)
* Missing lazy/recursive types
* Missing promise schemas
* Missing function schemas
* Missing union & intersection schemas
* Missing support for parsing cyclical data (maybe)
* Missing error customization -->

### Joi

[https://github.com/hapijs/joi](https://github.com/hapijs/joi)

Doesn't support static type inference 😕

### Yup

[https://github.com/jquense/yup](https://github.com/jquense/yup)

Yup is a full-featured library that was implemented first in vanilla JS, and later rewritten in TypeScript.

Differences

- Supports casting and transforms
- All object fields are optional by default
- Missing object methods: (partial, deepPartial)
<!-- - Missing nonempty arrays with proper typing (`[T, ...T[]]`) -->
- Missing promise schemas
- Missing function schemas
- Missing union & intersection schemas

<!-- ¹Yup has a strange interpretation of the word `required`. Instead of meaning "not undefined", Yup uses it to mean "not empty". So `yup.string().required()` will not accept an empty string, and `yup.array(yup.string()).required()` will not accept an empty array. Instead, Yup us Zod arrays there is a dedicated `.nonempty()` method to indicate this, or you can implement it with a custom refinement. -->

### io-ts

[https://github.com/gcanti/io-ts](https://github.com/gcanti/io-ts)

io-ts is an excellent library by gcanti. The API of io-ts heavily inspired the design of Zod.

In our experience, io-ts prioritizes functional programming purity over developer experience in many cases. This is a valid and admirable design goal, but it makes io-ts particularly hard to integrate into an existing codebase with a more procedural or object-oriented bias. For instance, consider how to define an object with optional properties in io-ts:

```ts
import * as t from "io-ts";

const A = t.type({
  foo: t.string,
});

const B = t.partial({
  bar: t.number,
});

const C = t.intersection([A, B]);

type C = t.TypeOf<typeof C>;
// returns { foo: string; bar?: number | undefined }
```

You must define the required and optional props in separate object validators, pass the optionals through `t.partial` (which marks all properties as optional), then combine them with `t.intersection` .

Consider the equivalent in Zod:

```ts
const C = z.object({
  foo: z.string(),
  bar: z.number().optional(),
});

type C = z.infer<typeof C>;
// returns { foo: string; bar?: number | undefined }
```

This more declarative API makes schema definitions vastly more concise.

`io-ts` also requires the use of gcanti's functional programming library `fp-ts` to parse results and handle errors. This is another fantastic resource for developers looking to keep their codebase strictly functional. But depending on `fp-ts` necessarily comes with a lot of intellectual overhead; a developer has to be familiar with functional programming concepts and the `fp-ts` nomenclature to use the library.

- Supports codecs with serialization & deserialization transforms
- Supports branded types
- Supports advanced functional programming, higher-kinded types, `fp-ts` compatibility
- Missing object methods: (pick, omit, partial, deepPartial, merge, extend)
- Missing nonempty arrays with proper typing (`[T, ...T[]]`)
- Missing promise schemas
- Missing function schemas

### Runtypes

[https://github.com/pelotom/runtypes](https://github.com/pelotom/runtypes)

Good type inference support, but limited options for object type masking (no `.pick` , `.omit` , `.extend` , etc.). No support for `Record` s (their `Record` is equivalent to Zod's `object` ). They DO support branded and readonly types, which Zod does not.

- Supports "pattern matching": computed properties that distribute over unions
- Supports readonly types
- Missing object methods: (deepPartial, merge)
- Missing nonempty arrays with proper typing (`[T, ...T[]]`)
- Missing promise schemas
- Missing error customization

### Ow

[https://github.com/sindresorhus/ow](https://github.com/sindresorhus/ow)

Ow is focused on function input validation. It's a library that makes it easy to express complicated assert statements, but it doesn't let you parse untyped data. They support a much wider variety of types; Zod has a nearly one-to-one mapping with TypeScript's type system, whereas ow lets you validate several highly-specific types out of the box (e.g. `int32Array` , see full list in their README).

If you want to validate function inputs, use function schemas in Zod! It's a much simpler approach that lets you reuse a function type declaration without repeating yourself (namely, copy-pasting a bunch of ow assertions at the beginning of every function). Also Zod lets you validate your return types as well, so you can be sure there won't be any unexpected data passed downstream.

## Changelog

View the changelog at [CHANGELOG.md](CHANGELOG.md)
````

## File: src/__tests__/all-errors.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

const Test = z.object({
  f1: z.number(),
  f2: z.string().optional(),
  f3: z.string().nullable(),
  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),
});
type TestFlattenedErrors = z.inferFlattenedErrors<
  typeof Test,
  { message: string; code: number }
>;
type TestFormErrors = z.inferFormErrors<typeof Test>;

test("default flattened errors type inference", () => {
  type TestTypeErrors = {
    formErrors: string[];
    fieldErrors: { [P in keyof z.TypeOf<typeof Test>]?: string[] | undefined };
  };

  const t1: util.AssertEqual<
    z.TypeOfFlattenedError<typeof Test>,
    TestTypeErrors
  > = true;
  const t2: util.AssertEqual<
    z.TypeOfFlattenedError<typeof Test, { message: string }>,
    TestTypeErrors
  > = false;
  [t1, t2];
});

test("custom flattened errors type inference", () => {
  type ErrorType = { message: string; code: number };
  type TestTypeErrors = {
    formErrors: ErrorType[];
    fieldErrors: {
      [P in keyof z.TypeOf<typeof Test>]?: ErrorType[] | undefined;
    };
  };

  const t1: util.AssertEqual<
    z.TypeOfFlattenedError<typeof Test>,
    TestTypeErrors
  > = false;
  const t2: util.AssertEqual<
    z.TypeOfFlattenedError<typeof Test, { message: string; code: number }>,
    TestTypeErrors
  > = true;
  const t3: util.AssertEqual<
    z.TypeOfFlattenedError<typeof Test, { message: string }>,
    TestTypeErrors
  > = false;
  [t1, t2, t3];
});

test("form errors type inference", () => {
  type TestTypeErrors = {
    formErrors: string[];
    fieldErrors: { [P in keyof z.TypeOf<typeof Test>]?: string[] | undefined };
  };

  const t1: util.AssertEqual<
    z.TypeOfFormErrors<typeof Test>,
    TestTypeErrors
  > = true;
  [t1];
});

test(".flatten() type assertion", () => {
  const parsed = Test.safeParse({}) as z.SafeParseError<void>;
  const validFlattenedErrors: TestFlattenedErrors = parsed.error.flatten(
    () => ({ message: "", code: 0 })
  );
  // @ts-expect-error should fail assertion between `TestFlattenedErrors` and unmapped `flatten()`.
  const invalidFlattenedErrors: TestFlattenedErrors = parsed.error.flatten();
  const validFormErrors: TestFormErrors = parsed.error.flatten();
  // @ts-expect-error should fail assertion between `TestFormErrors` and mapped `flatten()`.
  const invalidFormErrors: TestFormErrors = parsed.error.flatten(() => ({
    message: "string",
    code: 0,
  }));

  [
    validFlattenedErrors,
    invalidFlattenedErrors,
    validFormErrors,
    invalidFormErrors,
  ];
});

test(".formErrors type assertion", () => {
  const parsed = Test.safeParse({}) as z.SafeParseError<void>;
  const validFormErrors: TestFormErrors = parsed.error.formErrors;
  // @ts-expect-error should fail assertion between `TestFlattenedErrors` and `.formErrors`.
  const invalidFlattenedErrors: TestFlattenedErrors = parsed.error.formErrors;

  [validFormErrors, invalidFlattenedErrors];
});

test("all errors", () => {
  const propertySchema = z.string();
  const schema = z
    .object({
      a: propertySchema,
      b: propertySchema,
    })
    .refine(
      (val) => {
        return val.a === val.b;
      },
      { message: "Must be equal" }
    );

  try {
    schema.parse({
      a: "asdf",
      b: "qwer",
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      expect(error.flatten()).toEqual({
        formErrors: ["Must be equal"],
        fieldErrors: {},
      });
    }
  }

  try {
    schema.parse({
      a: null,
      b: null,
    });
  } catch (_error) {
    const error = _error as z.ZodError;
    expect(error.flatten()).toEqual({
      formErrors: [],
      fieldErrors: {
        a: ["Expected string, received null"],
        b: ["Expected string, received null"],
      },
    });

    expect(error.flatten((iss) => iss.message.toUpperCase())).toEqual({
      formErrors: [],
      fieldErrors: {
        a: ["EXPECTED STRING, RECEIVED NULL"],
        b: ["EXPECTED STRING, RECEIVED NULL"],
      },
    });
    // Test identity

    expect(error.flatten((i: z.ZodIssue) => i)).toEqual({
      formErrors: [],
      fieldErrors: {
        a: [
          {
            code: "invalid_type",
            expected: "string",
            message: "Expected string, received null",
            path: ["a"],
            received: "null",
          },
        ],
        b: [
          {
            code: "invalid_type",
            expected: "string",
            message: "Expected string, received null",
            path: ["b"],
            received: "null",
          },
        ],
      },
    });
    // Test mapping
    expect(error.flatten((i: z.ZodIssue) => i.message.length)).toEqual({
      formErrors: [],
      fieldErrors: {
        a: ["Expected string, received null".length],
        b: ["Expected string, received null".length],
      },
    });
  }
});
````

## File: src/__tests__/anyunknown.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

test("check any inference", () => {
  const t1 = z.any();
  t1.optional();
  t1.nullable();
  type t1 = z.infer<typeof t1>;
  const f1: util.AssertEqual<t1, any> = true;
  expect(f1).toBeTruthy();
});

test("check unknown inference", () => {
  const t1 = z.unknown();
  t1.optional();
  t1.nullable();
  type t1 = z.infer<typeof t1>;
  const f1: util.AssertEqual<t1, unknown> = true;
  expect(f1).toBeTruthy();
});

test("check never inference", () => {
  const t1 = z.never();
  expect(() => t1.parse(undefined)).toThrow();
  expect(() => t1.parse("asdf")).toThrow();
  expect(() => t1.parse(null)).toThrow();
});
````

## File: src/__tests__/array.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

const minTwo = z.string().array().min(2);
const maxTwo = z.string().array().max(2);
const justTwo = z.string().array().length(2);
const intNum = z.string().array().nonempty();
const nonEmptyMax = z.string().array().nonempty().max(2);

type t1 = z.infer<typeof nonEmptyMax>;
const f1: util.AssertEqual<[string, ...string[]], t1> = true;
f1;
type t2 = z.infer<typeof minTwo>;
const f2: util.AssertEqual<string[], t2> = true;
f2;

test("passing validations", () => {
  minTwo.parse(["a", "a"]);
  minTwo.parse(["a", "a", "a"]);
  maxTwo.parse(["a", "a"]);
  maxTwo.parse(["a"]);
  justTwo.parse(["a", "a"]);
  intNum.parse(["a"]);
  nonEmptyMax.parse(["a"]);
});

test("failing validations", () => {
  expect(() => minTwo.parse(["a"])).toThrow();
  expect(() => maxTwo.parse(["a", "a", "a"])).toThrow();
  expect(() => justTwo.parse(["a"])).toThrow();
  expect(() => justTwo.parse(["a", "a", "a"])).toThrow();
  expect(() => intNum.parse([])).toThrow();
  expect(() => nonEmptyMax.parse([])).toThrow();
  expect(() => nonEmptyMax.parse(["a", "a", "a"])).toThrow();
});

test("parse empty array in nonempty", () => {
  expect(() =>
    z
      .array(z.string())
      .nonempty()
      .parse([] as any)
  ).toThrow();
});

test("get element", () => {
  justTwo.element.parse("asdf");
  expect(() => justTwo.element.parse(12)).toThrow();
});

test("continue parsing despite array size error", () => {
  const schema = z.object({
    people: z.string().array().min(2),
  });

  const result = schema.safeParse({
    people: [123],
  });
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues.length).toEqual(2);
  }
});
````

## File: src/__tests__/async-parsing.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

/// string
const stringSchema = z.string();

test("string async parse", async () => {
  const goodData = "XXX";
  const badData = 12;

  const goodResult = await stringSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await stringSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// number
const numberSchema = z.number();
test("number async parse", async () => {
  const goodData = 1234.2353;
  const badData = "1234";

  const goodResult = await numberSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await numberSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// bigInt
const bigIntSchema = z.bigint();
test("bigInt async parse", async () => {
  const goodData = BigInt(145);
  const badData = 134;

  const goodResult = await bigIntSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await bigIntSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// boolean
const booleanSchema = z.boolean();
test("boolean async parse", async () => {
  const goodData = true;
  const badData = 1;

  const goodResult = await booleanSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await booleanSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// date
const dateSchema = z.date();
test("date async parse", async () => {
  const goodData = new Date();
  const badData = new Date().toISOString();

  const goodResult = await dateSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await dateSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// undefined
const undefinedSchema = z.undefined();
test("undefined async parse", async () => {
  const goodData = undefined;
  const badData = "XXX";

  const goodResult = await undefinedSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(undefined);

  const badResult = await undefinedSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// null
const nullSchema = z.null();
test("null async parse", async () => {
  const goodData = null;
  const badData = undefined;

  const goodResult = await nullSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await nullSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// any
const anySchema = z.any();
test("any async parse", async () => {
  const goodData = [{}];
  // const badData = 'XXX';

  const goodResult = await anySchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  // const badResult = await anySchema.safeParseAsync(badData);
  // expect(badResult.success).toBe(false);
  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// unknown
const unknownSchema = z.unknown();
test("unknown async parse", async () => {
  const goodData = ["asdf", 124, () => {}];
  // const badData = 'XXX';

  const goodResult = await unknownSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  // const badResult = await unknownSchema.safeParseAsync(badData);
  // expect(badResult.success).toBe(false);
  // if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// void
const voidSchema = z.void();
test("void async parse", async () => {
  const goodData = undefined;
  const badData = 0;

  const goodResult = await voidSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await voidSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// array
const arraySchema = z.array(z.string());
test("array async parse", async () => {
  const goodData = ["XXX"];
  const badData = "XXX";

  const goodResult = await arraySchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await arraySchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// object
const objectSchema = z.object({ string: z.string() });
test("object async parse", async () => {
  const goodData = { string: "XXX" };
  const badData = { string: 12 };

  const goodResult = await objectSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await objectSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// union
const unionSchema = z.union([z.string(), z.undefined()]);
test("union async parse", async () => {
  const goodData = undefined;
  const badData = null;

  const goodResult = await unionSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await unionSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// record
const recordSchema = z.record(z.object({}));
test("record async parse", async () => {
  const goodData = { adsf: {}, asdf: {} };
  const badData = [{}];

  const goodResult = await recordSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await recordSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// function
const functionSchema = z.function();
test("function async parse", async () => {
  const goodData = () => {};
  const badData = "XXX";

  const goodResult = await functionSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(typeof goodResult.data).toEqual("function");

  const badResult = await functionSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// literal
const literalSchema = z.literal("asdf");
test("literal async parse", async () => {
  const goodData = "asdf";
  const badData = "asdff";

  const goodResult = await literalSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await literalSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// enum
const enumSchema = z.enum(["fish", "whale"]);
test("enum async parse", async () => {
  const goodData = "whale";
  const badData = "leopard";

  const goodResult = await enumSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await enumSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// nativeEnum
enum nativeEnumTest {
  asdf = "qwer",
}
// @ts-ignore
const nativeEnumSchema = z.nativeEnum(nativeEnumTest);
test("nativeEnum async parse", async () => {
  const goodData = nativeEnumTest.asdf;
  const badData = "asdf";

  const goodResult = await nativeEnumSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) expect(goodResult.data).toEqual(goodData);

  const badResult = await nativeEnumSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(false);
  if (!badResult.success) expect(badResult.error).toBeInstanceOf(z.ZodError);
});

/// promise
const promiseSchema = z.promise(z.number());
test("promise async parse good", async () => {
  const goodData = Promise.resolve(123);

  const goodResult = await promiseSchema.safeParseAsync(goodData);
  expect(goodResult.success).toBe(true);
  if (goodResult.success) {
    expect(goodResult.data).toBeInstanceOf(Promise);
    const data = await goodResult.data;
    expect(data).toEqual(123);
    // expect(goodResult.data).resolves.toEqual(124);
    // return goodResult.data;
  } else {
    throw new Error("success should be true");
  }
});

test("promise async parse bad", async () => {
  const badData = Promise.resolve("XXX");
  const badResult = await promiseSchema.safeParseAsync(badData);
  expect(badResult.success).toBe(true);
  if (badResult.success) {
    await expect(badResult.data).rejects.toBeInstanceOf(z.ZodError);
  } else {
    throw new Error("success should be true");
  }
});

test("async validation non-empty strings", async () => {
  const base = z.object({
    hello: z.string().refine((x) => x && x.length > 0),
    foo: z.string().refine((x) => x && x.length > 0),
  });

  const testval = { hello: "", foo: "" };
  const result1 = base.safeParse(testval);
  const result2 = base.safeParseAsync(testval);

  const r1 = result1;
  await result2.then((r2) => {
    if (r1.success === false && r2.success === false)
      expect(r1.error.issues.length).toBe(r2.error.issues.length); // <--- r1 has length 2, r2 has length 1
  });
});

test("async validation multiple errors 1", async () => {
  const base = z.object({
    hello: z.string(),
    foo: z.number(),
  });

  const testval = { hello: 3, foo: "hello" };
  const result1 = base.safeParse(testval);
  const result2 = base.safeParseAsync(testval);

  const r1 = result1;
  await result2.then((r2) => {
    if (r1.success === false && r2.success === false)
      expect(r2.error.issues.length).toBe(r1.error.issues.length);
  });
});

test("async validation multiple errors 2", async () => {
  const base = (is_async?: boolean) =>
    z.object({
      hello: z.string(),
      foo: z.object({
        bar: z.number().refine(is_async ? async () => false : () => false),
      }),
    });

  const testval = { hello: 3, foo: { bar: 4 } };
  const result1 = base().safeParse(testval);
  const result2 = base(true).safeParseAsync(testval);

  const r1 = result1;
  await result2.then((r2) => {
    if (r1.success === false && r2.success === false)
      expect(r2.error.issues.length).toBe(r1.error.issues.length);
  });
});

test("ensure early async failure prevents follow-up refinement checks", async () => {
  let count = 0;
  const base = z.object({
    hello: z.string(),
    foo: z
      .number()
      .refine(async () => {
        count++;
        return true;
      })
      .refine(async () => {
        count++;
        return true;
      }, "Good"),
  });

  const testval = { hello: "bye", foo: 3 };
  const result = await base.safeParseAsync(testval);
  if (result.success === false) {
    expect(result.error.issues.length).toBe(1);
    expect(count).toBe(1);
  }

  // await result.then((r) => {
  //   if (r.success === false) expect(r.error.issues.length).toBe(1);
  //   expect(count).toBe(2);
  // });
});
````

## File: src/__tests__/async-refinements.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

test("parse async test", async () => {
  const schema1 = z.string().refine(async (_val) => false);
  expect(() => schema1.parse("asdf")).toThrow();

  const schema2 = z.string().refine((_val) => Promise.resolve(true));
  return await expect(() => schema2.parse("asdf")).toThrow();
});

test("parseAsync async test", async () => {
  const schema1 = z.string().refine(async (_val) => true);
  await schema1.parseAsync("asdf");

  const schema2 = z.string().refine(async (_val) => false);
  return await expect(schema2.parseAsync("asdf")).rejects.toBeDefined();
  // expect(async () => await schema2.parseAsync('asdf')).toThrow();
});

test("parseAsync async test", async () => {
  // expect.assertions(2);

  const schema1 = z.string().refine((_val) => Promise.resolve(true));
  const v1 = await schema1.parseAsync("asdf");
  expect(v1).toEqual("asdf");

  const schema2 = z.string().refine((_val) => Promise.resolve(false));
  await expect(schema2.parseAsync("asdf")).rejects.toBeDefined();

  const schema3 = z.string().refine((_val) => Promise.resolve(true));
  await expect(schema3.parseAsync("asdf")).resolves.toEqual("asdf");
  return await expect(schema3.parseAsync("qwer")).resolves.toEqual("qwer");
});

test("parseAsync async with value", async () => {
  const schema1 = z.string().refine(async (val) => {
    return val.length > 5;
  });
  await expect(schema1.parseAsync("asdf")).rejects.toBeDefined();

  const v = await schema1.parseAsync("asdf123");
  return await expect(v).toEqual("asdf123");
});
````

## File: src/__tests__/base.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

test("type guard", () => {
  const stringToNumber = z.string().transform((arg) => arg.length);

  const s1 = z.object({
    stringToNumber,
  });
  type t1 = z.input<typeof s1>;

  const data: any = "asdf";
  const parsed = s1.safeParse(data);
  if (parsed.success) {
    const f1: util.AssertEqual<typeof data, t1> = true;
    f1;
  }
});

test("test this binding", () => {
  const callback = (predicate: (val: string) => boolean) => {
    return predicate("hello");
  };

  expect(callback((value) => z.string().safeParse(value).success)).toBe(true); // true
  expect(callback((value) => z.string().safeParse(value).success)).toBe(true); // true
});
````

## File: src/__tests__/complex.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { crazySchema } from "./crazySchema";
// import * as z from "../index";

test("parse", () => {
  crazySchema.parse({
    tuple: ["asdf", 1234, true, null, undefined, "1234"],
    merged: { k1: "asdf", k2: 12 },
    union: ["asdf", 12, "asdf", 12, "asdf", 12],
    array: [12, 15, 16],
    // sumTransformer: [12, 15, 16],
    sumMinLength: [12, 15, 16, 98, 24, 63],
    intersection: {},
    enum: "one",
    nonstrict: { points: 1234 },
    numProm: Promise.resolve(12),
    lenfun: (x: string) => x.length,
  });
});
````

## File: src/__tests__/crazySchema.ts
````typescript
import * as z from "../index";

export const crazySchema = z.object({
  tuple: z.tuple([
    z.string().nullable().optional(),
    z.number().nullable().optional(),
    z.boolean().nullable().optional(),
    z.null().nullable().optional(),
    z.undefined().nullable().optional(),
    z.literal("1234").nullable().optional(),
  ]),
  merged: z
    .object({
      k1: z.string().optional(),
    })
    .merge(z.object({ k1: z.string().nullable(), k2: z.number() })),
  union: z.array(z.union([z.literal("asdf"), z.literal(12)])).nonempty(),
  array: z.array(z.number()),
  // sumTransformer: z.transformer(z.array(z.number()), z.number(), (arg) => {
  //   return arg.reduce((a, b) => a + b, 0);
  // }),
  sumMinLength: z.array(z.number()).refine((arg) => arg.length > 5),
  intersection: z.intersection(
    z.object({ p1: z.string().optional() }),
    z.object({ p1: z.number().optional() })
  ),
  enum: z.intersection(z.enum(["zero", "one"]), z.enum(["one", "two"])),
  nonstrict: z.object({ points: z.number() }).nonstrict(),
  numProm: z.promise(z.number()),
  lenfun: z.function(z.tuple([z.string()]), z.boolean()),
});

export const asyncCrazySchema = crazySchema.extend({
  // async_transform: z.transformer(
  //   z.array(z.number()),
  //   z.number(),
  //   async (arg) => {
  //     return arg.reduce((a, b) => a + b, 0);
  //   }
  // ),
  async_refine: z.array(z.number()).refine(async (arg) => arg.length > 5),
});
````

## File: src/__tests__/deepmasking.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

test("test", () => {
  z;
});

// const fish = z.object({
//   name: z.string(),
//   props: z.object({
//     color: z.string(),
//     numScales: z.number(),
//   }),
// });

// const nonStrict = z
//   .object({
//     name: z.string(),
//     color: z.string(),
//   })
//   .nonstrict();

// test('object pick type', () => {
//   const modNonStrictFish = nonStrict.omit({ name: true });
//   modNonStrictFish.parse({ color: 'asdf' });

//   const bad1 = () => fish.pick({ props: { unknown: true } } as any);
//   const bad2 = () => fish.omit({ name: true, props: { unknown: true } } as any);

//   expect(bad1).toThrow();
//   expect(bad2).toThrow();
// });

// test('f1', () => {
//   const f1 = fish.pick(true);
//   f1.parse({ name: 'a', props: { color: 'b', numScales: 3 } });
// });
// test('f2', () => {
//   const f2 = fish.pick({ props: true });
//   f2.parse({ props: { color: 'asdf', numScales: 1 } });
//   const badcheck2 = () => f2.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);
//   expect(badcheck2).toThrow();
// });
// test('f3', () => {
//   const f3 = fish.pick({ props: { color: true } });
//   f3.parse({ props: { color: 'b' } });
//   const badcheck3 = () => f3.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);
//   expect(badcheck3).toThrow();
// });
// test('f4', () => {
//   const badcheck4 = () => fish.pick({ props: { color: true, unknown: true } });
//   expect(badcheck4).toThrow();
// });
// test('f6', () => {
//   const f6 = fish.omit({ props: true });
//   const badcheck6 = () => f6.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);
//   f6.parse({ name: 'adsf' });
//   expect(badcheck6).toThrow();
// });
// test('f7', () => {
//   const f7 = fish.omit({ props: { color: true } });
//   f7.parse({ name: 'a', props: { numScales: 3 } });
//   const badcheck7 = () => f7.parse({ name: 'a', props: { color: 'b', numScales: 3 } } as any);
//   expect(badcheck7).toThrow();
// });
// test('f8', () => {
//   const badcheck8 = () => fish.omit({ props: { color: true, unknown: true } });
//   expect(badcheck8).toThrow();
// });
// test('f9', () => {
//   const f9 = nonStrict.pick(true);
//   f9.parse({ name: 'a', color: 'asdf' });
// });
// test('f10', () => {
//   const f10 = nonStrict.pick({ name: true });
//   f10.parse({ name: 'a' });
//   const val = f10.parse({ name: 'a', color: 'b' });
//   expect(val).toEqual({ name: 'a' });
// });
// test('f12', () => {
//   const badfcheck12 = () => nonStrict.omit({ color: true, asdf: true });
//   expect(badfcheck12).toThrow();
// });

// test('array masking', () => {
//   const fishArray = z.array(fish);
//   const modFishArray = fishArray.pick({
//     name: true,
//     props: {
//       numScales: true,
//     },
//   });

//   modFishArray.parse([{ name: 'fish', props: { numScales: 12 } }]);
//   const bad1 = () => modFishArray.parse([{ name: 'fish', props: { numScales: 12, color: 'asdf' } }] as any);
//   expect(bad1).toThrow();
// });

// test('array masking', () => {
//   const fishArray = z.array(fish);
//   const fail = () =>
//     fishArray.pick({
//       name: true,
//       props: {
//         whatever: true,
//       },
//     } as any);
//   expect(fail).toThrow();
// });

// test('array masking', () => {
//   const fishArray = z.array(fish);
//   const fail = () =>
//     fishArray.omit({
//       whateve: true,
//     } as any);
//   expect(fail).toThrow();
// });

// test('array masking', () => {
//   const fishArray = z.array(fish);
//   const modFishList = fishArray.omit({
//     name: true,
//     props: {
//       color: true,
//     },
//   });

//   modFishList.parse([{ props: { numScales: 12 } }]);
//   const fail = () => modFishList.parse([{ name: 'hello', props: { numScales: 12 } }] as any);
//   expect(fail).toThrow();
// });

// test('primitive array masking', () => {
//   const fishArray = z.array(z.number());
//   const fail = () => fishArray.pick({} as any);
//   expect(fail).toThrow();
// });

// test('other array masking', () => {
//   const fishArray = z.array(z.array(z.number()));
//   const fail = () => fishArray.pick({} as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #1', () => {
//   const fail = () => fish.pick(1 as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #2', () => {
//   const fail = () => fish.pick([] as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #3', () => {
//   const fail = () => fish.pick(false as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #4', () => {
//   const fail = () => fish.pick('asdf' as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #5', () => {
//   const fail = () => fish.omit(1 as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #6', () => {
//   const fail = () => fish.omit([] as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #7', () => {
//   const fail = () => fish.omit(false as any);
//   expect(fail).toThrow();
// });

// test('invalid mask #8', () => {
//   const fail = () => fish.omit('asdf' as any);
//   expect(fail).toThrow();
// });
````

## File: src/__tests__/default.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { z } from "..";
import { util } from "../helpers/util";

test("basic defaults", () => {
  expect(z.string().default("default").parse(undefined)).toBe("default");
});

test("default with transform", () => {
  const stringWithDefault = z
    .string()
    .transform((val) => val.toUpperCase())
    .default("default");
  expect(stringWithDefault.parse(undefined)).toBe("DEFAULT");
  expect(stringWithDefault).toBeInstanceOf(z.ZodDefault);
  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodEffects);
  expect(stringWithDefault._def.innerType._def.schema).toBeInstanceOf(
    z.ZodSchema
  );

  type inp = z.input<typeof stringWithDefault>;
  const f1: util.AssertEqual<inp, string | undefined> = true;
  type out = z.output<typeof stringWithDefault>;
  const f2: util.AssertEqual<out, string> = true;
  f1;
  f2;
});

test("default on existing optional", () => {
  const stringWithDefault = z.string().optional().default("asdf");
  expect(stringWithDefault.parse(undefined)).toBe("asdf");
  expect(stringWithDefault).toBeInstanceOf(z.ZodDefault);
  expect(stringWithDefault._def.innerType).toBeInstanceOf(z.ZodOptional);
  expect(stringWithDefault._def.innerType._def.innerType).toBeInstanceOf(
    z.ZodString
  );

  type inp = z.input<typeof stringWithDefault>;
  const f1: util.AssertEqual<inp, string | undefined> = true;
  type out = z.output<typeof stringWithDefault>;
  const f2: util.AssertEqual<out, string> = true;
  f1;
  f2;
});

test("optional on default", () => {
  const stringWithDefault = z.string().default("asdf").optional();

  type inp = z.input<typeof stringWithDefault>;
  const f1: util.AssertEqual<inp, string | undefined> = true;
  type out = z.output<typeof stringWithDefault>;
  const f2: util.AssertEqual<out, string | undefined> = true;
  f1;
  f2;
});

test("complex chain example", () => {
  const complex = z
    .string()
    .default("asdf")
    .transform((val) => val.toUpperCase())
    .default("qwer")
    .removeDefault()
    .optional()
    .default("asdfasdf");

  expect(complex.parse(undefined)).toBe("ASDFASDF");
});

test("removeDefault", () => {
  const stringWithRemovedDefault = z.string().default("asdf").removeDefault();

  type out = z.output<typeof stringWithRemovedDefault>;
  const f2: util.AssertEqual<out, string> = true;
  f2;
});

test("nested", () => {
  const inner = z.string().default("asdf");
  const outer = z.object({ inner }).default({
    inner: undefined,
  });
  type input = z.input<typeof outer>;
  const f1: util.AssertEqual<
    input,
    { inner?: string | undefined } | undefined
  > = true;
  type out = z.output<typeof outer>;
  const f2: util.AssertEqual<out, { inner: string }> = true;
  f1;
  f2;
  expect(outer.parse(undefined)).toEqual({ inner: "asdf" });
  expect(outer.parse({})).toEqual({ inner: "asdf" });
  expect(outer.parse({ inner: undefined })).toEqual({ inner: "asdf" });
});

test("chained defaults", () => {
  const stringWithDefault = z.string().default("inner").default("outer");
  const result = stringWithDefault.parse(undefined);
  expect(result).toEqual("outer");
});

test("factory", () => {
  z.ZodDefault.create(z.string()).parse(undefined);
});
````

## File: src/__tests__/description.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

test("description", () => {
  const schema: any = z.string();
  const DESC = "asdlfkjasdf";
  expect(schema.describe(DESC).description).toEqual(DESC);
});
````

## File: src/__tests__/discriminatedUnions.test.ts
````typescript
import { expect, test } from "@jest/globals";

import * as z from "../index";

test("valid", () => {
  expect(
    z
      .discriminatedUnion("type", [
        z.object({ type: z.literal("a"), a: z.string() }),
        z.object({ type: z.literal("b"), b: z.string() }),
      ])
      .parse({ type: "a", a: "abc" })
  ).toEqual({ type: "a", a: "abc" });
});

test("valid - discriminator value of various primitive types", () => {
  const schema = z.discriminatedUnion("type", [
    z.object({ type: z.literal("1"), val: z.literal(1) }),
    z.object({ type: z.literal(1), val: z.literal(2) }),
    z.object({ type: z.literal(BigInt(1)), val: z.literal(3) }),
    z.object({ type: z.literal("true"), val: z.literal(4) }),
    z.object({ type: z.literal(true), val: z.literal(5) }),
    z.object({ type: z.literal("null"), val: z.literal(6) }),
    z.object({ type: z.literal(null), val: z.literal(7) }),
    z.object({ type: z.literal("undefined"), val: z.literal(8) }),
    z.object({ type: z.literal(undefined), val: z.literal(9) }),
  ]);

  expect(schema.parse({ type: "1", val: 1 })).toEqual({ type: "1", val: 1 });
  expect(schema.parse({ type: 1, val: 2 })).toEqual({ type: 1, val: 2 });
  expect(schema.parse({ type: BigInt(1), val: 3 })).toEqual({
    type: BigInt(1),
    val: 3,
  });
  expect(schema.parse({ type: "true", val: 4 })).toEqual({
    type: "true",
    val: 4,
  });
  expect(schema.parse({ type: true, val: 5 })).toEqual({
    type: true,
    val: 5,
  });
  expect(schema.parse({ type: "null", val: 6 })).toEqual({
    type: "null",
    val: 6,
  });
  expect(schema.parse({ type: null, val: 7 })).toEqual({
    type: null,
    val: 7,
  });
  expect(schema.parse({ type: "undefined", val: 8 })).toEqual({
    type: "undefined",
    val: 8,
  });
  expect(schema.parse({ type: undefined, val: 9 })).toEqual({
    type: undefined,
    val: 9,
  });
});

test("invalid - null", () => {
  try {
    z.discriminatedUnion("type", [
      z.object({ type: z.literal("a"), a: z.string() }),
      z.object({ type: z.literal("b"), b: z.string() }),
    ]).parse(null);
    throw new Error();
  } catch (e: any) {
    expect(JSON.parse(e.message)).toEqual([
      {
        code: z.ZodIssueCode.invalid_type,
        expected: z.ZodParsedType.object,
        message: "Expected object, received null",
        received: z.ZodParsedType.null,
        path: [],
      },
    ]);
  }
});

test("invalid discriminator value", () => {
  try {
    z.discriminatedUnion("type", [
      z.object({ type: z.literal("a"), a: z.string() }),
      z.object({ type: z.literal("b"), b: z.string() }),
    ]).parse({ type: "x", a: "abc" });
    throw new Error();
  } catch (e: any) {
    expect(JSON.parse(e.message)).toEqual([
      {
        code: z.ZodIssueCode.invalid_union_discriminator,
        options: ["a", "b"],
        message: "Invalid discriminator value. Expected 'a' | 'b'",
        path: ["type"],
      },
    ]);
  }
});

test("valid discriminator value, invalid data", () => {
  try {
    z.discriminatedUnion("type", [
      z.object({ type: z.literal("a"), a: z.string() }),
      z.object({ type: z.literal("b"), b: z.string() }),
    ]).parse({ type: "a", b: "abc" });
    throw new Error();
  } catch (e: any) {
    expect(JSON.parse(e.message)).toEqual([
      {
        code: z.ZodIssueCode.invalid_type,
        expected: z.ZodParsedType.string,
        message: "Required",
        path: ["a"],
        received: z.ZodParsedType.undefined,
      },
    ]);
  }
});

test("wrong schema - missing discriminator", () => {
  try {
    z.discriminatedUnion("type", [
      z.object({ type: z.literal("a"), a: z.string() }),
      z.object({ b: z.string() }) as any,
    ]);
    throw new Error();
  } catch (e: any) {
    expect(e.message).toEqual(
      "The discriminator value could not be extracted from all the provided schemas"
    );
  }
});

test("wrong schema - duplicate discriminator values", () => {
  try {
    z.discriminatedUnion("type", [
      z.object({ type: z.literal("a"), a: z.string() }),
      z.object({ type: z.literal("a"), b: z.string() }),
    ]);
    throw new Error();
  } catch (e: any) {
    expect(e.message).toEqual(
      "Some of the discriminator values are not unique"
    );
  }
});

test("async - valid", async () => {
  expect(
    await z
      .discriminatedUnion("type", [
        z.object({
          type: z.literal("a"),
          a: z
            .string()
            .refine(async () => true)
            .transform(async (val) => Number(val)),
        }),
        z.object({
          type: z.literal("b"),
          b: z.string(),
        }),
      ])
      .parseAsync({ type: "a", a: "1" })
  ).toEqual({ type: "a", a: 1 });
});

test("async - invalid", async () => {
  try {
    await z
      .discriminatedUnion("type", [
        z.object({
          type: z.literal("a"),
          a: z
            .string()
            .refine(async () => true)
            .transform(async (val) => val),
        }),
        z.object({
          type: z.literal("b"),
          b: z.string(),
        }),
      ])
      .parseAsync({ type: "a", a: 1 });
    throw new Error();
  } catch (e: any) {
    expect(JSON.parse(e.message)).toEqual([
      {
        code: "invalid_type",
        expected: "string",
        received: "number",
        path: ["a"],
        message: "Expected string, received number",
      },
    ]);
  }
});
````

## File: src/__tests__/enum.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

test("create enum", () => {
  const MyEnum = z.enum(["Red", "Green", "Blue"]);
  expect(MyEnum.Values.Red).toEqual("Red");
  expect(MyEnum.Enum.Red).toEqual("Red");
  expect(MyEnum.enum.Red).toEqual("Red");
});

test("infer enum", () => {
  const MyEnum = z.enum(["Red", "Green", "Blue"]);
  type MyEnum = z.infer<typeof MyEnum>;
  const t1: util.AssertEqual<MyEnum, "Red" | "Green" | "Blue"> = true;
  [t1];
});

test("get options", () => {
  expect(z.enum(["tuna", "trout"]).options).toEqual(["tuna", "trout"]);
});

test("readonly enum", () => {
  const HTTP_SUCCESS = ["200", "201"] as const;
  const arg = z.enum(HTTP_SUCCESS);
  type arg = z.infer<typeof arg>;
  const f1: util.AssertEqual<arg, "200" | "201"> = true;
  f1;
  arg.parse("201");
  expect(() => arg.parse("202")).toThrow();
});
````

## File: src/__tests__/error.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { ZodParsedType } from "../helpers/parseUtil";
import * as z from "../index";
import { ZodError, ZodIssueCode } from "../ZodError";

test("error creation", () => {
  const err1 = ZodError.create([]);
  err1.addIssue({
    code: ZodIssueCode.invalid_type,
    expected: ZodParsedType.object,
    received: ZodParsedType.string,
    path: [],
    message: "",
  });
  err1.isEmpty;

  const err2 = ZodError.create(err1.issues);
  const err3 = new ZodError([]);
  err3.addIssues(err1.issues);
  err3.addIssue(err1.issues[0]);
  err1.message;
  err2.message;
  err3.message;
});

const errorMap: z.ZodErrorMap = (error, ctx) => {
  if (error.code === ZodIssueCode.invalid_type) {
    if (error.expected === "string") {
      return { message: "bad type!" };
    }
  }
  if (error.code === ZodIssueCode.custom) {
    return { message: `less-than-${(error.params || {}).minimum}` };
  }
  return { message: ctx.defaultError };
};

test("type error with custom error map", () => {
  try {
    z.string().parse(234, { errorMap });
  } catch (err) {
    const zerr: z.ZodError = err as any;

    expect(zerr.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);
    expect(zerr.issues[0].message).toEqual(`bad type!`);
  }
});

test("refinement fail with params", () => {
  try {
    z.number()
      .refine((val) => val >= 3, {
        params: { minimum: 3 },
      })
      .parse(2, { errorMap });
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues[0].code).toEqual(z.ZodIssueCode.custom);
    expect(zerr.issues[0].message).toEqual(`less-than-3`);
  }
});

test("custom error with custom errormap", () => {
  try {
    z.string()
      .refine((val) => val.length > 12, {
        params: { minimum: 13 },
        message: "override",
      })
      .parse("asdf", { errorMap });
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues[0].message).toEqual("override");
  }
});

test("default error message", () => {
  try {
    z.number()
      .refine((x) => x > 3)
      .parse(2);
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues.length).toEqual(1);
    expect(zerr.issues[0].message).toEqual("Invalid input");
  }
});

test("override error in refine", () => {
  try {
    z.number()
      .refine((x) => x > 3, "override")
      .parse(2);
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues.length).toEqual(1);
    expect(zerr.issues[0].message).toEqual("override");
  }
});

test("override error in refinement", () => {
  try {
    z.number()
      .refine((x) => x > 3, {
        message: "override",
      })
      .parse(2);
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues.length).toEqual(1);
    expect(zerr.issues[0].message).toEqual("override");
  }
});

test("array minimum", () => {
  try {
    z.array(z.string()).min(3, "tooshort").parse(["asdf", "qwer"]);
  } catch (err) {
    const zerr: ZodError = err as any;
    expect(zerr.issues[0].code).toEqual(ZodIssueCode.too_small);
    expect(zerr.issues[0].message).toEqual("tooshort");
  }
  try {
    z.array(z.string()).min(3).parse(["asdf", "qwer"]);
  } catch (err) {
    const zerr: ZodError = err as any;
    expect(zerr.issues[0].code).toEqual(ZodIssueCode.too_small);
    expect(zerr.issues[0].message).toEqual(
      `Array must contain at least 3 element(s)`
    );
  }
});

// implement test for semi-smart union logic that checks for type error on either left or right
// test("union smart errors", () => {
//   // expect.assertions(2);

//   const p1 = z
//     .union([z.string(), z.number().refine((x) => x > 0)])
//     .safeParse(-3.2);

//   if (p1.success === true) throw new Error();
//   expect(p1.success).toBe(false);
//   expect(p1.error.issues[0].code).toEqual(ZodIssueCode.custom);

//   const p2 = z.union([z.string(), z.number()]).safeParse(false);
//   // .catch(err => expect(err.issues[0].code).toEqual(ZodIssueCode.invalid_union));
//   if (p2.success === true) throw new Error();
//   expect(p2.success).toBe(false);
//   expect(p2.error.issues[0].code).toEqual(ZodIssueCode.invalid_union);
// });

test("custom path in custom error map", () => {
  const schema = z.object({
    items: z.array(z.string()).refine((data) => data.length > 3, {
      path: ["items-too-few"],
    }),
  });

  const errorMap: z.ZodErrorMap = (error) => {
    expect(error.path.length).toBe(2);
    return { message: "doesnt matter" };
  };
  const result = schema.safeParse({ items: ["first"] }, { errorMap });
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].path).toEqual(["items", "items-too-few"]);
  }
});

test("error metadata from value", () => {
  const dynamicRefine = z.string().refine(
    (val) => val === val.toUpperCase(),
    (val) => ({ params: { val } })
  );

  const result = dynamicRefine.safeParse("asdf");
  expect(result.success).toEqual(false);
  if (!result.success) {
    const sub = result.error.issues[0];
    expect(result.error.issues[0].code).toEqual("custom");
    if (sub.code === "custom") {
      expect(sub.params!.val).toEqual("asdf");
    }
  }
});

// test("don't call refine after validation failed", () => {
//   const asdf = z
//     .union([
//       z.number(),
//       z.string().transform(z.number(), (val) => {
//         return parseFloat(val);
//       }),
//     ])
//     .refine((v) => v >= 1);

//   expect(() => asdf.safeParse("foo")).not.toThrow();
// });

test("root level formatting", () => {
  const schema = z.string().email();
  const result = schema.safeParse("asdfsdf");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.format()._errors).toEqual(["Invalid email"]);
  }
});

test("custom path", () => {
  const schema = z
    .object({
      password: z.string(),
      confirm: z.string(),
    })
    .refine((val) => val.confirm === val.password, { path: ["confirm"] });

  const result = schema.safeParse({
    password: "peanuts",
    confirm: "qeanuts",
  });

  expect(result.success).toEqual(false);
  if (!result.success) {
    // nested errors
    const error = result.error.format();
    expect(error._errors).toEqual([]);
    expect(error.password?._errors).toEqual(undefined);
    expect(error.confirm?._errors).toEqual(["Invalid input"]);
  }
});

test("custom path", () => {
  const schema = z
    .object({
      password: z.string().min(6),
      confirm: z.string().min(6),
    })
    .refine((val) => val.confirm === val.password);

  const result = schema.safeParse({
    password: "qwer",
    confirm: "asdf",
  });

  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues.length).toEqual(3);
  }
});

const schema = z.object({
  inner: z.object({
    name: z
      .string()
      .refine((val) => val.length > 5)
      .array()
      .refine((val) => val.length <= 1),
  }),
});

test("no abort early on refinements", () => {
  const invalidItem = {
    inner: { name: ["aasd", "asdfasdfasfd"] },
  };

  const result1 = schema.safeParse(invalidItem);
  expect(result1.success).toEqual(false);
  if (!result1.success) {
    expect(result1.error.issues.length).toEqual(2);
  }
});
test("formatting", () => {
  const invalidItem = {
    inner: { name: ["aasd", "asdfasdfasfd"] },
  };
  const invalidArray = {
    inner: { name: ["asdfasdf", "asdfasdfasfd"] },
  };
  const result1 = schema.safeParse(invalidItem);
  const result2 = schema.safeParse(invalidArray);

  expect(result1.success).toEqual(false);
  expect(result2.success).toEqual(false);
  if (!result1.success) {
    const error = result1.error.format();

    expect(error._errors).toEqual([]);
    expect(error.inner?._errors).toEqual([]);
    // expect(error.inner?.name?._errors).toEqual(["Invalid input"]);
    // expect(error.inner?.name?.[0]._errors).toEqual(["Invalid input"]);
    expect(error.inner?.name?.[1]).toEqual(undefined);
  }
  if (!result2.success) {
    const error = result2.error.format();
    expect(error._errors).toEqual([]);
    expect(error.inner?._errors).toEqual([]);
    expect(error.inner?.name?._errors).toEqual(["Invalid input"]);
    expect(error.inner?.name?.[0]).toEqual(undefined);
    expect(error.inner?.name?.[1]).toEqual(undefined);
    expect(error.inner?.name?.[2]).toEqual(undefined);
  }
});

const stringWithCustomError = z.string({
  errorMap: (issue, ctx) => ({
    message:
      issue.code === "invalid_type"
        ? ctx.data
          ? "Invalid name"
          : "Name is required"
        : ctx.defaultError,
  }),
});

test("schema-bound error map", () => {
  const result = stringWithCustomError.safeParse(1234);
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].message).toEqual("Invalid name");
  }

  const result2 = stringWithCustomError.safeParse(undefined);
  expect(result2.success).toEqual(false);
  if (!result2.success) {
    expect(result2.error.issues[0].message).toEqual("Name is required");
  }

  // support contextual override
  const result3 = stringWithCustomError.safeParse(undefined, {
    errorMap: () => ({ message: "OVERRIDE" }),
  });
  expect(result3.success).toEqual(false);
  if (!result3.success) {
    expect(result3.error.issues[0].message).toEqual("OVERRIDE");
  }
});

test("overrideErrorMap", () => {
  // support overrideErrorMap
  z.setErrorMap(() => ({ message: "OVERRIDE" }));
  const result4 = stringWithCustomError.min(10).safeParse("tooshort");
  expect(result4.success).toEqual(false);
  if (!result4.success) {
    expect(result4.error.issues[0].message).toEqual("OVERRIDE");
  }
  z.setErrorMap(z.defaultErrorMap);
});

test("invalid and required", () => {
  const str = z.string({
    invalid_type_error: "Invalid name",
    required_error: "Name is required",
  });
  const result1 = str.safeParse(1234);
  expect(result1.success).toEqual(false);
  if (!result1.success) {
    expect(result1.error.issues[0].message).toEqual("Invalid name");
  }
  const result2 = str.safeParse(undefined);
  expect(result2.success).toEqual(false);
  if (!result2.success) {
    expect(result2.error.issues[0].message).toEqual("Name is required");
  }
});

test("Fallback to invalid_type_error without required_error", () => {
  const str = z.string({
    invalid_type_error: "Invalid name",
    // required_error: "Name is required",
  });

  const result2 = str.safeParse(undefined);
  expect(result2.success).toEqual(false);
  if (!result2.success) {
    expect(result2.error.issues[0].message).toEqual("Invalid name");
  }
});

test("invalid and required and errorMap", () => {
  expect(() => {
    return z.string({
      invalid_type_error: "Invalid name",
      required_error: "Name is required",
      errorMap: () => ({ message: "OVERRIDE" }),
    });
  }).toThrow();
});

test("strict error message", () => {
  const errorMsg = "Invalid object";
  const obj = z.object({ x: z.string() }).strict(errorMsg);
  const result = obj.safeParse({ x: "a", y: "b" });
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].message).toEqual(errorMsg);
  }
});

test("enum default error message", () => {
  try {
    z.enum(["Tuna", "Trout"]).parse("Salmon");
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues.length).toEqual(1);
    expect(zerr.issues[0].message).toEqual(
      "Invalid enum value. Expected 'Tuna' | 'Trout'"
    );
    expect(zerr.issues[0].message).not.toContain("Salmon");
  }
});

test("literal default error message", () => {
  try {
    z.literal("Tuna").parse("Trout");
  } catch (err) {
    const zerr: z.ZodError = err as any;
    expect(zerr.issues.length).toEqual(1);
    expect(zerr.issues[0].message).toEqual(
      `Invalid literal value, expected "Tuna"`
    );
  }
});

// test("dont short circuit on continuable errors", () => {
//   const user = z
//     .object({
//       password: z.string().min(6),
//       confirm: z.string(),
//     })
//     .refine((data) => data.password === data.confirm, {
//       message: "Passwords don't match",
//       path: ["confirm"],
//     });
//   const result = user.safeParse({ password: "asdf", confirm: "qwer" });
//   if (!result.success) {
//     expect(result.error.issues.length).toEqual(2);
//   }
// });
````

## File: src/__tests__/firstparty.test.ts
````typescript
import { test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

test("first party switch", () => {
  const myType = z.string() as z.ZodFirstPartySchemaTypes;
  const def = myType._def;

  switch (def.typeName) {
    case z.ZodFirstPartyTypeKind.ZodString:
      break;
    case z.ZodFirstPartyTypeKind.ZodNumber:
      break;
    case z.ZodFirstPartyTypeKind.ZodNaN:
      break;
    case z.ZodFirstPartyTypeKind.ZodBigInt:
      break;
    case z.ZodFirstPartyTypeKind.ZodBoolean:
      break;
    case z.ZodFirstPartyTypeKind.ZodDate:
      break;
    case z.ZodFirstPartyTypeKind.ZodUndefined:
      break;
    case z.ZodFirstPartyTypeKind.ZodNull:
      break;
    case z.ZodFirstPartyTypeKind.ZodAny:
      break;
    case z.ZodFirstPartyTypeKind.ZodUnknown:
      break;
    case z.ZodFirstPartyTypeKind.ZodNever:
      break;
    case z.ZodFirstPartyTypeKind.ZodVoid:
      break;
    case z.ZodFirstPartyTypeKind.ZodArray:
      break;
    case z.ZodFirstPartyTypeKind.ZodObject:
      break;
    case z.ZodFirstPartyTypeKind.ZodUnion:
      break;
    case z.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      break;
    case z.ZodFirstPartyTypeKind.ZodIntersection:
      break;
    case z.ZodFirstPartyTypeKind.ZodTuple:
      break;
    case z.ZodFirstPartyTypeKind.ZodRecord:
      break;
    case z.ZodFirstPartyTypeKind.ZodMap:
      break;
    case z.ZodFirstPartyTypeKind.ZodSet:
      break;
    case z.ZodFirstPartyTypeKind.ZodFunction:
      break;
    case z.ZodFirstPartyTypeKind.ZodLazy:
      break;
    case z.ZodFirstPartyTypeKind.ZodLiteral:
      break;
    case z.ZodFirstPartyTypeKind.ZodEnum:
      break;
    case z.ZodFirstPartyTypeKind.ZodEffects:
      break;
    case z.ZodFirstPartyTypeKind.ZodNativeEnum:
      break;
    case z.ZodFirstPartyTypeKind.ZodOptional:
      break;
    case z.ZodFirstPartyTypeKind.ZodNullable:
      break;
    case z.ZodFirstPartyTypeKind.ZodDefault:
      break;
    case z.ZodFirstPartyTypeKind.ZodPromise:
      break;
    default:
      util.assertNever(def);
  }
});
````

## File: src/__tests__/function.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

const args1 = z.tuple([z.string()]);
const returns1 = z.number();
const func1 = z.function(args1, returns1);

test("function parsing", () => {
  const parsed = func1.parse((arg: any) => arg.length);
  parsed("asdf");
});

test("parsed function fail 1", () => {
  const parsed = func1.parse((x: string) => x);
  expect(() => parsed("asdf")).toThrow();
});

test("parsed function fail 2", () => {
  const parsed = func1.parse((x: string) => x);
  expect(() => parsed(13 as any)).toThrow();
});

test("function inference 1", () => {
  type func1 = z.TypeOf<typeof func1>;
  const t1: util.AssertEqual<func1, (k: string) => number> = true;
  [t1];
});

test("args method", () => {
  const t1 = z.function();
  type t1 = z.infer<typeof t1>;
  const f1: util.AssertEqual<t1, () => void> = true;

  const t2 = t1.args(z.string());
  type t2 = z.infer<typeof t2>;
  const f2: util.AssertEqual<t2, (arg: string) => void> = true;

  const t3 = t2.returns(z.boolean());
  type t3 = z.infer<typeof t3>;
  const f3: util.AssertEqual<t3, (arg: string) => boolean> = true;

  f1;
  f2;
  f3;
});

const args2 = z.tuple([
  z.object({
    f1: z.number(),
    f2: z.string().nullable(),
    f3: z.array(z.boolean().optional()).optional(),
  }),
]);
const returns2 = z.union([z.string(), z.number()]);

const func2 = z.function(args2, returns2);

test("function inference 2", () => {
  type func2 = z.TypeOf<typeof func2>;
  const t2: util.AssertEqual<
    func2,
    (arg: {
      f1: number;
      f2: string | null;
      f3?: (boolean | undefined)[] | undefined;
    }) => string | number
  > = true;
  [t2];
});

test("valid function run", () => {
  const validFunc2Instance = func2.validate((_x) => {
    return "adf" as any;
  });

  const checker = () => {
    validFunc2Instance({
      f1: 21,
      f2: "asdf",
      f3: [true, false],
    });
  };

  checker();
});

test("input validation error", () => {
  const invalidFuncInstance = func2.validate((_x) => {
    return "adf" as any;
  });

  const checker = () => {
    invalidFuncInstance("Invalid_input" as any);
  };

  expect(checker).toThrow();
});

test("output validation error", () => {
  const invalidFuncInstance = func2.validate((_x) => {
    return ["this", "is", "not", "valid", "output"] as any;
  });

  const checker = () => {
    invalidFuncInstance({
      f1: 21,
      f2: "asdf",
      f3: [true, false],
    });
  };

  expect(checker).toThrow();
});

test("special function error codes", () => {
  const checker = z
    .function(z.tuple([z.string()]), z.boolean())
    .implement((arg) => {
      return arg.length as any;
    });
  try {
    checker("12" as any);
  } catch (err) {
    const zerr = err as z.ZodError;
    const first = zerr.issues[0];
    if (first.code !== z.ZodIssueCode.invalid_return_type) throw new Error();

    expect(first.returnTypeError).toBeInstanceOf(z.ZodError);
  }

  try {
    checker(12 as any);
  } catch (err) {
    const zerr = err as z.ZodError;
    const first = zerr.issues[0];
    if (first.code !== z.ZodIssueCode.invalid_arguments) throw new Error();
    expect(first.argumentsError).toBeInstanceOf(z.ZodError);
  }
});

test("function with async refinements", async () => {
  const func = z
    .function()
    .args(z.string().refine(async (val) => val.length > 10))
    .returns(z.promise(z.number().refine(async (val) => val > 10)))
    .implement(async (val) => {
      return val.length;
    });
  const results = [];
  try {
    await func("asdfasdf");
    results.push("success");
  } catch (err) {
    results.push("fail");
  }
  try {
    await func("asdflkjasdflkjsf");
    results.push("success");
  } catch (err) {
    results.push("fail");
  }

  expect(results).toEqual(["fail", "success"]);
});

test("non async function with async refinements should fail", async () => {
  const func = z
    .function()
    .args(z.string().refine(async (val) => val.length > 10))
    .returns(z.number().refine(async (val) => val > 10))
    .implement((val) => {
      return val.length;
    });

  const results = [];
  try {
    await func("asdasdfasdffasdf");
    results.push("success");
  } catch (err) {
    results.push("fail");
  }

  expect(results).toEqual(["fail"]);
});

test("allow extra parameters", () => {
  const maxLength5 = z
    .function()
    .args(z.string())
    .returns(z.boolean())
    .implement((str, _arg, _qewr) => {
      return str.length <= 5;
    });

  const filteredList = [
    "apple",
    "orange",
    "pear",
    "banana",
    "strawberry",
  ].filter(maxLength5);
  expect(filteredList.length).toEqual(2);
});

test("params and returnType getters", () => {
  const func = z.function().args(z.string()).returns(z.string());

  func.parameters().items[0].parse("asdf");
  func.returnType().parse("asdf");
});
````

## File: src/__tests__/instanceof.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

test("instanceof", async () => {
  class Test {}
  class Subtest extends Test {}

  const TestSchema = z.instanceof(Test);
  const SubtestSchema = z.instanceof(Subtest);

  TestSchema.parse(new Test());
  TestSchema.parse(new Subtest());
  SubtestSchema.parse(new Subtest());

  await expect(() => SubtestSchema.parse(new Test())).toThrow(
    /Input not instance of Subtest/
  );
  await expect(() => TestSchema.parse(12)).toThrow(
    /Input not instance of Test/
  );

  const f1: util.AssertEqual<Test, z.infer<typeof TestSchema>> = true;
  expect(f1).toBeTruthy();
});
````

## File: src/__tests__/intersection.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

test("object intersection", () => {
  const BaseTeacher = z.object({
    subjects: z.array(z.string()),
  });
  const HasID = z.object({ id: z.string() });

  const Teacher = z.intersection(BaseTeacher.passthrough(), HasID); // BaseTeacher.merge(HasID);
  const data = {
    subjects: ["math"],
    id: "asdfasdf",
  };
  expect(Teacher.parse(data)).toEqual(data);
  expect(() => Teacher.parse({ subject: data.subjects })).toThrow();
  expect(Teacher.parse({ ...data, extra: 12 })).toEqual({ ...data, extra: 12 });

  expect(() =>
    z.intersection(BaseTeacher.strict(), HasID).parse({ ...data, extra: 12 })
  ).toThrow();
});

test("deep intersection", () => {
  const Animal = z.object({
    properties: z.object({
      is_animal: z.boolean(),
    }),
  });
  const Cat = z
    .object({
      properties: z.object({
        jumped: z.boolean(),
      }),
    })
    .and(Animal);

  type Cat = z.infer<typeof Cat>;
  // const cat:Cat = 'asdf' as any;
  const cat = Cat.parse({ properties: { is_animal: true, jumped: true } });
  expect(cat.properties).toEqual({ is_animal: true, jumped: true });
});

test("deep intersection of arrays", async () => {
  const Author = z.object({
    posts: z.array(
      z.object({
        post_id: z.number(),
      })
    ),
  });
  const Registry = z
    .object({
      posts: z.array(
        z.object({
          title: z.string(),
        })
      ),
    })
    .and(Author);

  const posts = [
    { post_id: 1, title: "Novels" },
    { post_id: 2, title: "Fairy tales" },
  ];
  const cat = Registry.parse({ posts });
  expect(cat.posts).toEqual(posts);
  const asyncCat = await Registry.parseAsync({ posts });
  expect(asyncCat.posts).toEqual(posts);
});

test("invalid intersection types", async () => {
  const numberIntersection = z.intersection(
    z.number(),
    z.number().transform((x) => x + 1)
  );

  const syncResult = numberIntersection.safeParse(1234);
  expect(syncResult.success).toEqual(false);
  if (!syncResult.success) {
    expect(syncResult.error.issues[0].code).toEqual(
      z.ZodIssueCode.invalid_intersection_types
    );
  }

  const asyncResult = await numberIntersection.spa(1234);
  expect(asyncResult.success).toEqual(false);
  if (!asyncResult.success) {
    expect(asyncResult.error.issues[0].code).toEqual(
      z.ZodIssueCode.invalid_intersection_types
    );
  }
});

test("invalid array merge", async () => {
  const stringArrInt = z.intersection(
    z.string().array(),
    z
      .string()
      .array()
      .transform((val) => [...val, "asdf"])
  );
  const syncResult = stringArrInt.safeParse(["asdf", "qwer"]);
  expect(syncResult.success).toEqual(false);
  if (!syncResult.success) {
    expect(syncResult.error.issues[0].code).toEqual(
      z.ZodIssueCode.invalid_intersection_types
    );
  }

  const asyncResult = await stringArrInt.spa(["asdf", "qwer"]);
  expect(asyncResult.success).toEqual(false);
  if (!asyncResult.success) {
    expect(asyncResult.error.issues[0].code).toEqual(
      z.ZodIssueCode.invalid_intersection_types
    );
  }
});
````

## File: src/__tests__/map.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";
import { ZodIssueCode } from "../index";

const stringMap = z.map(z.string(), z.string());
type stringMap = z.infer<typeof stringMap>;

test("type inference", () => {
  const f1: util.AssertEqual<stringMap, Map<string, string>> = true;
  f1;
});

test("valid parse", () => {
  const result = stringMap.safeParse(
    new Map([
      ["first", "foo"],
      ["second", "bar"],
    ])
  );
  expect(result.success).toEqual(true);
  if (result.success) {
    expect(result.data.has("first")).toEqual(true);
    expect(result.data.has("second")).toEqual(true);
    expect(result.data.get("first")).toEqual("foo");
    expect(result.data.get("second")).toEqual("bar");
  }
});

test("valid parse async", async () => {
  const result = await stringMap.spa(
    new Map([
      ["first", "foo"],
      ["second", "bar"],
    ])
  );
  expect(result.success).toEqual(true);
  if (result.success) {
    expect(result.data.has("first")).toEqual(true);
    expect(result.data.has("second")).toEqual(true);
    expect(result.data.get("first")).toEqual("foo");
    expect(result.data.get("second")).toEqual("bar");
  }
});

test("throws when a Set is given", () => {
  const result = stringMap.safeParse(new Set([]));
  expect(result.success).toEqual(false);
  if (result.success === false) {
    expect(result.error.issues.length).toEqual(1);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
  }
});

test("throws when the given map has invalid key and invalid input", () => {
  const result = stringMap.safeParse(new Map([[42, Symbol()]]));
  expect(result.success).toEqual(false);
  if (result.success === false) {
    expect(result.error.issues.length).toEqual(2);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[0].path).toEqual([0, "key"]);
    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[1].path).toEqual([0, "value"]);
  }
});

test("throws when the given map has multiple invalid entries", () => {
  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));

  const result = stringMap.safeParse(
    new Map([
      [1, "foo"],
      ["bar", 2],
    ] as [any, any][]) as Map<any, any>
  );

  // const result = stringMap.safeParse(new Map([[42, Symbol()]]));
  expect(result.success).toEqual(false);
  if (result.success === false) {
    expect(result.error.issues.length).toEqual(2);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[0].path).toEqual([0, "key"]);
    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[1].path).toEqual([1, "value"]);
  }
});

test("dirty", async () => {
  const map = z.map(
    z.string().refine((val) => val === val.toUpperCase(), {
      message: "Keys must be uppercase",
    }),
    z.string()
  );
  const result = await map.spa(
    new Map([
      ["first", "foo"],
      ["second", "bar"],
    ])
  );
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues.length).toEqual(2);
    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);
    expect(result.error.issues[0].message).toEqual("Keys must be uppercase");
    expect(result.error.issues[1].code).toEqual(z.ZodIssueCode.custom);
    expect(result.error.issues[1].message).toEqual("Keys must be uppercase");
  }
});
````

## File: src/__tests__/masking.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

test("masking test", () => {});

test("require", () => {
  const baseSchema = z.object({
    firstName: z.string(),
    middleName: z.string().optional(),
    lastName: z.union([z.undefined(), z.string()]),
    otherName: z.union([z.string(), z.undefined(), z.string()]),
  });
  baseSchema;
  // const reqBase = baseSchema.require();
  // const ewr = reqBase.shape;
  // expect(ewr.firstName).toBeInstanceOf(z.ZodString);
  // expect(ewr.middleName).toBeInstanceOf(z.ZodString);
  // expect(ewr.lastName).toBeInstanceOf(z.ZodString);
  // expect(ewr.otherName).toBeInstanceOf(z.ZodUnion);
});
````

## File: src/__tests__/mocker.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { Mocker } from "./Mocker";

test("mocker", () => {
  const mocker = new Mocker();
  mocker.string;
  mocker.number;
  mocker.boolean;
  mocker.null;
  mocker.undefined;
  mocker.stringOptional;
  mocker.stringNullable;
  mocker.numberOptional;
  mocker.numberNullable;
  mocker.booleanOptional;
  mocker.booleanNullable;
});
````

## File: src/__tests__/Mocker.ts
````typescript
function getRandomInt(max: number) {
  return Math.floor(Math.random() * Math.floor(max));
}

export class Mocker {
  pick = (...args: any[]) => {
    return args[getRandomInt(args.length)];
  };

  get string() {
    return Math.random().toString(36).substring(7);
  }
  get number() {
    return Math.random() * 100;
  }
  get bigint() {
    return BigInt(Math.floor(Math.random() * 10000));
  }
  get boolean() {
    return Math.random() < 0.5;
  }
  get date() {
    return new Date(Math.floor(Date.now() * Math.random()));
  }
  get null(): null {
    return null;
  }
  get undefined(): undefined {
    return undefined;
  }
  get stringOptional() {
    return this.pick(this.string, this.undefined);
  }
  get stringNullable() {
    return this.pick(this.string, this.null);
  }
  get numberOptional() {
    return this.pick(this.number, this.undefined);
  }
  get numberNullable() {
    return this.pick(this.number, this.null);
  }
  get booleanOptional() {
    return this.pick(this.boolean, this.undefined);
  }
  get booleanNullable() {
    return this.pick(this.boolean, this.null);
  }
}
````

## File: src/__tests__/nan.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

const schema = z.nan();

test("passing validations", () => {
  schema.parse(NaN);
  schema.parse(Number("Not a number"));
});

test("failing validations", () => {
  expect(() => schema.parse(5)).toThrow();
  expect(() => schema.parse("John")).toThrow();
  expect(() => schema.parse(true)).toThrow();
  expect(() => schema.parse(null)).toThrow();
  expect(() => schema.parse(undefined)).toThrow();
  expect(() => schema.parse({})).toThrow();
  expect(() => schema.parse([])).toThrow();
});
````

## File: src/__tests__/nativeEnum.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

test("nativeEnum test with consts", () => {
  const Fruits: { Apple: "apple"; Banana: "banana" } = {
    Apple: "apple",
    Banana: "banana",
  };
  const fruitEnum = z.nativeEnum(Fruits);
  type fruitEnum = z.infer<typeof fruitEnum>;
  fruitEnum.parse("apple");
  fruitEnum.parse("banana");
  fruitEnum.parse(Fruits.Apple);
  fruitEnum.parse(Fruits.Banana);
  const t1: util.AssertEqual<fruitEnum, "apple" | "banana"> = true;
  [t1];
});

test("nativeEnum test with real enum", () => {
  enum Fruits {
    Apple = "apple",
    Banana = "banana",
  }
  // @ts-ignore
  const fruitEnum = z.nativeEnum(Fruits);
  type fruitEnum = z.infer<typeof fruitEnum>;
  fruitEnum.parse("apple");
  fruitEnum.parse("banana");
  fruitEnum.parse(Fruits.Apple);
  fruitEnum.parse(Fruits.Banana);
  const t1: util.AssertEqual<fruitEnum, Fruits> = true;
  [t1];
});

test("nativeEnum test with const with numeric keys", () => {
  const FruitValues = {
    Apple: 10,
    Banana: 20,
    // @ts-ignore
  } as const;
  const fruitEnum = z.nativeEnum(FruitValues);
  type fruitEnum = z.infer<typeof fruitEnum>;
  fruitEnum.parse(10);
  fruitEnum.parse(20);
  fruitEnum.parse(FruitValues.Apple);
  fruitEnum.parse(FruitValues.Banana);
  const t1: util.AssertEqual<fruitEnum, 10 | 20> = true;
  [t1];
});

test("from enum", () => {
  enum Fruits {
    Cantaloupe,
    Apple = "apple",
    Banana = "banana",
  }

  const FruitEnum = z.nativeEnum(Fruits as any);
  type FruitEnum = z.infer<typeof FruitEnum>;
  FruitEnum.parse(Fruits.Cantaloupe);
  FruitEnum.parse(Fruits.Apple);
  FruitEnum.parse("apple");
  FruitEnum.parse(0);
  expect(() => FruitEnum.parse(1)).toThrow();
  expect(() => FruitEnum.parse("Apple")).toThrow();
  expect(() => FruitEnum.parse("Cantaloupe")).toThrow();
});

test("from const", () => {
  const Greek = {
    Alpha: "a",
    Beta: "b",
    Gamma: 3,
    // @ts-ignore
  } as const;

  const GreekEnum = z.nativeEnum(Greek);
  type GreekEnum = z.infer<typeof GreekEnum>;
  GreekEnum.parse("a");
  GreekEnum.parse("b");
  GreekEnum.parse(3);
  expect(() => GreekEnum.parse("v")).toThrow();
  expect(() => GreekEnum.parse("Alpha")).toThrow();
  expect(() => GreekEnum.parse(2)).toThrow();

  expect(GreekEnum.enum.Alpha).toEqual("a");
});
````

## File: src/__tests__/nullable.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

function checkErrors(a: z.ZodTypeAny, bad: any) {
  let expected;
  try {
    a.parse(bad);
  } catch (error) {
    expected = (error as z.ZodError).formErrors;
  }
  try {
    a.nullable().parse(bad);
  } catch (error) {
    expect((error as z.ZodError).formErrors).toEqual(expected);
  }
}

test("Should have error messages appropriate for the underlying type", () => {
  checkErrors(z.string().min(2), 1);
  z.string().min(2).nullable().parse(null);
  checkErrors(z.number().gte(2), 1);
  z.number().gte(2).nullable().parse(null);
  checkErrors(z.boolean(), "");
  z.boolean().nullable().parse(null);
  checkErrors(z.null(), null);
  z.null().nullable().parse(null);
  checkErrors(z.null(), {});
  z.null().nullable().parse(null);
  checkErrors(z.object({}), 1);
  z.object({}).nullable().parse(null);
  checkErrors(z.tuple([]), 1);
  z.tuple([]).nullable().parse(null);
  checkErrors(z.unknown(), 1);
  z.unknown().nullable().parse(null);
});

test("unwrap", () => {
  const unwrapped = z.string().nullable().unwrap();
  expect(unwrapped).toBeInstanceOf(z.ZodString);
});
````

## File: src/__tests__/number.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

const gtFive = z.number().gt(5);
const gteFive = z.number().gte(5);
const ltFive = z.number().lt(5);
const lteFive = z.number().lte(5);
const intNum = z.number().int();
const multipleOfFive = z.number().multipleOf(5);
const stepPointOne = z.number().step(0.1);
const stepPointZeroZeroZeroOne = z.number().step(0.0001);
const stepSixPointFour = z.number().step(6.4);

test("passing validations", () => {
  gtFive.parse(6);
  gteFive.parse(5);
  ltFive.parse(4);
  lteFive.parse(5);
  intNum.parse(4);
  multipleOfFive.parse(15);
  stepPointOne.parse(6);
  stepPointOne.parse(6.1);
  stepPointOne.parse(6.1);
  stepSixPointFour.parse(12.8);
  stepPointZeroZeroZeroOne.parse(3.01);
});

test("failing validations", () => {
  expect(() => ltFive.parse(5)).toThrow();
  expect(() => lteFive.parse(6)).toThrow();
  expect(() => gtFive.parse(5)).toThrow();
  expect(() => gteFive.parse(4)).toThrow();
  expect(() => intNum.parse(3.14)).toThrow();
  expect(() => multipleOfFive.parse(14.9)).toThrow();

  expect(() => stepPointOne.parse(6.11)).toThrow();
  expect(() => stepPointOne.parse(6.1000000001)).toThrow();
  expect(() => stepSixPointFour.parse(6.41)).toThrow();
});

test("parse NaN", () => {
  expect(() => z.number().parse(NaN)).toThrow();
});

test("min max getters", () => {
  expect(z.number().int().isInt).toEqual(true);
  expect(z.number().isInt).toEqual(false);

  expect(z.number().min(5).minValue).toEqual(5);
  expect(z.number().min(5).min(10).minValue).toEqual(10);

  expect(z.number().max(5).maxValue).toEqual(5);
  expect(z.number().max(5).max(1).maxValue).toEqual(1);
});
````

## File: src/__tests__/object-augmentation.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

test("object augmentation", () => {
  const Animal = z
    .object({
      species: z.string(),
    })
    .augment({
      population: z.number(),
    });
  // overwrites `species`
  const ModifiedAnimal = Animal.augment({
    species: z.array(z.string()),
  });
  ModifiedAnimal.parse({
    species: ["asd"],
    population: 1324,
  });

  const bad = () =>
    ModifiedAnimal.parse({
      species: "asdf",
      population: 1324,
    } as any);
  expect(bad).toThrow();
});
````

## File: src/__tests__/object-in-es5-env.test.ts
````typescript
import { expect, test } from "@jest/globals";

import * as z from "../index";

const RealSet = Set;
const RealMap = Map;
const RealDate = Date;

test("doesn’t throw when Date is undefined", () => {
  delete (globalThis as any).Date;
  const result = z.object({}).safeParse({});
  expect(result.success).toEqual(true);
  globalThis.Date = RealDate;
});

test("doesn’t throw when Set is undefined", () => {
  delete (globalThis as any).Set;
  const result = z.object({}).safeParse({});
  expect(result.success).toEqual(true);
  globalThis.Set = RealSet;
});

test("doesn’t throw when Map is undefined", () => {
  delete (globalThis as any).Map;
  const result = z.object({}).safeParse({});
  expect(result.success).toEqual(true);
  globalThis.Map = RealMap;
});
````

## File: src/__tests__/object.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

const Test = z.object({
  f1: z.number(),
  f2: z.string().optional(),
  f3: z.string().nullable(),
  f4: z.array(z.object({ t: z.union([z.string(), z.boolean()]) })),
});
type Test = z.infer<typeof Test>;

test("object type inference", () => {
  type TestType = {
    f1: number;
    f2?: string | undefined;
    f3: string | null;
    f4: { t: string | boolean }[];
  };

  const t1: util.AssertEqual<z.TypeOf<typeof Test>, TestType> = true;
  [t1];
});

test("unknown throw", () => {
  const asdf: unknown = 35;
  expect(() => Test.parse(asdf)).toThrow();
});

test("correct parsing", () => {
  Test.parse({
    f1: 12,
    f2: "string",
    f3: "string",
    f4: [
      {
        t: "string",
      },
    ],
  });

  Test.parse({
    f1: 12,
    f3: null,
    f4: [
      {
        t: false,
      },
    ],
  });
});

test("incorrect #1", () => {
  expect(() => Test.parse({} as any)).toThrow();
});

test("nonstrict by default", () => {
  z.object({ points: z.number() }).parse({
    points: 2314,
    unknown: "asdf",
  });
});

const data = {
  points: 2314,
  unknown: "asdf",
};

test("strip by default", () => {
  const val = z.object({ points: z.number() }).parse(data);
  expect(val).toEqual({ points: 2314 });
});

test("unknownkeys override", () => {
  const val = z
    .object({ points: z.number() })
    .strict()
    .passthrough()
    .strip()
    .nonstrict()
    .parse(data);

  expect(val).toEqual(data);
});

test("passthrough unknown", () => {
  const val = z.object({ points: z.number() }).passthrough().parse(data);

  expect(val).toEqual(data);
});

test("strip unknown", () => {
  const val = z.object({ points: z.number() }).strip().parse(data);

  expect(val).toEqual({ points: 2314 });
});

test("strict", () => {
  const val = z.object({ points: z.number() }).strict().safeParse(data);

  expect(val.success).toEqual(false);
});

test("catchall inference", () => {
  const o1 = z
    .object({
      first: z.string(),
    })
    .catchall(z.number());

  const d1 = o1.parse({ first: "asdf", num: 1243 });
  const f1: util.AssertEqual<number, typeof d1["asdf"]> = true;
  const f2: util.AssertEqual<string, typeof d1["first"]> = true;
  f1;
  f2;
});

test("catchall overrides strict", () => {
  const o1 = z
    .object({ first: z.string().optional() })
    .strict()
    .catchall(z.number());

  // should run fine
  // setting a catchall overrides the unknownKeys behavior
  o1.parse({
    asdf: 1234,
  });

  // should only run catchall validation
  // against unknown keys
  o1.parse({
    first: "asdf",
    asdf: 1234,
  });
});

test("catchall overrides strict", () => {
  const o1 = z
    .object({
      first: z.string(),
    })
    .strict()
    .catchall(z.number());

  // should run fine
  // setting a catchall overrides the unknownKeys behavior
  o1.parse({
    first: "asdf",
    asdf: 1234,
  });
});

test("test that optional keys are unset", async () => {
  const SNamedEntity = z.object({
    id: z.string(),
    set: z.string().optional(),
    unset: z.string().optional(),
  });
  const result = await SNamedEntity.parse({
    id: "asdf",
    set: undefined,
  });
  // eslint-disable-next-line ban/ban
  expect(Object.keys(result)).toEqual(["id", "set"]);
});

test("test catchall parsing", async () => {
  const result = z
    .object({ name: z.string() })
    .catchall(z.number())
    .parse({ name: "Foo", validExtraKey: 61 });

  expect(result).toEqual({ name: "Foo", validExtraKey: 61 });

  const result2 = z
    .object({ name: z.string() })
    .catchall(z.number())
    .safeParse({ name: "Foo", validExtraKey: 61, invalid: "asdf" });

  expect(result2.success).toEqual(false);
});

test("test nonexistent keys", async () => {
  const Schema = z.union([
    z.object({ a: z.string() }),
    z.object({ b: z.number() }),
  ]);
  const obj = { a: "A" };
  const result = await Schema.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21
  expect(result.success).toBe(true);
});

test("test async union", async () => {
  const Schema2 = z.union([
    z.object({
      ty: z.string(),
    }),
    z.object({
      ty: z.number(),
    }),
  ]);

  const obj = { ty: "A" };
  const result = await Schema2.spa(obj); // Works with 1.11.10, breaks with 2.0.0-beta.21
  expect(result.success).toEqual(true);
});

test("test inferred merged type", async () => {
  const asdf = z.object({ a: z.string() }).merge(z.object({ a: z.number() }));
  type asdf = z.infer<typeof asdf>;
  const f1: util.AssertEqual<asdf, { a: number }> = true;
  f1;
});

test("inferred type for unknown/any keys", () => {
  const myType = z.object({
    anyOptional: z.any().optional(),
    anyRequired: z.any(),
    unknownOptional: z.unknown().optional(),
    unknownRequired: z.unknown(),
  });
  type myType = z.infer<typeof myType>;
  const _f1: util.AssertEqual<
    myType,
    {
      anyOptional?: any;
      anyRequired?: any;
      unknownOptional?: unknown;
      unknownRequired?: unknown;
    }
  > = true;
  _f1;
});

test("setKey", () => {
  const base = z.object({ name: z.string() });
  const withNewKey = base.setKey("age", z.number());

  type withNewKey = z.infer<typeof withNewKey>;
  const _t1: util.AssertEqual<withNewKey, { name: string; age: number }> = true;
  _t1;
  withNewKey.parse({ name: "asdf", age: 1234 });
});

test("strictcreate", async () => {
  const strictObj = z.strictObject({
    name: z.string(),
  });

  const syncResult = strictObj.safeParse({ name: "asdf", unexpected: 13 });
  expect(syncResult.success).toEqual(false);

  const asyncResult = await strictObj.spa({ name: "asdf", unexpected: 13 });
  expect(asyncResult.success).toEqual(false);
});

test("object with refine", async () => {
  const schema = z
    .object({
      a: z.string().default("foo"),
      b: z.number(),
    })
    .refine(() => true);
  expect(schema.parse({ b: 5 })).toEqual({ b: 5, a: "foo" });
  const result = await schema.parseAsync({ b: 5 });
  expect(result).toEqual({ b: 5, a: "foo" });
});

test("intersection of object with date", async () => {
  const schema = z.object({
    a: z.date(),
  });
  expect(schema.and(schema).parse({ a: new Date(1637353595983) })).toEqual({
    a: new Date(1637353595983),
  });
  const result = await schema.parseAsync({ a: new Date(1637353595983) });
  expect(result).toEqual({ a: new Date(1637353595983) });
});

test("intersection of object with refine with date", async () => {
  const schema = z
    .object({
      a: z.date(),
    })
    .refine(() => true);
  expect(schema.and(schema).parse({ a: new Date(1637353595983) })).toEqual({
    a: new Date(1637353595983),
  });
  const result = await schema.parseAsync({ a: new Date(1637353595983) });
  expect(result).toEqual({ a: new Date(1637353595983) });
});

test("constructor key", () => {
  const person = z
    .object({
      name: z.string(),
    })
    .strict();

  expect(() =>
    person.parse({
      name: "bob dylan",
      constructor: 61,
    })
  ).toThrow();
});
````

## File: src/__tests__/optional.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

function checkErrors(a: z.ZodTypeAny, bad: any) {
  let expected;
  try {
    a.parse(bad);
  } catch (error) {
    expected = (error as z.ZodError).formErrors;
  }
  try {
    a.optional().parse(bad);
  } catch (error) {
    expect((error as z.ZodError).formErrors).toEqual(expected);
  }
}

test("Should have error messages appropriate for the underlying type", () => {
  checkErrors(z.string().min(2), 1);
  z.string().min(2).optional().parse(undefined);
  checkErrors(z.number().gte(2), 1);
  z.number().gte(2).optional().parse(undefined);
  checkErrors(z.boolean(), "");
  z.boolean().optional().parse(undefined);
  checkErrors(z.undefined(), null);
  z.undefined().optional().parse(undefined);
  checkErrors(z.null(), {});
  z.null().optional().parse(undefined);
  checkErrors(z.object({}), 1);
  z.object({}).optional().parse(undefined);
  checkErrors(z.tuple([]), 1);
  z.tuple([]).optional().parse(undefined);
  checkErrors(z.unknown(), 1);
  z.unknown().optional().parse(undefined);
});

test("unwrap", () => {
  const unwrapped = z.string().optional().unwrap();
  expect(unwrapped).toBeInstanceOf(z.ZodString);
});
````

## File: src/__tests__/parser.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

test("parse strict object with unknown keys", () => {
  expect(() =>
    z
      .object({ name: z.string() })
      .strict()
      .parse({ name: "bill", unknownKey: 12 } as any)
  ).toThrow();
});

test("parse nonstrict object with unknown keys", () => {
  z.object({ name: z.string() })
    .nonstrict()
    .parse({ name: "bill", unknownKey: 12 });
});

test("invalid left side of intersection", () => {
  expect(() =>
    z.intersection(z.string(), z.number()).parse(12 as any)
  ).toThrow();
});

test("invalid right side of intersection", () => {
  expect(() =>
    z.intersection(z.string(), z.number()).parse("12" as any)
  ).toThrow();
});

test("parsing non-array in tuple schema", () => {
  expect(() => z.tuple([]).parse("12" as any)).toThrow();
});

test("incorrect num elements in tuple", () => {
  expect(() => z.tuple([]).parse(["asdf"] as any)).toThrow();
});

test("invalid enum value", () => {
  expect(() => z.enum(["Blue"]).parse("Red" as any)).toThrow();
});

test("parsing unknown", () => {
  z.string().parse("Red" as unknown);
});
````

## File: src/__tests__/parseUtil.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import {
  isAborted,
  isDirty,
  isValid,
  SyncParseReturnType,
} from "../helpers/parseUtil";

test("parseUtil isInvalid should use structural typing", () => {
  // Test for issue #556: https://github.com/colinhacks/zod/issues/556
  const aborted: SyncParseReturnType = { status: "aborted" };
  const dirty: SyncParseReturnType = { status: "dirty", value: "whatever" };
  const valid: SyncParseReturnType = { status: "valid", value: "whatever" };

  expect(isAborted(aborted)).toBe(true);
  expect(isAborted(dirty)).toBe(false);
  expect(isAborted(valid)).toBe(false);

  expect(isDirty(aborted)).toBe(false);
  expect(isDirty(dirty)).toBe(true);
  expect(isDirty(valid)).toBe(false);

  expect(isValid(aborted)).toBe(false);
  expect(isValid(dirty)).toBe(false);
  expect(isValid(valid)).toBe(true);
});
````

## File: src/__tests__/partials.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";
import { ZodNullable, ZodOptional } from "../index";

const nested = z.object({
  name: z.string(),
  age: z.number(),
  outer: z.object({
    inner: z.string(),
  }),
  array: z.array(z.object({ asdf: z.string() })),
});

test("shallow inference", () => {
  const shallow = nested.partial();
  type shallow = z.infer<typeof shallow>;
  type correct = {
    name?: string | undefined;
    age?: number | undefined;
    outer?: { inner: string } | undefined;
    array?: { asdf: string }[];
  };
  const t1: util.AssertEqual<shallow, correct> = true;
  t1;
});

test("shallow partial parse", () => {
  const shallow = nested.partial();
  shallow.parse({});
  shallow.parse({
    name: "asdf",
    age: 23143,
  });
});

test("deep partial inference", () => {
  const deep = nested.deepPartial();
  const asdf = deep.shape.array.unwrap().element.shape.asdf.unwrap();
  asdf.parse("asdf");
  type deep = z.infer<typeof deep>;
  type correct = {
    array?: { asdf?: string }[];
    name?: string | undefined;
    age?: number | undefined;
    outer?: { inner?: string | undefined } | undefined;
  };

  const t1: util.AssertEqual<deep, correct> = true;
  t1;
});

test("deep partial parse", () => {
  const deep = nested.deepPartial();

  expect(deep.shape.name instanceof z.ZodOptional).toBe(true);
  expect(deep.shape.outer instanceof z.ZodOptional).toBe(true);
  expect(deep.shape.outer._def.innerType instanceof z.ZodObject).toBe(true);
  expect(
    deep.shape.outer._def.innerType.shape.inner instanceof z.ZodOptional
  ).toBe(true);
  expect(
    deep.shape.outer._def.innerType.shape.inner._def.innerType instanceof
      z.ZodString
  ).toBe(true);
});

test("deep partial runtime tests", () => {
  const deep = nested.deepPartial();
  deep.parse({});
  deep.parse({
    outer: {},
  });
  deep.parse({
    name: "asdf",
    age: 23143,
    outer: {
      inner: "adsf",
    },
  });
});

test("deep partial optional/nullable", () => {
  const schema = z
    .object({
      name: z.string().optional(),
      age: z.number().nullable(),
    })
    .deepPartial();

  expect(schema.shape.name.unwrap()).toBeInstanceOf(ZodOptional);
  expect(schema.shape.age.unwrap()).toBeInstanceOf(ZodNullable);
});

test("deep partial tuple", () => {
  const schema = z
    .object({
      tuple: z.tuple([
        z.object({
          name: z.string().optional(),
          age: z.number().nullable(),
        }),
      ]),
    })
    .deepPartial();

  expect(schema.shape.tuple.unwrap().items[0].shape.name).toBeInstanceOf(
    ZodOptional
  );
});

test("deep partial inference", () => {
  const mySchema = z.object({
    name: z.string(),
    array: z.array(z.object({ asdf: z.string() })),
    tuple: z.tuple([z.object({ value: z.string() })]),
  });

  const partialed = mySchema.deepPartial();
  type partialed = z.infer<typeof partialed>;
  type expected = {
    name?: string | undefined;
    array?:
      | {
          asdf?: string | undefined;
        }[]
      | undefined;
    tuple?: [{ value?: string }] | undefined;
  };
  const f1: util.AssertEqual<expected, partialed> = true;
  f1;
});

test("required", () => {
  const object = z.object({
    name: z.string(),
    age: z.number().optional(),
    field: z.string().optional().default("asdf"),
  });

  const requiredObject = object.required();
  expect(requiredObject.shape.name).toBeInstanceOf(z.ZodString);
  expect(requiredObject.shape.age).toBeInstanceOf(z.ZodNumber);
  expect(requiredObject.shape.field).toBeInstanceOf(z.ZodDefault);
});

test("with mask", async () => {
  const object = z.object({
    name: z.string(),
    age: z.number().optional(),
    field: z.string().optional().default("asdf"),
  });

  const masked = object
    .partial({
      name: true,
      age: true,
      field: true,
    })
    .strict();

  masked.parse({});
  await masked.parseAsync({});
});
````

## File: src/__tests__/pickomit.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

const fish = z.object({
  name: z.string(),
  age: z.number(),
  nested: z.object({}),
});

test("pick type inference", () => {
  const nameonlyFish = fish.pick({ name: true });
  type nameonlyFish = z.infer<typeof nameonlyFish>;
  const f1: util.AssertEqual<nameonlyFish, { name: string }> = true;
  f1;
});

test("pick parse - success", () => {
  const nameonlyFish = fish.pick({ name: true });
  nameonlyFish.parse({ name: "bob" });
});

test("pick parse - fail", () => {
  fish.pick({ name: true }).parse({ name: "12" } as any);
  fish.pick({ name: true }).parse({ name: "bob", age: 12 } as any);
  fish.pick({ age: true }).parse({ age: 12 } as any);

  const nameonlyFish = fish.pick({ name: true }).strict();
  const bad1 = () => nameonlyFish.parse({ name: 12 } as any);
  const bad2 = () => nameonlyFish.parse({ name: "bob", age: 12 } as any);
  const bad3 = () => nameonlyFish.parse({ age: 12 } as any);

  expect(bad1).toThrow();
  expect(bad2).toThrow();
  expect(bad3).toThrow();
});

test("omit type inference", () => {
  const nonameFish = fish.omit({ name: true });
  type nonameFish = z.infer<typeof nonameFish>;
  const f1: util.AssertEqual<nonameFish, { age: number; nested: {} }> = true;
  f1;
});

test("omit parse - success", () => {
  const nonameFish = fish.omit({ name: true });
  nonameFish.parse({ age: 12, nested: {} });
});

test("omit parse - fail", () => {
  const nonameFish = fish.omit({ name: true });
  const bad1 = () => nonameFish.parse({ name: 12 } as any);
  const bad2 = () => nonameFish.parse({ age: 12 } as any);
  const bad3 = () => nonameFish.parse({} as any);

  expect(bad1).toThrow();
  expect(bad2).toThrow();
  expect(bad3).toThrow();
});

test("nonstrict inference", () => {
  const laxfish = fish.nonstrict().pick({ name: true });
  type laxfish = z.infer<typeof laxfish>;
  const f1: util.AssertEqual<laxfish, { [k: string]: any; name: string }> =
    true;
  f1;
});

test("nonstrict parsing - pass", () => {
  const laxfish = fish.nonstrict().pick({ name: true });
  laxfish.parse({ name: "asdf", whatever: "asdf" });
  laxfish.parse({ name: "asdf", age: 12, nested: {} });
});

test("nonstrict parsing - fail", () => {
  const laxfish = fish.nonstrict().pick({ name: true });
  const bad = () => laxfish.parse({ whatever: "asdf" } as any);
  expect(bad).toThrow();
});
````

## File: src/__tests__/primitive.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";
import { Mocker } from "./Mocker";

const literalStringSchema = z.literal("asdf");
const literalNumberSchema = z.literal(12);
const literalBooleanSchema = z.literal(true);
const stringSchema = z.string();
const numberSchema = z.number();
const bigintSchema = z.bigint();
const booleanSchema = z.boolean();
const dateSchema = z.date();
const nullSchema = z.null();
const undefinedSchema = z.undefined();
const stringSchemaOptional = z.string().optional();
const stringSchemaNullable = z.string().nullable();
const numberSchemaOptional = z.number().optional();
const numberSchemaNullable = z.number().nullable();
const bigintSchemaOptional = z.bigint().optional();
const bigintSchemaNullable = z.bigint().nullable();
const booleanSchemaOptional = z.boolean().optional();
const booleanSchemaNullable = z.boolean().nullable();
const dateSchemaOptional = z.date().optional();
const dateSchemaNullable = z.date().nullable();

const val = new Mocker();

test("literal string correct", () => {
  expect(literalStringSchema.parse("asdf")).toBe("asdf");
});

test("literal string incorrect", () => {
  const f = () => literalStringSchema.parse("not_asdf");
  expect(f).toThrow();
});

test("literal string number", () => {
  const f = () => literalStringSchema.parse(123);
  expect(f).toThrow();
});

test("literal string boolean", () => {
  const f = () => literalStringSchema.parse(true);
  expect(f).toThrow();
});

test("literal string boolean", () => {
  const f = () => literalStringSchema.parse(true);
  expect(f).toThrow();
});

test("literal string object", () => {
  const f = () => literalStringSchema.parse({});
  expect(f).toThrow();
});

test("literal number correct", () => {
  expect(literalNumberSchema.parse(12)).toBe(12);
});

test("literal number incorrect", () => {
  const f = () => literalNumberSchema.parse(13);
  expect(f).toThrow();
});

test("literal number number", () => {
  const f = () => literalNumberSchema.parse(val.string);
  expect(f).toThrow();
});

test("literal number boolean", () => {
  const f = () => literalNumberSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("literal number object", () => {
  const f = () => literalStringSchema.parse({});
  expect(f).toThrow();
});

test("literal boolean correct", () => {
  expect(literalBooleanSchema.parse(true)).toBe(true);
});

test("literal boolean incorrect", () => {
  const f = () => literalBooleanSchema.parse(false);
  expect(f).toThrow();
});

test("literal boolean number", () => {
  const f = () => literalBooleanSchema.parse("asdf");
  expect(f).toThrow();
});

test("literal boolean boolean", () => {
  const f = () => literalBooleanSchema.parse(123);
  expect(f).toThrow();
});

test("literal boolean object", () => {
  const f = () => literalBooleanSchema.parse({});
  expect(f).toThrow();
});

test("parse stringSchema string", () => {
  stringSchema.parse(val.string);
});

test("parse stringSchema number", () => {
  const f = () => stringSchema.parse(val.number);
  expect(f).toThrow();
});

test("parse stringSchema boolean", () => {
  const f = () => stringSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("parse stringSchema undefined", () => {
  const f = () => stringSchema.parse(val.undefined);
  expect(f).toThrow();
});

test("parse stringSchema null", () => {
  const f = () => stringSchema.parse(val.null);
  expect(f).toThrow();
});

test("parse numberSchema string", () => {
  const f = () => numberSchema.parse(val.string);
  expect(f).toThrow();
});

test("parse numberSchema number", () => {
  numberSchema.parse(val.number);
});

test("parse numberSchema bigint", () => {
  const f = () => numberSchema.parse(val.bigint);
  expect(f).toThrow();
});

test("parse numberSchema boolean", () => {
  const f = () => numberSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("parse numberSchema undefined", () => {
  const f = () => numberSchema.parse(val.undefined);
  expect(f).toThrow();
});

test("parse numberSchema null", () => {
  const f = () => numberSchema.parse(val.null);
  expect(f).toThrow();
});

test("parse bigintSchema string", () => {
  const f = () => bigintSchema.parse(val.string);
  expect(f).toThrow();
});

test("parse bigintSchema number", () => {
  const f = () => bigintSchema.parse(val.number);
  expect(f).toThrow();
});

test("parse bigintSchema bigint", () => {
  bigintSchema.parse(val.bigint);
});

test("parse bigintSchema boolean", () => {
  const f = () => bigintSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("parse bigintSchema undefined", () => {
  const f = () => bigintSchema.parse(val.undefined);
  expect(f).toThrow();
});

test("parse bigintSchema null", () => {
  const f = () => bigintSchema.parse(val.null);
  expect(f).toThrow();
});

test("parse booleanSchema string", () => {
  const f = () => booleanSchema.parse(val.string);
  expect(f).toThrow();
});

test("parse booleanSchema number", () => {
  const f = () => booleanSchema.parse(val.number);
  expect(f).toThrow();
});

test("parse booleanSchema boolean", () => {
  booleanSchema.parse(val.boolean);
});

test("parse booleanSchema undefined", () => {
  const f = () => booleanSchema.parse(val.undefined);
  expect(f).toThrow();
});

test("parse booleanSchema null", () => {
  const f = () => booleanSchema.parse(val.null);
  expect(f).toThrow();
});

// ==============

test("parse dateSchema string", () => {
  const f = () => dateSchema.parse(val.string);
  expect(f).toThrow();
});

test("parse dateSchema number", () => {
  const f = () => dateSchema.parse(val.number);
  expect(f).toThrow();
});

test("parse dateSchema boolean", () => {
  const f = () => dateSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("parse dateSchema date", () => {
  dateSchema.parse(val.date);
});

test("parse dateSchema undefined", () => {
  const f = () => dateSchema.parse(val.undefined);
  expect(f).toThrow();
});

test("parse dateSchema null", () => {
  const f = () => dateSchema.parse(val.null);
  expect(f).toThrow();
});

test("parse dateSchema invalid date", async () => {
  try {
    await dateSchema.parseAsync(new Date("invalid"));
  } catch (err) {
    expect((err as z.ZodError).issues[0].code).toEqual(
      z.ZodIssueCode.invalid_date
    );
  }
});
// ==============

test("parse undefinedSchema string", () => {
  const f = () => undefinedSchema.parse(val.string);
  expect(f).toThrow();
});

test("parse undefinedSchema number", () => {
  const f = () => undefinedSchema.parse(val.number);
  expect(f).toThrow();
});

test("parse undefinedSchema boolean", () => {
  const f = () => undefinedSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("parse undefinedSchema undefined", () => {
  undefinedSchema.parse(val.undefined);
});

test("parse undefinedSchema null", () => {
  const f = () => undefinedSchema.parse(val.null);
  expect(f).toThrow();
});

test("parse nullSchema string", () => {
  const f = () => nullSchema.parse(val.string);
  expect(f).toThrow();
});

test("parse nullSchema number", () => {
  const f = () => nullSchema.parse(val.number);
  expect(f).toThrow();
});

test("parse nullSchema boolean", () => {
  const f = () => nullSchema.parse(val.boolean);
  expect(f).toThrow();
});

test("parse nullSchema undefined", () => {
  const f = () => nullSchema.parse(val.undefined);
  expect(f).toThrow();
});

test("parse nullSchema null", () => {
  nullSchema.parse(val.null);
});

export type AssertEqualTest = boolean | undefined extends true
  ? true extends boolean | undefined
    ? true
    : never
  : never;

type AssertEqual<X, Y> = (<T>() => T extends X ? 1 : 2) extends <
  T
>() => T extends Y ? 1 : 2
  ? true
  : never;

test("primitive inference", () => {
  const literalStringSchemaTest: AssertEqual<
    z.TypeOf<typeof literalStringSchema>,
    "asdf"
  > = true;
  const literalNumberSchemaTest: AssertEqual<
    z.TypeOf<typeof literalNumberSchema>,
    12
  > = true;
  const literalBooleanSchemaTest: AssertEqual<
    z.TypeOf<typeof literalBooleanSchema>,
    true
  > = true;
  const stringSchemaTest: AssertEqual<
    z.TypeOf<typeof stringSchema>,
    string
  > = true;
  const numberSchemaTest: AssertEqual<
    z.TypeOf<typeof numberSchema>,
    number
  > = true;
  const bigintSchemaTest: AssertEqual<
    z.TypeOf<typeof bigintSchema>,
    bigint
  > = true;
  const booleanSchemaTest: AssertEqual<
    z.TypeOf<typeof booleanSchema>,
    boolean
  > = true;
  const dateSchemaTest: AssertEqual<z.TypeOf<typeof dateSchema>, Date> = true;
  const nullSchemaTest: AssertEqual<z.TypeOf<typeof nullSchema>, null> = true;
  const undefinedSchemaTest: AssertEqual<
    z.TypeOf<typeof undefinedSchema>,
    undefined
  > = true;
  const stringSchemaOptionalTest: AssertEqual<
    z.TypeOf<typeof stringSchemaOptional>,
    string | undefined
  > = true;
  const stringSchemaNullableTest: AssertEqual<
    z.TypeOf<typeof stringSchemaNullable>,
    string | null
  > = true;
  const numberSchemaOptionalTest: AssertEqual<
    z.TypeOf<typeof numberSchemaOptional>,
    number | undefined
  > = true;
  const numberSchemaNullableTest: AssertEqual<
    z.TypeOf<typeof numberSchemaNullable>,
    number | null
  > = true;
  const bigintSchemaOptionalTest: AssertEqual<
    z.TypeOf<typeof bigintSchemaOptional>,
    bigint | undefined
  > = true;
  const bigintSchemaNullableTest: AssertEqual<
    z.TypeOf<typeof bigintSchemaNullable>,
    bigint | null
  > = true;
  const booleanSchemaOptionalTest: AssertEqual<
    z.TypeOf<typeof booleanSchemaOptional>,
    boolean | undefined
  > = true;
  const booleanSchemaNullableTest: AssertEqual<
    z.TypeOf<typeof booleanSchemaNullable>,
    boolean | null
  > = true;
  const dateSchemaOptionalTest: AssertEqual<
    z.TypeOf<typeof dateSchemaOptional>,
    Date | undefined
  > = true;
  const dateSchemaNullableTest: AssertEqual<
    z.TypeOf<typeof dateSchemaNullable>,
    Date | null
  > = true;

  [
    literalStringSchemaTest,
    literalNumberSchemaTest,
    literalBooleanSchemaTest,
    stringSchemaTest,
    numberSchemaTest,
    bigintSchemaTest,
    booleanSchemaTest,
    dateSchemaTest,
    nullSchemaTest,
    undefinedSchemaTest,
    stringSchemaOptionalTest,
    stringSchemaNullableTest,
    numberSchemaOptionalTest,
    numberSchemaNullableTest,
    bigintSchemaOptionalTest,
    bigintSchemaNullableTest,
    booleanSchemaOptionalTest,
    booleanSchemaNullableTest,
    dateSchemaOptionalTest,
    dateSchemaNullableTest,
  ];
});

test("get literal value", () => {
  expect(literalStringSchema.value).toEqual("asdf");
});

test("optional convenience methd", () => {
  z.ostring().parse(undefined);
  z.onumber().parse(undefined);
  z.oboolean().parse(undefined);
});
````

## File: src/__tests__/promise.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

const promSchema = z.promise(
  z.object({
    name: z.string(),
    age: z.number(),
  })
);

test("promise inference", () => {
  type promSchemaType = z.infer<typeof promSchema>;
  const t1: util.AssertEqual<
    promSchemaType,
    Promise<{ name: string; age: number }>
  > = true;
  expect(t1).toBeTruthy();
});

test("promise parsing success", async () => {
  const pr = promSchema.parse(Promise.resolve({ name: "Bobby", age: 10 }));
  expect(pr).toBeInstanceOf(Promise);
  const result = await pr;
  expect(typeof result).toBe("object");
  expect(typeof result.age).toBe("number");
  expect(typeof result.name).toBe("string");
});

test("promise parsing success 2", () => {
  const fakePromise = {
    then() {
      return this;
    },
    catch() {
      return this;
    },
  };
  promSchema.parse(fakePromise);
});

test("promise parsing fail", async () => {
  const bad = promSchema.parse(Promise.resolve({ name: "Bobby", age: "10" }));
  // return await expect(bad).resolves.toBe({ name: 'Bobby', age: '10' });
  return await expect(bad).rejects.toBeInstanceOf(z.ZodError);
  // done();
});

test("promise parsing fail 2", async () => {
  const failPromise = promSchema.parse(
    Promise.resolve({ name: "Bobby", age: "10" })
  );
  await expect(failPromise).rejects.toBeInstanceOf(z.ZodError);
  // done();/z
});

test("promise parsing fail", () => {
  const bad = () => promSchema.parse({ then: () => {}, catch: {} });
  expect(bad).toThrow();
});

// test('sync promise parsing', () => {
//   expect(() => z.promise(z.string()).parse(Promise.resolve('asfd'))).toThrow();
// });

const asyncFunction = z.function(z.tuple([]), promSchema);

test("async function pass", async () => {
  const validatedFunction = asyncFunction.implement(async () => {
    return { name: "jimmy", age: 14 };
  });
  await expect(validatedFunction()).resolves.toEqual({
    name: "jimmy",
    age: 14,
  });
});

test("async function fail", async () => {
  const validatedFunction = asyncFunction.implement(() => {
    return Promise.resolve("asdf" as any);
  });
  await expect(validatedFunction()).rejects.toBeInstanceOf(z.ZodError);
});

test("async promise parsing", () => {
  const res = z.promise(z.number()).parseAsync(Promise.resolve(12));
  expect(res).toBeInstanceOf(Promise);
});
````

## File: src/__tests__/record.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

const booleanRecord = z.record(z.boolean());
type booleanRecord = z.infer<typeof booleanRecord>;

const recordWithEnumKeys = z.record(z.enum(["Tuna", "Salmon"]), z.string());
type recordWithEnumKeys = z.infer<typeof recordWithEnumKeys>;

const recordWithLiteralKeys = z.record(
  z.union([z.literal("Tuna"), z.literal("Salmon")]),
  z.string()
);
type recordWithLiteralKeys = z.infer<typeof recordWithLiteralKeys>;

test("type inference", () => {
  const f1: util.AssertEqual<booleanRecord, Record<string, boolean>> = true;
  f1;

  const f2: util.AssertEqual<
    recordWithEnumKeys,
    Partial<Record<"Tuna" | "Salmon", string>>
  > = true;
  f2;
  const f3: util.AssertEqual<
    recordWithLiteralKeys,
    Partial<Record<"Tuna" | "Salmon", string>>
  > = true;
  f3;
});

test("methods", () => {
  booleanRecord.optional();
  booleanRecord.nullable();
});

test("string record parse - pass", () => {
  booleanRecord.parse({
    k1: true,
    k2: false,
    1234: false,
  });
});

test("string record parse - fail", () => {
  const badCheck = () =>
    booleanRecord.parse({
      asdf: 1234,
    } as any);
  expect(badCheck).toThrow();

  expect(() => booleanRecord.parse("asdf")).toThrow();
});

test("string record parse - fail", () => {
  const badCheck = () =>
    booleanRecord.parse({
      asdf: {},
    } as any);
  expect(badCheck).toThrow();
});

test("string record parse - fail", () => {
  const badCheck = () =>
    booleanRecord.parse({
      asdf: [],
    } as any);
  expect(badCheck).toThrow();
});

test("key schema", () => {
  const result1 = recordWithEnumKeys.parse({
    Tuna: "asdf",
    Salmon: "asdf",
  });
  expect(result1).toEqual({
    Tuna: "asdf",
    Salmon: "asdf",
  });

  const result2 = recordWithLiteralKeys.parse({
    Tuna: "asdf",
    Salmon: "asdf",
  });
  expect(result2).toEqual({
    Tuna: "asdf",
    Salmon: "asdf",
  });

  // shouldn't require us to specify all props in record
  const result3 = recordWithEnumKeys.parse({
    Tuna: "abcd",
  });
  expect(result3).toEqual({
    Tuna: "abcd",
  });

  // shouldn't require us to specify all props in record
  const result4 = recordWithLiteralKeys.parse({
    Salmon: "abcd",
  });
  expect(result4).toEqual({
    Salmon: "abcd",
  });

  expect(() =>
    recordWithEnumKeys.parse({
      Tuna: "asdf",
      Salmon: "asdf",
      Trout: "asdf",
    })
  ).toThrow();

  expect(() =>
    recordWithLiteralKeys.parse({
      Tuna: "asdf",
      Salmon: "asdf",

      Trout: "asdf",
    })
  ).toThrow();
});

// test("record element", () => {
//   expect(booleanRecord.element).toBeInstanceOf(z.ZodBoolean);
// });

test("key and value getters", () => {
  const rec = z.record(z.string(), z.number());

  rec.keySchema.parse("asdf");
  rec.valueSchema.parse(1234);
  rec.element.parse(1234);
});
````

## File: src/__tests__/recursive.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { z } from "..";

interface Category {
  name: string;
  subcategories: Category[];
}

const testCategory: Category = {
  name: "I",
  subcategories: [
    {
      name: "A",
      subcategories: [
        {
          name: "1",
          subcategories: [
            {
              name: "a",
              subcategories: [],
            },
          ],
        },
      ],
    },
  ],
};

test("recursion with z.late.object", () => {
  const Category: z.ZodType<Category> = z.late.object(() => ({
    name: z.string(),
    subcategories: z.array(Category),
  }));
  Category.parse(testCategory);
});

test("recursion with z.lazy", () => {
  const Category: z.ZodType<Category> = z.lazy(() =>
    z.object({
      name: z.string(),
      subcategories: z.array(Category),
    })
  );
  Category.parse(testCategory);
});

test("schema getter", () => {
  z.lazy(() => z.string()).schema.parse("asdf");
});
// interface A {
//   val: number;
//   b: B;
// }

// interface B {
//   val: number;
//   a: A;
// }

// const A: z.ZodType<A> = z.late.object(() => ({
//   val: z.number(),
//   b: B,
// }));

// const B: z.ZodType<B> = z.late.object(() => ({
//   val: z.number(),
//   a: A,
// }));

// const Alazy: z.ZodType<A> = z.lazy(() => z.object({
//   val: z.number(),
//   b: B,
// }));

// const Blazy: z.ZodType<B> = z.lazy(() => z.object({
//   val: z.number(),
//   a: A,
// }));

// const a: any = { val: 1 };
// const b: any = { val: 2 };
// a.b = b;
// b.a = a;

// test('valid check', () => {
//   A.parse(a);
//   B.parse(b);
// });

// test("valid check lazy", () => {
//   A.parse({val:1, b:});
//   B.parse(b);
// });

// test('masking check', () => {
//   const FragmentOnA = z
//     .object({
//       val: z.number(),
//       b: z
//         .object({
//           val: z.number(),
//           a: z
//             .object({
//               val: z.number(),
//             })
//             .nonstrict(),
//         })
//         .nonstrict(),
//     })
//     .nonstrict();

//   const fragment = FragmentOnA.parse(a);
//   fragment;
// });

// test('invalid check', () => {
//   expect(() => A.parse({} as any)).toThrow();
// });

// test('schema getter', () => {
//   (A as z.ZodLazy<any>).schema;
// });

// test("self recursion with cyclical data", () => {
//   interface Category {
//     name: string;
//     subcategories: Category[];
//   }

//   const Category: z.ZodType<Category> = z.late.object(() => ({
//     name: z.string(),
//     subcategories: z.array(Category),
//   }));

//   const untypedCategory: any = {
//     name: "Category A",
//   };
//   // creating a cycle
//   untypedCategory.subcategories = [untypedCategory];
//   Category.parse(untypedCategory);
// });

// test("self recursion with base type", () => {
//   const BaseCategory = z.object({
//     name: z.string(),
//   });
//   type BaseCategory = z.infer<typeof BaseCategory>;

//   type Category = BaseCategory & { subcategories: Category[] };

//   const Category: z.ZodType<Category> = z.late
//     .object(() => ({
//       subcategories: z.array(Category),
//     }))
//     .extend({
//       name: z.string(),
//     });

//   const untypedCategory: any = {
//     name: "Category A",
//   };
//   // creating a cycle
//   untypedCategory.subcategories = [untypedCategory];
//   Category.parse(untypedCategory); // parses successfully
// });
````

## File: src/__tests__/refine.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";
import { ZodIssueCode } from "../ZodError";

test("refinement", () => {
  const obj1 = z.object({
    first: z.string(),
    second: z.string(),
  });
  const obj2 = obj1.partial().strict();

  const obj3 = obj2.refine(
    (data) => data.first || data.second,
    "Either first or second should be filled in."
  );

  expect(obj1 === (obj2 as any)).toEqual(false);
  expect(obj2 === (obj3 as any)).toEqual(false);

  expect(() => obj1.parse({})).toThrow();
  expect(() => obj2.parse({ third: "adsf" })).toThrow();
  expect(() => obj3.parse({})).toThrow();
  obj3.parse({ first: "a" });
  obj3.parse({ second: "a" });
  obj3.parse({ first: "a", second: "a" });
});

test("refinement 2", () => {
  const validationSchema = z
    .object({
      email: z.string().email(),
      password: z.string(),
      confirmPassword: z.string(),
    })
    .refine(
      (data) => data.password === data.confirmPassword,
      "Both password and confirmation must match"
    );

  expect(() =>
    validationSchema.parse({
      email: "aaaa@gmail.com",
      password: "aaaaaaaa",
      confirmPassword: "bbbbbbbb",
    })
  ).toThrow();
});

test("refinement type guard", () => {
  const validationSchema = z.object({
    a: z.string().refine((s): s is "a" => s === "a"),
  });
  type Schema = z.infer<typeof validationSchema>;

  const f1: util.AssertEqual<"a", Schema["a"]> = true;
  f1;
  const f2: util.AssertEqual<"string", Schema["a"]> = false;
  f2;
});

test("refinement Promise", async () => {
  const validationSchema = z
    .object({
      email: z.string().email(),
      password: z.string(),
      confirmPassword: z.string(),
    })
    .refine(
      (data) =>
        Promise.resolve().then(() => data.password === data.confirmPassword),
      "Both password and confirmation must match"
    );

  await validationSchema.parseAsync({
    email: "aaaa@gmail.com",
    password: "password",
    confirmPassword: "password",
  });
});

test("custom path", async () => {
  const result = await z
    .object({
      password: z.string(),
      confirm: z.string(),
    })
    .refine((data) => data.confirm === data.password, { path: ["confirm"] })
    .spa({ password: "asdf", confirm: "qewr" });
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].path).toEqual(["confirm"]);
  }
});

test("use path in refinement context", async () => {
  const noNested = z.string()._refinement((_val, ctx) => {
    if (ctx.path.length > 0) {
      ctx.addIssue({
        code: ZodIssueCode.custom,
        message: `schema cannot be nested. path: ${ctx.path.join(".")}`,
      });
      return false;
    } else {
      return true;
    }
  });

  const data = z.object({
    foo: noNested,
  });

  const t1 = await noNested.spa("asdf");
  const t2 = await data.spa({ foo: "asdf" });

  expect(t1.success).toBe(true);
  expect(t2.success).toBe(false);
  if (t2.success === false) {
    expect(t2.error.issues[0].message).toEqual(
      "schema cannot be nested. path: foo"
    );
  }
});

test("superRefine", () => {
  const Strings = z.array(z.string()).superRefine((val, ctx) => {
    if (val.length > 3) {
      ctx.addIssue({
        code: z.ZodIssueCode.too_big,
        maximum: 3,
        type: "array",
        inclusive: true,
        message: "Too many items 😡",
      });
    }

    if (val.length !== new Set(val).size) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `No duplicates allowed.`,
      });
    }
  });

  const result = Strings.safeParse(["asfd", "asfd", "asfd", "asfd"]);

  expect(result.success).toEqual(false);
  if (!result.success) expect(result.error.issues.length).toEqual(2);

  Strings.parse(["asfd", "qwer"]);
});

test("get inner type", () => {
  z.string()
    .refine(() => true)
    .innerType()
    .parse("asdf");
});

test("chained refinements", () => {
  const objectSchema = z
    .object({
      length: z.number(),
      size: z.number(),
    })
    .refine(({ length }) => length > 5, {
      path: ["length"],
      message: "length greater than 5",
    })
    .refine(({ size }) => size > 7, {
      path: ["size"],
      message: "size greater than 7",
    });
  const r1 = objectSchema.safeParse({
    length: 4,
    size: 9,
  });
  expect(r1.success).toEqual(false);
  if (!r1.success) expect(r1.error.issues.length).toEqual(1);

  const r2 = objectSchema.safeParse({
    length: 4,
    size: 3,
  });
  expect(r2.success).toEqual(false);
  if (!r2.success) expect(r2.error.issues.length).toEqual(2);
});

test("fatal superRefine", () => {
  const Strings = z
    .string()
    .superRefine((val, ctx) => {
      if (val === "") {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "foo",
          fatal: true,
        });
      }
    })
    .superRefine((val, ctx) => {
      if (val !== " ") {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "bar",
        });
      }
    });

  const result = Strings.safeParse("");

  expect(result.success).toEqual(false);
  if (!result.success) expect(result.error.issues.length).toEqual(1);
});
````

## File: src/__tests__/safeparse.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";
const stringSchema = z.string();

test("safeparse fail", () => {
  const safe = stringSchema.safeParse(12);
  expect(safe.success).toEqual(false);
  expect((safe as any).error).toBeInstanceOf(z.ZodError);
});

test("safeparse pass", () => {
  const safe = stringSchema.safeParse("12");
  expect(safe.success).toEqual(true);
  expect((safe as any).data).toEqual("12");
});

test("safeparse unexpected error", () => {
  expect(() =>
    stringSchema
      .refine((data) => {
        throw new Error(data);
      })
      .safeParse("12")
  ).toThrow();
});
````

## File: src/__tests__/set.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";
import { ZodIssueCode } from "../index";

const stringSet = z.set(z.string());
type stringSet = z.infer<typeof stringSet>;

const minTwo = z.set(z.string()).min(2);
const maxTwo = z.set(z.string()).max(2);
const justTwo = z.set(z.string()).size(2);
const nonEmpty = z.set(z.string()).nonempty();
const nonEmptyMax = z.set(z.string()).nonempty().max(2);

test("type inference", () => {
  const f1: util.AssertEqual<stringSet, Set<string>> = true;
  f1;
});

test("valid parse", () => {
  const result = stringSet.safeParse(new Set(["first", "second"]));
  expect(result.success).toEqual(true);
  if (result.success) {
    expect(result.data.has("first")).toEqual(true);
    expect(result.data.has("second")).toEqual(true);
    expect(result.data.has("third")).toEqual(false);
  }

  expect(() => {
    minTwo.parse(new Set(["a", "b"]));
    minTwo.parse(new Set(["a", "b", "c"]));
    maxTwo.parse(new Set(["a", "b"]));
    maxTwo.parse(new Set(["a"]));
    justTwo.parse(new Set(["a", "b"]));
    nonEmpty.parse(new Set(["a"]));
    nonEmptyMax.parse(new Set(["a"]));
  }).not.toThrow();
});

test("valid parse async", async () => {
  const result = await stringSet.spa(new Set(["first", "second"]));
  expect(result.success).toEqual(true);
  if (result.success) {
    expect(result.data.has("first")).toEqual(true);
    expect(result.data.has("second")).toEqual(true);
    expect(result.data.has("third")).toEqual(false);
  }

  const asyncResult = await stringSet.safeParse(new Set(["first", "second"]));
  expect(asyncResult.success).toEqual(true);
  if (asyncResult.success) {
    expect(asyncResult.data.has("first")).toEqual(true);
    expect(asyncResult.data.has("second")).toEqual(true);
    expect(asyncResult.data.has("third")).toEqual(false);
  }
});

test("valid parse: size-related methods", () => {
  expect(() => {
    minTwo.parse(new Set(["a", "b"]));
    minTwo.parse(new Set(["a", "b", "c"]));
    maxTwo.parse(new Set(["a", "b"]));
    maxTwo.parse(new Set(["a"]));
    justTwo.parse(new Set(["a", "b"]));
    nonEmpty.parse(new Set(["a"]));
    nonEmptyMax.parse(new Set(["a"]));
  }).not.toThrow();

  const sizeZeroResult = stringSet.parse(new Set());
  expect(sizeZeroResult.size).toBe(0);

  const sizeTwoResult = minTwo.parse(new Set(["a", "b"]));
  expect(sizeTwoResult.size).toBe(2);
});

test("failing when parsing empty set in nonempty ", () => {
  const result = nonEmpty.safeParse(new Set());
  expect(result.success).toEqual(false);

  if (result.success === false) {
    expect(result.error.issues.length).toEqual(1);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.too_small);
  }
});

test("failing when set is smaller than min() ", () => {
  const result = minTwo.safeParse(new Set(["just_one"]));
  expect(result.success).toEqual(false);

  if (result.success === false) {
    expect(result.error.issues.length).toEqual(1);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.too_small);
  }
});

test("failing when set is bigger than max() ", () => {
  const result = maxTwo.safeParse(new Set(["one", "two", "three"]));
  expect(result.success).toEqual(false);

  if (result.success === false) {
    expect(result.error.issues.length).toEqual(1);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.too_big);
  }
});

test("doesn’t throw when an empty set is given", () => {
  const result = stringSet.safeParse(new Set([]));
  expect(result.success).toEqual(true);
});

test("throws when a Map is given", () => {
  const result = stringSet.safeParse(new Map([]));
  expect(result.success).toEqual(false);
  if (result.success === false) {
    expect(result.error.issues.length).toEqual(1);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
  }
});

test("throws when the given set has invalid input", () => {
  const result = stringSet.safeParse(new Set([Symbol()]));
  expect(result.success).toEqual(false);
  if (result.success === false) {
    expect(result.error.issues.length).toEqual(1);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[0].path).toEqual([0]);
  }
});

test("throws when the given set has multiple invalid entries", () => {
  const result = stringSet.safeParse(new Set([1, 2] as any[]) as Set<any>);

  expect(result.success).toEqual(false);
  if (result.success === false) {
    expect(result.error.issues.length).toEqual(2);
    expect(result.error.issues[0].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[0].path).toEqual([0]);
    expect(result.error.issues[1].code).toEqual(ZodIssueCode.invalid_type);
    expect(result.error.issues[1].path).toEqual([1]);
  }
});
````

## File: src/__tests__/string.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

const minFive = z.string().min(5, "min5");
const maxFive = z.string().max(5, "max5");
const justFive = z.string().length(5);
const nonempty = z.string().nonempty("nonempty");

test("passing validations", () => {
  minFive.parse("12345");
  minFive.parse("123456");
  maxFive.parse("12345");
  maxFive.parse("1234");
  nonempty.parse("1");
  justFive.parse("12345");
});

test("failing validations", () => {
  expect(() => minFive.parse("1234")).toThrow();
  expect(() => maxFive.parse("123456")).toThrow();
  expect(() => nonempty.parse("")).toThrow();
  expect(() => justFive.parse("1234")).toThrow();
  expect(() => justFive.parse("123456")).toThrow();
});

test("email validations", () => {
  const email = z.string().email();
  email.parse("mojojojo@example.com");
  expect(() => email.parse("asdf")).toThrow();
  expect(() => email.parse("@lkjasdf.com")).toThrow();
  expect(() => email.parse("asdf@sdf.")).toThrow();
});

test("more email validations", () => {
  const data = [
    `"josé.arrañoça"@domain.com`,
    `"сайт"@domain.com`,
    `"💩"@domain.com`,
    `"🍺🕺🎉"@domain.com`,
    `poop@💩.la`,
    `"🌮"@i❤️tacos.ws`,
  ];
  const email = z.string().email();
  for (const datum of data) {
    email.parse(datum);
  }
});

test("url validations", () => {
  const url = z.string().url();
  try {
    url.parse("http://google.com");
    url.parse("https://google.com/asdf?asdf=ljk3lk4&asdf=234#asdf");
    expect(() => url.parse("asdf")).toThrow();
    expect(() => url.parse("https:/")).toThrow();
    expect(() => url.parse("asdfj@lkjsdf.com")).toThrow();
  } catch (err) {}
});

test("url error overrides", () => {
  try {
    z.string().url().parse("https");
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual("Invalid url");
  }
  try {
    z.string().url("badurl").parse("https");
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual("badurl");
  }
  try {
    z.string().url({ message: "badurl" }).parse("https");
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual("badurl");
  }
});

test("uuid", () => {
  const uuid = z.string().uuid("custom error");
  uuid.parse("9491d710-3185-4e06-bea0-6a2f275345e0");
  uuid.parse("00000000-0000-0000-0000-000000000000");
  uuid.parse("b3ce60f8-e8b9-40f5-1150-172ede56ff74"); // Variant 0 - RFC 4122: Reserved, NCS backward compatibility
  uuid.parse("92e76bf9-28b3-4730-cd7f-cb6bc51f8c09"); // Variant 2 - RFC 4122: Reserved, Microsoft Corporation backward compatibility
  const result = uuid.safeParse("9491d710-3185-4e06-bea0-6a2f275345e0X");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].message).toEqual("custom error");
  }
});

test("bad uuid", () => {
  const uuid = z.string().uuid("custom error");
  uuid.parse("9491d710-3185-4e06-bea0-6a2f275345e0");
  const result = uuid.safeParse("invalid uuid");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].message).toEqual("custom error");
  }
});

test("cuid", () => {
  const cuid = z.string().cuid();
  cuid.parse("ckopqwooh000001la8mbi2im9");
  const result = cuid.safeParse("cifjhdsfhsd-invalid-cuid");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].message).toEqual("Invalid cuid");
  }
});

test("regex", () => {
  z.string()
    .regex(/^moo+$/)
    .parse("mooooo");
  expect(() => z.string().uuid().parse("purr")).toThrow();
});

test("regexp error message", () => {
  const result = z
    .string()
    .regex(/^moo+$/)
    .safeParse("boooo");
  if (!result.success) {
    expect(result.error.issues[0].message).toEqual("Invalid");
  } else {
    throw new Error("validation should have failed");
  }

  expect(() => z.string().uuid().parse("purr")).toThrow();
});

test("regex lastIndex reset", () => {
  const schema = z.string().regex(/^\d+$/g);
  expect(schema.safeParse("123").success).toEqual(true);
  expect(schema.safeParse("123").success).toEqual(true);
  expect(schema.safeParse("123").success).toEqual(true);
  expect(schema.safeParse("123").success).toEqual(true);
  expect(schema.safeParse("123").success).toEqual(true);
});

test("checks getters", () => {
  expect(z.string().email().isEmail).toEqual(true);
  expect(z.string().email().isURL).toEqual(false);
  expect(z.string().email().isCUID).toEqual(false);
  expect(z.string().email().isUUID).toEqual(false);

  expect(z.string().url().isEmail).toEqual(false);
  expect(z.string().url().isURL).toEqual(true);
  expect(z.string().url().isCUID).toEqual(false);
  expect(z.string().url().isUUID).toEqual(false);

  expect(z.string().cuid().isEmail).toEqual(false);
  expect(z.string().cuid().isURL).toEqual(false);
  expect(z.string().cuid().isCUID).toEqual(true);
  expect(z.string().cuid().isUUID).toEqual(false);

  expect(z.string().uuid().isEmail).toEqual(false);
  expect(z.string().uuid().isURL).toEqual(false);
  expect(z.string().uuid().isCUID).toEqual(false);
  expect(z.string().uuid().isUUID).toEqual(true);
});

test("min max getters", () => {
  expect(z.string().min(5).minLength).toEqual(5);
  expect(z.string().min(5).min(10).minLength).toEqual(10);

  expect(z.string().max(5).maxLength).toEqual(5);
  expect(z.string().max(5).max(1).maxLength).toEqual(1);
});
````

## File: src/__tests__/transformer.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";

const stringToNumber = z.string().transform((arg) => parseFloat(arg));
// const numberToString = z
//   .transformer(z.number())
//   .transform((n) => String(n));
const asyncNumberToString = z.number().transform(async (n) => String(n));

test("basic transformations", () => {
  const r1 = z
    .string()
    .transform((data) => data.length)
    .parse("asdf");
  expect(r1).toEqual(4);
});

test("coercion", () => {
  const numToString = z.number().transform((n) => String(n));
  const data = z
    .object({
      id: numToString,
    })
    .parse({ id: 5 });

  expect(data).toEqual({ id: "5" });
});

test("async coercion", async () => {
  const numToString = z.number().transform(async (n) => String(n));
  const data = await z
    .object({
      id: numToString,
    })
    .parseAsync({ id: 5 });

  expect(data).toEqual({ id: "5" });
});

test("sync coercion async error", async () => {
  expect(() =>
    z
      .object({
        id: asyncNumberToString,
      })
      .parse({ id: 5 })
  ).toThrow();
  // expect(data).toEqual({ id: '5' });
});

test("default", () => {
  const data = z.string().default("asdf").parse(undefined); // => "asdf"
  expect(data).toEqual("asdf");
});

test("dynamic default", () => {
  const data = z
    .string()
    .default(() => "string")
    .parse(undefined); // => "asdf"
  expect(data).toEqual("string");
});

test("default when property is null or undefined", () => {
  const data = z
    .object({
      foo: z.boolean().nullable().default(true),
      bar: z.boolean().default(true),
    })
    .parse({ foo: null });

  expect(data).toEqual({ foo: null, bar: true });
});

test("default with falsy values", () => {
  const schema = z.object({
    emptyStr: z.string().default("def"),
    zero: z.number().default(5),
    falseBoolean: z.boolean().default(true),
  });
  const input = { emptyStr: "", zero: 0, falseBoolean: true };
  const output = schema.parse(input);
  // defaults are not supposed to be used
  expect(output).toEqual(input);
});

test("object typing", () => {
  const t1 = z.object({
    stringToNumber,
  });

  type t1 = z.input<typeof t1>;
  type t2 = z.output<typeof t1>;

  const f1: util.AssertEqual<t1, { stringToNumber: string }> = true;
  const f2: util.AssertEqual<t2, { stringToNumber: number }> = true;
  f1;
  f2;
});

test("transform method overloads", () => {
  const t1 = z.string().transform((val) => val.toUpperCase());
  expect(t1.parse("asdf")).toEqual("ASDF");

  const t2 = z.string().transform((val) => val.length);
  expect(t2.parse("asdf")).toEqual(4);
});

test("multiple transformers", () => {
  const doubler = stringToNumber.transform((val) => {
    return val * 2;
  });
  expect(doubler.parse("5")).toEqual(10);
});

test("preprocess", () => {
  const schema = z.preprocess((data) => [data], z.string().array());

  const value = schema.parse("asdf");
  expect(value).toEqual(["asdf"]);
});

test("async preprocess", async () => {
  const schema = z.preprocess(async (data) => [data], z.string().array());

  const value = await schema.parseAsync("asdf");
  expect(value).toEqual(["asdf"]);
});

test("short circuit on dirty", () => {
  const schema = z
    .string()
    .refine(() => false)
    .transform((val) => val.toUpperCase());
  const result = schema.safeParse("asdf");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);
  }

  const result2 = schema.safeParse(1234);
  expect(result2.success).toEqual(false);
  if (!result2.success) {
    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);
  }
});

test("async short circuit on dirty", async () => {
  const schema = z
    .string()
    .refine(() => false)
    .transform((val) => val.toUpperCase());
  const result = await schema.spa("asdf");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues[0].code).toEqual(z.ZodIssueCode.custom);
  }

  const result2 = await schema.spa(1234);
  expect(result2.success).toEqual(false);
  if (!result2.success) {
    expect(result2.error.issues[0].code).toEqual(z.ZodIssueCode.invalid_type);
  }
});
````

## File: src/__tests__/tuple.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";
import { ZodError } from "../ZodError";

const testTuple = z.tuple([
  z.string(),
  z.object({ name: z.literal("Rudy") }),
  z.array(z.literal("blue")),
]);
const testData = ["asdf", { name: "Rudy" }, ["blue"]];
const badData = [123, { name: "Rudy2" }, ["blue", "red"]];

test("tuple inference", () => {
  const args1 = z.tuple([z.string()]);
  const returns1 = z.number();
  const func1 = z.function(args1, returns1);
  type func1 = z.TypeOf<typeof func1>;
  const t1: util.AssertEqual<func1, (k: string) => number> = true;
  [t1];
});

test("successful validation", () => {
  const val = testTuple.parse(testData);
  expect(val).toEqual(["asdf", { name: "Rudy" }, ["blue"]]);
});

test("successful async validation", async () => {
  const val = await testTuple.parseAsync(testData);
  return expect(val).toEqual(testData);
});

test("failed validation", () => {
  const checker = () => {
    testTuple.parse([123, { name: "Rudy2" }, ["blue", "red"]] as any);
  };
  try {
    checker();
  } catch (err) {
    if (err instanceof ZodError) {
      expect(err.issues.length).toEqual(3);
    }
  }
});

test("failed async validation", async () => {
  const res = await testTuple.safeParse(badData);
  expect(res.success).toEqual(false);
  if (!res.success) {
    expect(res.error.issues.length).toEqual(3);
  }
  // try {
  //   checker();
  // } catch (err) {
  //   if (err instanceof ZodError) {
  //     expect(err.issues.length).toEqual(3);
  //   }
  // }
});

test("tuple with transformers", () => {
  const stringToNumber = z.string().transform((val) => val.length);
  const val = z.tuple([stringToNumber]);

  type t1 = z.input<typeof val>;
  const f1: util.AssertEqual<t1, [string]> = true;
  type t2 = z.output<typeof val>;
  const f2: util.AssertEqual<t2, [number]> = true;
  expect(val.parse(["1234"])).toEqual([4]);
  f1;
  f2;
});

test("tuple with rest schema", () => {
  const myTuple = z.tuple([z.string(), z.number()]).rest(z.boolean());
  expect(myTuple.parse(["asdf", 1234, true, false, true])).toEqual([
    "asdf",
    1234,
    true,
    false,
    true,
  ]);

  expect(myTuple.parse(["asdf", 1234])).toEqual(["asdf", 1234]);

  expect(() => myTuple.parse(["asdf", 1234, "asdf"])).toThrow();
  type t1 = z.output<typeof myTuple>;

  const f1: util.AssertEqual<t1, [string, number, ...boolean[]]> = true;
  f1;
});

// test('tuple with optional elements', () => {
//   const result = z
//     .tuple([z.string(), z.number().optional()])
//     .safeParse(['asdf']);
//   expect(result).toEqual(['asdf']);
// });
````

## File: src/__tests__/unions.test.ts
````typescript
import { expect, test } from "@jest/globals";

import * as z from "../index";

test("function parsing", () => {
  const schema = z.union([
    z.string().refine(() => false),
    z.number().refine(() => false),
  ]);
  const result = schema.safeParse("asdf");
  expect(result.success).toEqual(false);
});

test("union 2", () => {
  const result = z
    .union([z.number(), z.string().refine(() => false)])
    .safeParse("a");
  expect(result.success).toEqual(false);
});

test("return valid over invalid", () => {
  const schema = z.union([
    z.object({
      email: z.string().email(),
    }),
    z.string(),
  ]);
  expect(schema.parse("asdf")).toEqual("asdf");
  expect(schema.parse({ email: "asdlkjf@lkajsdf.com" })).toEqual({
    email: "asdlkjf@lkajsdf.com",
  });
});

test("return dirty result over aborted", () => {
  const result = z
    .union([z.number(), z.string().refine(() => false)])
    .safeParse("a");
  expect(result.success).toEqual(false);
  if (!result.success) {
    expect(result.error.issues).toEqual([
      {
        code: "custom",
        message: "Invalid input",
        path: [],
      },
    ]);
  }
});

test("options getter", async () => {
  const union = z.union([z.string(), z.number()]);
  union.options[0].parse("asdf");
  union.options[1].parse(1234);
  await union.options[0].parseAsync("asdf");
  await union.options[1].parseAsync(1234);
});

test("readonly union", async () => {
  const options = [z.string(), z.number()] as const;
  const union = z.union(options);
  union.parse("asdf");
  union.parse(12);
});
````

## File: src/__tests__/validations.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import * as z from "../index";

test("array min", async () => {
  try {
    await z.array(z.string()).min(4).parseAsync([]);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Array must contain at least 4 element(s)"
    );
  }
});

test("array max", async () => {
  try {
    await z.array(z.string()).max(2).parseAsync(["asdf", "asdf", "asdf"]);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Array must contain at most 2 element(s)"
    );
  }
});

test("string min", async () => {
  try {
    await z.string().min(4).parseAsync("asd");
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "String must contain at least 4 character(s)"
    );
  }
});

test("string max", async () => {
  try {
    await z.string().max(4).parseAsync("aasdfsdfsd");
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "String must contain at most 4 character(s)"
    );
  }
});

test("number min", async () => {
  try {
    await z.number().gte(3).parseAsync(2);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Number must be greater than or equal to 3"
    );
  }
});

test("number max", async () => {
  try {
    await z.number().lte(3).parseAsync(4);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Number must be less than or equal to 3"
    );
  }
});

test("number nonnegative", async () => {
  try {
    await z.number().nonnegative().parseAsync(-1);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Number must be greater than or equal to 0"
    );
  }
});

test("number nonpositive", async () => {
  try {
    await z.number().nonpositive().parseAsync(1);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Number must be less than or equal to 0"
    );
  }
});

test("number negative", async () => {
  try {
    await z.number().negative().parseAsync(1);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Number must be less than 0"
    );
  }
});

test("number positive", async () => {
  try {
    await z.number().positive().parseAsync(-1);
  } catch (err) {
    expect((err as z.ZodError).issues[0].message).toEqual(
      "Number must be greater than 0"
    );
  }
});

test("instantiation", () => {
  z.string().min(5);
  z.string().max(5);
  z.string().length(5);
  z.string().email();
  z.string().url();
  z.string().uuid();
  z.string().min(5, { message: "Must be 5 or more characters long" });
  z.string().max(5, { message: "Must be 5 or fewer characters long" });
  z.string().length(5, { message: "Must be exactly 5 characters long" });
  z.string().email({ message: "Invalid email address." });
  z.string().url({ message: "Invalid url" });
  z.string().uuid({ message: "Invalid UUID" });
});

test("int", async () => {
  const int = z.number().int();
  int.parse(4);
  expect(() => int.parse(3.5)).toThrow();
});
````

## File: src/__tests__/void.test.ts
````typescript
// @ts-ignore TS6133
import { expect, test } from "@jest/globals";

import { util } from "../helpers/util";
import * as z from "../index";
test("void", () => {
  const v = z.void();
  v.parse(undefined);

  expect(() => v.parse(null)).toThrow();
  expect(() => v.parse("")).toThrow();

  type v = z.infer<typeof v>;
  const t1: util.AssertEqual<v, void> = true;
  t1;
});
````

## File: src/benchmarks/discriminatedUnion.ts
````typescript
import Benchmark from "benchmark";

import { z } from "../index";

const doubleSuite = new Benchmark.Suite("z.discriminatedUnion: double");
const manySuite = new Benchmark.Suite("z.discriminatedUnion: many");

const aSchema = z.object({
  type: z.literal("a"),
});
const objA = {
  type: "a",
};

const bSchema = z.object({
  type: z.literal("b"),
});
const objB = {
  type: "b",
};

const cSchema = z.object({
  type: z.literal("c"),
});
const objC = {
  type: "c",
};

const dSchema = z.object({
  type: z.literal("d"),
});

const double = z.discriminatedUnion("type", [aSchema, bSchema]);
const many = z.discriminatedUnion("type", [aSchema, bSchema, cSchema, dSchema]);

doubleSuite
  .add("valid: a", () => {
    double.parse(objA);
  })
  .add("valid: b", () => {
    double.parse(objB);
  })
  .add("invalid: null", () => {
    try {
      double.parse(null);
    } catch (err) {}
  })
  .add("invalid: wrong shape", () => {
    try {
      double.parse(objC);
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(doubleSuite as any).name}: ${e.target}`);
  });

manySuite
  .add("valid: a", () => {
    many.parse(objA);
  })
  .add("valid: c", () => {
    many.parse(objC);
  })
  .add("invalid: null", () => {
    try {
      many.parse(null);
    } catch (err) {}
  })
  .add("invalid: wrong shape", () => {
    try {
      many.parse({ type: "unknown" });
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(manySuite as any).name}: ${e.target}`);
  });

export default {
  suites: [doubleSuite, manySuite],
};
````

## File: src/benchmarks/index.ts
````typescript
import discriminatedUnionBenchmarks from "./discriminatedUnion";
import objectBenchmarks from "./object";
import primitiveBenchmarks from "./primitives";
import realworld from "./realworld";
import stringBenchmarks from "./string";
import unionBenchmarks from "./union";

for (const suite of [
  ...realworld.suites,
  ...primitiveBenchmarks.suites,
  ...stringBenchmarks.suites,
  ...objectBenchmarks.suites,
  ...unionBenchmarks.suites,
  ...discriminatedUnionBenchmarks.suites,
]) {
  suite.run();
}
````

## File: src/benchmarks/object.ts
````typescript
import Benchmark from "benchmark";

import { z } from "../index";

const emptySuite = new Benchmark.Suite("z.object: empty");
const shortSuite = new Benchmark.Suite("z.object: short");
const longSuite = new Benchmark.Suite("z.object: long");

const empty = z.object({});
const short = z.object({
  string: z.string(),
});
const long = z.object({
  string: z.string(),
  number: z.number(),
  boolean: z.boolean(),
});

emptySuite
  .add("valid", () => {
    empty.parse({});
  })
  .add("valid: extra keys", () => {
    empty.parse({ string: "string" });
  })
  .add("invalid: null", () => {
    try {
      empty.parse(null);
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(emptySuite as any).name}: ${e.target}`);
  });

shortSuite
  .add("valid", () => {
    short.parse({ string: "string" });
  })
  .add("valid: extra keys", () => {
    short.parse({ string: "string", number: 42 });
  })
  .add("invalid: null", () => {
    try {
      short.parse(null);
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(shortSuite as any).name}: ${e.target}`);
  });

longSuite
  .add("valid", () => {
    long.parse({ string: "string", number: 42, boolean: true });
  })
  .add("valid: extra keys", () => {
    long.parse({ string: "string", number: 42, boolean: true, list: [] });
  })
  .add("invalid: null", () => {
    try {
      long.parse(null);
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(longSuite as any).name}: ${e.target}`);
  });

export default {
  suites: [emptySuite, shortSuite, longSuite],
};
````

## File: src/benchmarks/primitives.ts
````typescript
import Benchmark from "benchmark";

import { z } from "../index";

const enumSuite = new Benchmark.Suite("z.enum");
const enumSchema = z.enum(["a", "b", "c"]);

enumSuite
  .add("valid", () => {
    enumSchema.parse("a");
  })
  .add("invalid", () => {
    try {
      enumSchema.parse("x");
    } catch (e) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`z.enum: ${e.target}`);
  });

const undefinedSuite = new Benchmark.Suite("z.undefined");
const undefinedSchema = z.undefined();

undefinedSuite
  .add("valid", () => {
    undefinedSchema.parse(undefined);
  })
  .add("invalid", () => {
    try {
      undefinedSchema.parse(1);
    } catch (e) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`z.undefined: ${e.target}`);
  });

const literalSuite = new Benchmark.Suite("z.literal");
const short = "short";
const bad = "bad";
const literalSchema = z.literal("short");

literalSuite
  .add("valid", () => {
    literalSchema.parse(short);
  })
  .add("invalid", () => {
    try {
      literalSchema.parse(bad);
    } catch (e) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`z.literal: ${e.target}`);
  });

const numberSuite = new Benchmark.Suite("z.number");
const numberSchema = z.number().int();

numberSuite
  .add("valid", () => {
    numberSchema.parse(1);
  })
  .add("invalid type", () => {
    try {
      numberSchema.parse("bad");
    } catch (e) {}
  })
  .add("invalid number", () => {
    try {
      numberSchema.parse(0.5);
    } catch (e) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`z.number: ${e.target}`);
  });

export default {
  suites: [enumSuite, undefinedSuite, literalSuite, numberSuite],
};
````

## File: src/benchmarks/realworld.ts
````typescript
import Benchmark from "benchmark";

import { z } from "../index";

const shortSuite = new Benchmark.Suite("realworld");

const People = z.array(
  z.object({
    type: z.literal("person"),
    hair: z.enum(["blue", "brown"]),
    active: z.boolean(),
    name: z.string(),
    age: z.number().int(),
    hobbies: z.array(z.string()),
    address: z.object({
      street: z.string(),
      zip: z.string(),
      country: z.string(),
    }),
  })
);

let i = 0;

function num() {
  return ++i;
}

function str() {
  return (++i % 100).toString(16);
}

function array<T>(fn: () => T): T[] {
  return Array.from({ length: ++i % 10 }, () => fn());
}

const people = Array.from({ length: 100 }, () => {
  return {
    type: "person",
    hair: i % 2 ? "blue" : "brown",
    active: !!(i % 2),
    name: str(),
    age: num(),
    hobbies: array(str),
    address: {
      street: str(),
      zip: str(),
      country: str(),
    },
  };
});

shortSuite
  .add("valid", () => {
    People.parse(people);
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(shortSuite as any).name}: ${e.target}`);
  });

export default {
  suites: [shortSuite],
};
````

## File: src/benchmarks/string.ts
````typescript
import Benchmark from "benchmark";

import { z } from "../index";

const SUITE_NAME = "z.string";
const suite = new Benchmark.Suite(SUITE_NAME);

const empty = "";
const short = "short";
const long = "long".repeat(256);
const manual = (str: unknown) => {
  if (typeof str !== "string") {
    throw new Error("Not a string");
  }

  return str;
};
const stringSchema = z.string();
const optionalStringSchema = z.string().optional();
const optionalNullableStringSchema = z.string().optional().nullable();

suite
  .add("empty string", () => {
    stringSchema.parse(empty);
  })
  .add("short string", () => {
    stringSchema.parse(short);
  })
  .add("long string", () => {
    stringSchema.parse(long);
  })
  .add("optional string", () => {
    optionalStringSchema.parse(long);
  })
  .add("nullable string", () => {
    optionalNullableStringSchema.parse(long);
  })
  .add("nullable (null) string", () => {
    optionalNullableStringSchema.parse(null);
  })
  .add("invalid: null", () => {
    try {
      stringSchema.parse(null);
    } catch (err) {}
  })
  .add("manual parser: long", () => {
    manual(long);
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${SUITE_NAME}: ${e.target}`);
  });

export default {
  suites: [suite],
};
````

## File: src/benchmarks/union.ts
````typescript
import Benchmark from "benchmark";

import { z } from "../index";

const doubleSuite = new Benchmark.Suite("z.union: double");
const manySuite = new Benchmark.Suite("z.union: many");

const aSchema = z.object({
  type: z.literal("a"),
});
const objA = {
  type: "a",
};

const bSchema = z.object({
  type: z.literal("b"),
});
const objB = {
  type: "b",
};

const cSchema = z.object({
  type: z.literal("c"),
});
const objC = {
  type: "c",
};

const dSchema = z.object({
  type: z.literal("d"),
});

const double = z.union([aSchema, bSchema]);
const many = z.union([aSchema, bSchema, cSchema, dSchema]);

doubleSuite
  .add("valid: a", () => {
    double.parse(objA);
  })
  .add("valid: b", () => {
    double.parse(objB);
  })
  .add("invalid: null", () => {
    try {
      double.parse(null);
    } catch (err) {}
  })
  .add("invalid: wrong shape", () => {
    try {
      double.parse(objC);
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(doubleSuite as any).name}: ${e.target}`);
  });

manySuite
  .add("valid: a", () => {
    many.parse(objA);
  })
  .add("valid: c", () => {
    many.parse(objC);
  })
  .add("invalid: null", () => {
    try {
      many.parse(null);
    } catch (err) {}
  })
  .add("invalid: wrong shape", () => {
    try {
      many.parse({ type: "unknown" });
    } catch (err) {}
  })
  .on("cycle", (e: Benchmark.Event) => {
    console.log(`${(manySuite as any).name}: ${e.target}`);
  });

export default {
  suites: [doubleSuite, manySuite],
};
````

## File: src/helpers/errorUtil.ts
````typescript
export namespace errorUtil {
  export type ErrMessage = string | { message?: string };
  export const errToObj = (message?: ErrMessage) =>
    typeof message === "string" ? { message } : message || {};
  export const toString = (message?: ErrMessage): string | undefined =>
    typeof message === "string" ? message : message?.message;
}
````

## File: src/helpers/parseUtil.ts
````typescript
import {
  defaultErrorMap,
  IssueData,
  overrideErrorMap,
  ZodErrorMap,
  ZodIssue,
} from "../ZodError";
import { util } from "./util";

export const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set",
]);

export type ZodParsedType = keyof typeof ZodParsedType;

export const getParsedType = (data: any): ZodParsedType => {
  const t = typeof data;

  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;

    case "string":
      return ZodParsedType.string;

    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;

    case "boolean":
      return ZodParsedType.boolean;

    case "function":
      return ZodParsedType.function;

    case "bigint":
      return ZodParsedType.bigint;

    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (
        data.then &&
        typeof data.then === "function" &&
        data.catch &&
        typeof data.catch === "function"
      ) {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;

    default:
      return ZodParsedType.unknown;
  }
};

export const makeIssue = (params: {
  data: any;
  path: (string | number)[];
  errorMaps: ZodErrorMap[];
  issueData: IssueData;
}): ZodIssue => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...(issueData.path || [])];
  const fullIssue = {
    ...issueData,
    path: fullPath,
  };

  let errorMessage = "";
  const maps = errorMaps
    .filter((m) => !!m)
    .slice()
    .reverse() as ZodErrorMap[];
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }

  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage,
  };
};

export type ParseParams = {
  path: (string | number)[];
  errorMap: ZodErrorMap;
  async: boolean;
};

export type ParsePathComponent = string | number;
export type ParsePath = ParsePathComponent[];
export const EMPTY_PATH: ParsePath = [];

export interface ParseContext {
  readonly common: {
    readonly issues: ZodIssue[];
    readonly contextualErrorMap?: ZodErrorMap;
    readonly async: boolean;
    readonly typeCache: Map<any, ZodParsedType> | undefined;
  };
  readonly path: ParsePath;
  readonly schemaErrorMap?: ZodErrorMap;
  readonly parent: ParseContext | null;
  readonly data: any;
  readonly parsedType: ZodParsedType;
}

export type ParseInput = {
  data: any;
  path: (string | number)[];
  parent: ParseContext;
};

export function addIssueToContext(
  ctx: ParseContext,
  issueData: IssueData
): void {
  const issue = makeIssue({
    issueData: issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap, // contextual error map is first priority
      ctx.schemaErrorMap, // then schema-bound map if available
      overrideErrorMap, // then global override map
      defaultErrorMap, // then global default map
    ].filter((x) => !!x) as ZodErrorMap[],
  });
  ctx.common.issues.push(issue);
}

export type ObjectPair = {
  key: SyncParseReturnType<any>;
  value: SyncParseReturnType<any>;
};
export class ParseStatus {
  value: "aborted" | "dirty" | "valid" = "valid";
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }

  static mergeArray(
    status: ParseStatus,
    results: SyncParseReturnType<any>[]
  ): SyncParseReturnType {
    const arrayValue: any[] = [];
    for (const s of results) {
      if (s.status === "aborted") return INVALID;
      if (s.status === "dirty") status.dirty();
      arrayValue.push(s.value);
    }

    return { status: status.value, value: arrayValue };
  }

  static async mergeObjectAsync(
    status: ParseStatus,
    pairs: { key: ParseReturnType<any>; value: ParseReturnType<any> }[]
  ): Promise<SyncParseReturnType<any>> {
    const syncPairs: ObjectPair[] = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value,
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }

  static mergeObjectSync(
    status: ParseStatus,
    pairs: {
      key: SyncParseReturnType<any>;
      value: SyncParseReturnType<any>;
      alwaysSet?: boolean;
    }[]
  ): SyncParseReturnType {
    const finalObject: any = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted") return INVALID;
      if (value.status === "aborted") return INVALID;
      if (key.status === "dirty") status.dirty();
      if (value.status === "dirty") status.dirty();

      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key.value] = value.value;
      }
    }

    return { status: status.value, value: finalObject };
  }
}
export interface ParseResult {
  status: "aborted" | "dirty" | "valid";
  data: any;
}

export type INVALID = { status: "aborted" };
export const INVALID: INVALID = Object.freeze({
  status: "aborted",
});

export type DIRTY<T> = { status: "dirty"; value: T };
export const DIRTY = <T>(value: T): DIRTY<T> => ({ status: "dirty", value });

export type OK<T> = { status: "valid"; value: T };
export const OK = <T>(value: T): OK<T> => ({ status: "valid", value });

export type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;
export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
export type ParseReturnType<T> =
  | SyncParseReturnType<T>
  | AsyncParseReturnType<T>;

export const isAborted = (x: ParseReturnType<any>): x is INVALID =>
  (x as any).status === "aborted";
export const isDirty = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
  (x as any).status === "dirty";
export const isValid = <T>(x: ParseReturnType<T>): x is OK<T> | DIRTY<T> =>
  (x as any).status === "valid";
export const isAsync = <T>(
  x: ParseReturnType<T>
): x is AsyncParseReturnType<T> =>
  typeof Promise !== undefined && x instanceof Promise;
````

## File: src/helpers/partialUtil.ts
````typescript
import type {
  ZodArray,
  ZodNullable,
  ZodObject,
  ZodOptional,
  ZodTuple,
  ZodTupleItems,
  ZodTypeAny,
} from "../index";

export namespace partialUtil {
  // export type DeepPartial<T extends AnyZodObject> = T extends AnyZodObject
  //   ? ZodObject<
  //       { [k in keyof T["_shape"]]: InternalDeepPartial<T["_shape"][k]> },
  //       T["_unknownKeys"],
  //       T["_catchall"]
  //     >
  //   : T extends ZodArray<infer Type, infer Card>
  //   ? ZodArray<InternalDeepPartial<Type>, Card>
  //   : ZodOptional<T>;

  // {
  //   // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
  //   // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
  //   object: T extends AnyZodObject
  //     ? ZodObject<
  //         { [k in keyof T["_shape"]]: DeepPartial<T["_shape"][k]> },
  //         T["_unknownKeys"],
  //         T["_catchall"]
  //       >
  //     : never;
  //   rest: ReturnType<T["optional"]>; // ZodOptional<T>;
  // }[T extends AnyZodObject
  //   ? "object" // T extends ZodOptional<any> // ? 'optional' // :
  //   : "rest"];

  export type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<
    infer Shape,
    infer Params,
    infer Catchall
  >
    ? ZodObject<
        { [k in keyof Shape]: ZodOptional<DeepPartial<Shape[k]>> },
        Params,
        Catchall
      >
    : T extends ZodArray<infer Type, infer Card>
    ? ZodArray<DeepPartial<Type>, Card>
    : T extends ZodOptional<infer Type>
    ? ZodOptional<DeepPartial<Type>>
    : T extends ZodNullable<infer Type>
    ? ZodNullable<DeepPartial<Type>>
    : T extends ZodTuple<infer Items>
    ? {
        [k in keyof Items]: Items[k] extends ZodTypeAny
          ? DeepPartial<Items[k]>
          : never;
      } extends infer PI
      ? PI extends ZodTupleItems
        ? ZodTuple<PI>
        : never
      : never
    : T;
  //  {
  //     // optional: T extends ZodOptional<ZodTypeAny> ? T : ZodOptional<T>;
  //     // array: T extends ZodArray<infer Type> ? ZodArray<DeepPartial<Type>> : never;
  //     object: T extends ZodObject<infer Shape, infer Params, infer Catchall>
  //       ? ZodOptional<
  //           ZodObject<
  //             { [k in keyof Shape]: DeepPartial<Shape[k]> },
  //             Params,
  //             Catchall
  //           >
  //         >
  //       : never;
  //     rest: ReturnType<T["optional"]>;
  //   }[T extends ZodObject<any>
  //     ? "object" // T extends ZodOptional<any> // ? 'optional' // :
  //     : "rest"];
}
````

## File: src/helpers/typeAliases.ts
````typescript
export type Primitive = string | number | bigint | boolean | null | undefined;
export type Scalars = Primitive | Primitive[];
````

## File: src/helpers/util.ts
````typescript
export namespace util {
  export type AssertEqual<T, Expected> = [T] extends [Expected]
    ? [Expected] extends [T]
      ? true
      : false
    : false;

  export function assertNever(_x: never): never {
    throw new Error();
  }

  export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
  export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;
  export type MakePartial<T, K extends keyof T> = Omit<T, K> &
    Partial<Pick<T, K>>;

  export const arrayToEnum = <T extends string, U extends [T, ...T[]]>(
    items: U
  ): { [k in U[number]]: k } => {
    const obj: any = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj as any;
  };

  export const getValidEnumValues = (obj: any) => {
    const validKeys = objectKeys(obj).filter(
      (k: any) => typeof obj[obj[k]] !== "number"
    );
    const filtered: any = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return objectValues(filtered);
  };

  export const objectValues = (obj: any) => {
    return objectKeys(obj).map(function (e) {
      return obj[e];
    });
  };

  export const objectKeys: ObjectConstructor["keys"] =
    typeof Object.keys === "function" // eslint-disable-line ban/ban
      ? (obj: any) => Object.keys(obj) // eslint-disable-line ban/ban
      : (object: any) => {
          const keys = [];
          for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
              keys.push(key);
            }
          }
          return keys;
        };

  export const find = <T>(
    arr: T[],
    checker: (arg: T) => any
  ): T | undefined => {
    for (const item of arr) {
      if (checker(item)) return item;
    }
    return undefined;
  };

  export type identity<T> = T;
  export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;
  export type noUndefined<T> = T extends undefined ? never : T;

  export const isInteger: NumberConstructor["isInteger"] =
    typeof Number.isInteger === "function"
      ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
      : (val) =>
          typeof val === "number" && isFinite(val) && Math.floor(val) === val;
}
````

## File: src/external.ts
````typescript
export * from "./helpers/parseUtil";
export * from "./helpers/typeAliases";
export * from "./types";
export * from "./ZodError";
````

## File: src/index.ts
````typescript
import * as mod from "./external";
export * from "./external";
export { mod as z };
export default mod;
````

## File: src/types.ts
````typescript
import { errorUtil } from "./helpers/errorUtil";
import {
  addIssueToContext,
  AsyncParseReturnType,
  DIRTY,
  getParsedType,
  INVALID,
  isAborted,
  isAsync,
  isDirty,
  isValid,
  makeIssue,
  OK,
  ParseContext,
  ParseInput,
  ParseParams,
  ParsePath,
  ParseReturnType,
  ParseStatus,
  SyncParseReturnType,
  ZodParsedType,
} from "./helpers/parseUtil";
import { partialUtil } from "./helpers/partialUtil";
import { Primitive } from "./helpers/typeAliases";
import { util } from "./helpers/util";
import {
  defaultErrorMap,
  IssueData,
  overrideErrorMap,
  StringValidation,
  ZodCustomIssue,
  ZodError,
  ZodErrorMap,
  ZodIssue,
  ZodIssueCode,
} from "./ZodError";

///////////////////////////////////////
///////////////////////////////////////
//////////                   //////////
//////////      ZodType      //////////
//////////                   //////////
///////////////////////////////////////
///////////////////////////////////////

export type RefinementCtx = {
  addIssue: (arg: IssueData) => void;
  path: (string | number)[];
};
export type ZodRawShape = { [k: string]: ZodTypeAny };
export type ZodTypeAny = ZodType<any, any, any>;
export type TypeOf<T extends ZodType<any, any, any>> = T["_output"];
export type input<T extends ZodType<any, any, any>> = T["_input"];
export type output<T extends ZodType<any, any, any>> = T["_output"];

type allKeys<T> = T extends any ? keyof T : never;
export type TypeOfFlattenedError<
  T extends ZodType<any, any, any>,
  U = string
> = {
  formErrors: U[];
  fieldErrors: {
    [P in allKeys<TypeOf<T>>]?: U[];
  };
};
export type TypeOfFormErrors<T extends ZodType<any, any, any>> =
  TypeOfFlattenedError<T>;
export type {
  TypeOf as infer,
  TypeOfFlattenedError as inferFlattenedErrors,
  TypeOfFormErrors as inferFormErrors,
};

export type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
export interface ZodTypeDef {
  errorMap?: ZodErrorMap;
  description?: string;
}

class ParseInputLazyPath implements ParseInput {
  parent: ParseContext;
  data: any;
  _path: ParsePath;
  _key: string | number | (string | number)[];
  constructor(
    parent: ParseContext,
    value: any,
    path: ParsePath,
    key: string | number | (string | number)[]
  ) {
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    return this._path.concat(this._key);
  }
}

const handleResult = <Input, Output>(
  ctx: ParseContext,
  result: SyncParseReturnType<Output>
):
  | { success: true; data: Output }
  | { success: false; error: ZodError<Input> } => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    const error = new ZodError(ctx.common.issues);
    return { success: false, error };
  }
};

type RawCreateParams =
  | {
      errorMap?: ZodErrorMap;
      invalid_type_error?: string;
      required_error?: string;
      description?: string;
    }
  | undefined;
type ProcessedCreateParams = { errorMap?: ZodErrorMap; description?: string };
function processCreateParams(params: RawCreateParams): ProcessedCreateParams {
  if (!params) return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(
      `Can't use "invalid" or "required" in conjunction with custom error map.`
    );
  }
  if (errorMap) return { errorMap: errorMap, description };
  const customMap: ZodErrorMap = (iss, ctx) => {
    if (iss.code !== "invalid_type") return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined" && required_error)
      return { message: required_error };
    if (params.invalid_type_error)
      return { message: params.invalid_type_error };
    return { message: ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

export type SafeParseSuccess<Output> = { success: true; data: Output };
export type SafeParseError<Input> = { success: false; error: ZodError<Input> };

export type SafeParseReturnType<Input, Output> =
  | SafeParseSuccess<Output>
  | SafeParseError<Input>;

export abstract class ZodType<
  Output = any,
  Def extends ZodTypeDef = ZodTypeDef,
  Input = Output
> {
  readonly _type!: Output;
  readonly _output!: Output;
  readonly _input!: Input;
  readonly _def!: Def;

  get description() {
    return this._def.description;
  }

  abstract _parse(input: ParseInput): ParseReturnType<Output>;

  _getType(input: ParseInput): string {
    return getParsedType(input.data);
  }

  _getOrReturnCtx(
    input: ParseInput,
    ctx?: ParseContext | undefined
  ): ParseContext {
    return (
      ctx || {
        common: input.parent.common,
        data: input.data,

        parsedType: getParsedType(input.data),

        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent,
      }
    );
  }

  _processInputParams(input: ParseInput): {
    status: ParseStatus;
    ctx: ParseContext;
  } {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,

        parsedType: getParsedType(input.data),

        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent,
      },
    };
  }

  _parseSync(input: ParseInput): SyncParseReturnType<Output> {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }

  _parseAsync(input: ParseInput): AsyncParseReturnType<Output> {
    const result = this._parse(input);

    return Promise.resolve(result);
  }

  parse(data: unknown, params?: Partial<ParseParams>): Output {
    const result = this.safeParse(data, params);
    if (result.success) return result.data;
    throw result.error;
  }

  safeParse(
    data: unknown,
    params?: Partial<ParseParams>
  ): SafeParseReturnType<Input, Output> {
    const ctx: ParseContext = {
      common: {
        issues: [],
        async: params?.async ?? false,
        typeCache: typeof Map !== "undefined" ? new Map() : undefined,
        contextualErrorMap: params?.errorMap,
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data),
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });

    return handleResult(ctx, result);
  }

  async parseAsync(
    data: unknown,
    params?: Partial<ParseParams>
  ): Promise<Output> {
    const result = await this.safeParseAsync(data, params);
    if (result.success) return result.data;
    throw result.error;
  }

  async safeParseAsync(
    data: unknown,
    params?: Partial<ParseParams>
  ): Promise<SafeParseReturnType<Input, Output>> {
    const ctx: ParseContext = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true,
        typeCache: typeof Map !== "undefined" ? new Map() : undefined,
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data),
    };

    const maybeAsyncResult = this._parse({ data, path: [], parent: ctx });
    const result = await (isAsync(maybeAsyncResult)
      ? maybeAsyncResult
      : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }

  /** Alias of safeParseAsync */
  spa = this.safeParseAsync;

  refine<RefinedOutput extends Output>(
    check: (arg: Output) => arg is RefinedOutput,
    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
  ): ZodEffects<this, RefinedOutput, RefinedOutput>;
  refine(
    check: (arg: Output) => unknown | Promise<unknown>,
    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
  ): ZodEffects<this, Output, Input>;
  refine(
    check: (arg: Output) => unknown,
    message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)
  ): ZodEffects<this, Output, Input> {
    const getIssueProperties: any = (val: Output) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () =>
        ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val),
        });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }

  refinement<RefinedOutput extends Output>(
    check: (arg: Output) => arg is RefinedOutput,
    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
  ): ZodEffects<this, RefinedOutput, RefinedOutput>;
  refinement(
    check: (arg: Output) => boolean,
    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
  ): ZodEffects<this, Output, Input>;
  refinement(
    check: (arg: Output) => unknown,
    refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)
  ): ZodEffects<this, Output, Input> {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(
          typeof refinementData === "function"
            ? refinementData(val, ctx)
            : refinementData
        );
        return false;
      } else {
        return true;
      }
    });
  }

  _refinement(
    refinement: RefinementEffect<Output>["refinement"]
  ): ZodEffects<this, Output, Input> {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement },
    });
  }
  superRefine = this._refinement;

  constructor(def: Def) {
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.default = this.default.bind(this);
    this.describe = this.describe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }

  optional(): ZodOptional<this> {
    ("");
    ("asdf");
    return ZodOptional.create(this) as any;
  }
  nullable(): ZodNullable<this> {
    return ZodNullable.create(this) as any;
  }
  nullish(): ZodNullable<ZodOptional<this>> {
    return this.optional().nullable();
  }
  array(): ZodArray<this> {
    return ZodArray.create(this);
  }
  promise(): ZodPromise<this> {
    return ZodPromise.create(this);
  }

  or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]> {
    return ZodUnion.create([this, option]) as any;
  }

  and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T> {
    return ZodIntersection.create(this, incoming);
  }

  transform<NewOut>(
    transform: (arg: Output) => NewOut | Promise<NewOut>
  ): ZodEffects<this, NewOut> {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform },
    }) as any;
  }

  default(def: util.noUndefined<Input>): ZodDefault<this>;
  default(def: () => util.noUndefined<Input>): ZodDefault<this>;
  default(def: any) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;

    return new ZodDefault({
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
    }) as any;
  }

  describe(description: string): this {
    const This = (this as any).constructor;
    return new This({
      ...this._def,
      description,
    });
  }

  isOptional(): boolean {
    return this.safeParse(undefined).success;
  }
  isNullable(): boolean {
    return this.safeParse(null).success;
  }
}

/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodString      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////
type ZodStringCheck =
  | { kind: "min"; value: number; message?: string }
  | { kind: "max"; value: number; message?: string }
  | { kind: "email"; message?: string }
  | { kind: "url"; message?: string }
  | { kind: "uuid"; message?: string }
  | { kind: "cuid"; message?: string }
  | { kind: "regex"; regex: RegExp; message?: string };

export interface ZodStringDef extends ZodTypeDef {
  checks: ZodStringCheck[];
  typeName: ZodFirstPartyTypeKind.ZodString;
}

const cuidRegex = /^c[^\s-]{8,}$/i;
const uuidRegex =
  /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
// eslint-disable-next-line
const emailRegex =
  /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;

export class ZodString extends ZodType<string, ZodStringDef> {
  _parse(input: ParseInput): ParseReturnType<string> {
    const parsedType = this._getType(input);

    if (parsedType !== ZodParsedType.string) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx.parsedType,
        }
        //
      );
      return INVALID;
    }

    const status = new ParseStatus();
    let ctx: undefined | ParseContext = undefined;

    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message,
          });
          status.dirty();
        }
      }
    }

    return { status: status.value, value: input.data };
  }

  protected _regex = (
    regex: RegExp,
    validation: StringValidation,
    message?: errorUtil.ErrMessage
  ) =>
    this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message),
    });

  _addCheck(check: ZodStringCheck) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check],
    });
  }

  email(message?: errorUtil.ErrMessage) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message?: errorUtil.ErrMessage) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  uuid(message?: errorUtil.ErrMessage) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message?: errorUtil.ErrMessage) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  regex(regex: RegExp, message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "regex",
      regex: regex,
      ...errorUtil.errToObj(message),
    });
  }

  min(minLength: number, message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message),
    });
  }

  max(maxLength: number, message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message),
    });
  }

  length(len: number, message?: errorUtil.ErrMessage) {
    return this.min(len, message).max(len, message);
  }

  /**
   * Deprecated.
   * Use z.string().min(1) instead.
   */
  nonempty = (message?: errorUtil.ErrMessage) =>
    this.min(1, errorUtil.errToObj(message));

  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get minLength() {
    let min: number | null = -Infinity;
    this._def.checks.map((ch) => {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) {
          min = ch.value;
        }
      }
    });
    return min;
  }
  get maxLength() {
    let max: number | null = null;
    this._def.checks.map((ch) => {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) {
          max = ch.value;
        }
      }
    });
    return max;
  }
  static create = (params?: RawCreateParams): ZodString => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      ...processCreateParams(params),
    });
  };
}

/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodNumber      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////
type ZodNumberCheck =
  | { kind: "min"; value: number; inclusive: boolean; message?: string }
  | { kind: "max"; value: number; inclusive: boolean; message?: string }
  | { kind: "int"; message?: string }
  | { kind: "multipleOf"; value: number; message?: string };

// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val: number, step: number) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return (valInt % stepInt) / Math.pow(10, decCount);
}

export interface ZodNumberDef extends ZodTypeDef {
  checks: ZodNumberCheck[];
  typeName: ZodFirstPartyTypeKind.ZodNumber;
}

export class ZodNumber extends ZodType<number, ZodNumberDef> {
  _parse(input: ParseInput): ParseReturnType<number> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    let ctx: undefined | ParseContext = undefined;
    const status = new ParseStatus();

    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive
          ? input.data < check.value
          : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive
          ? input.data > check.value
          : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            message: check.message,
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message,
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }

    return { status: status.value, value: input.data };
  }

  static create = (params?: RawCreateParams): ZodNumber => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      ...processCreateParams(params),
    });
  };

  gte(value: number, message?: errorUtil.ErrMessage) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  min = this.gte;

  gt(value: number, message?: errorUtil.ErrMessage) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }

  lte(value: number, message?: errorUtil.ErrMessage) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  max = this.lte;

  lt(value: number, message?: errorUtil.ErrMessage) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }

  protected setLimit(
    kind: "min" | "max",
    value: number,
    inclusive: boolean,
    message?: string
  ) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message),
        },
      ],
    });
  }

  _addCheck(check: ZodNumberCheck) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check],
    });
  }

  int(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message),
    });
  }

  positive(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }

  negative(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }

  nonpositive(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message),
    });
  }

  nonnegative(message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message),
    });
  }

  multipleOf(value: number, message?: errorUtil.ErrMessage) {
    return this._addCheck({
      kind: "multipleOf",
      value: value,
      message: errorUtil.toString(message),
    });
  }

  step = this.multipleOf;

  get minValue() {
    let min: number | null = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }

  get maxValue() {
    let max: number | null = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max;
  }

  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int");
  }
}

/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodBigInt      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////

export interface ZodBigIntDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodBigInt;
}

export class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {
  _parse(input: ParseInput): ParseReturnType<bigint> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }

  static create = (params?: RawCreateParams): ZodBigInt => {
    return new ZodBigInt({
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////////
//////////////////////////////////////////
//////////                     ///////////
//////////      ZodBoolean      //////////
//////////                     ///////////
//////////////////////////////////////////
//////////////////////////////////////////
export interface ZodBooleanDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodBoolean;
}

export class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {
  _parse(input: ParseInput): ParseReturnType<boolean> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }

  static create = (params?: RawCreateParams): ZodBoolean => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      ...processCreateParams(params),
    });
  };
}

///////////////////////////////////////
///////////////////////////////////////
//////////                     ////////
//////////      ZodDate        ////////
//////////                     ////////
///////////////////////////////////////
///////////////////////////////////////
export interface ZodDateDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodDate;
}

export class ZodDate extends ZodType<Date, ZodDateDef> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_date,
      });
      return INVALID;
    }

    return {
      status: "valid",
      value: new Date((input.data as Date).getTime()),
    };
  }

  static create = (params?: RawCreateParams): ZodDate => {
    return new ZodDate({
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params),
    });
  };
}

////////////////////////////////////////////
////////////////////////////////////////////
//////////                        //////////
//////////      ZodUndefined      //////////
//////////                        //////////
////////////////////////////////////////////
////////////////////////////////////////////
export interface ZodUndefinedDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodUndefined;
}

export class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
  params?: RawCreateParams;

  static create = (params?: RawCreateParams): ZodUndefined => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params),
    });
  };
}

///////////////////////////////////////
///////////////////////////////////////
//////////                   //////////
//////////      ZodNull      //////////
//////////                   //////////
///////////////////////////////////////
///////////////////////////////////////
export interface ZodNullDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodNull;
}

export class ZodNull extends ZodType<null, ZodNullDef> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
  static create = (params?: RawCreateParams): ZodNull => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////
//////////////////////////////////////
//////////                  //////////
//////////      ZodAny      //////////
//////////                  //////////
//////////////////////////////////////
//////////////////////////////////////
export interface ZodAnyDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodAny;
}

export class ZodAny extends ZodType<any, ZodAnyDef> {
  // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
  _any: true = true;
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    return OK(input.data);
  }
  static create = (params?: RawCreateParams): ZodAny => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////////
//////////////////////////////////////////
//////////                      //////////
//////////      ZodUnknown      //////////
//////////                      //////////
//////////////////////////////////////////
//////////////////////////////////////////
export interface ZodUnknownDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodUnknown;
}

export class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {
  // required
  _unknown: true = true;
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    return OK(input.data);
  }

  static create = (params?: RawCreateParams): ZodUnknown => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params),
    });
  };
}

////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      ZodNever      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
export interface ZodNeverDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodNever;
}

export class ZodNever extends ZodType<never, ZodNeverDef> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType,
    });
    return INVALID;
  }
  static create = (params?: RawCreateParams): ZodNever => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params),
    });
  };
}

///////////////////////////////////////
///////////////////////////////////////
//////////                   //////////
//////////      ZodVoid      //////////
//////////                   //////////
///////////////////////////////////////
///////////////////////////////////////
export interface ZodVoidDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodVoid;
}

export class ZodVoid extends ZodType<void, ZodVoidDef> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }

  static create = (params?: RawCreateParams): ZodVoid => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params),
    });
  };
}

////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      ZodArray      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
export interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  type: T;
  typeName: ZodFirstPartyTypeKind.ZodArray;
  minLength: { value: number; message?: string } | null;
  maxLength: { value: number; message?: string } | null;
}

export type ArrayCardinality = "many" | "atleastone";
type arrayOutputType<
  T extends ZodTypeAny,
  Cardinality extends ArrayCardinality = "many"
> = Cardinality extends "atleastone"
  ? [T["_output"], ...T["_output"][]]
  : T["_output"][];

export class ZodArray<
  T extends ZodTypeAny,
  Cardinality extends ArrayCardinality = "many"
> extends ZodType<
  arrayOutputType<T, Cardinality>,
  ZodArrayDef<T>,
  Cardinality extends "atleastone"
    ? [T["_input"], ...T["_input"][]]
    : T["_input"][]
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { ctx, status } = this._processInputParams(input);

    const def = this._def;

    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          message: def.minLength.message,
        });
        status.dirty();
      }
    }

    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          message: def.maxLength.message,
        });
        status.dirty();
      }
    }

    if (ctx.common.async) {
      return Promise.all(
        (ctx.data as any[]).map((item, i) => {
          return def.type._parseAsync(
            new ParseInputLazyPath(ctx, item, ctx.path, i)
          );
        })
      ).then((result) => {
        return ParseStatus.mergeArray(status, result);
      });
    }

    const result = (ctx.data as any[]).map((item, i) => {
      return def.type._parseSync(
        new ParseInputLazyPath(ctx, item, ctx.path, i)
      );
    });

    return ParseStatus.mergeArray(status, result);
  }

  get element() {
    return this._def.type;
  }

  min(minLength: number, message?: errorUtil.ErrMessage): this {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) },
    }) as any;
  }

  max(maxLength: number, message?: errorUtil.ErrMessage): this {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) },
    }) as any;
  }

  length(len: number, message?: errorUtil.ErrMessage): this {
    return this.min(len, message).max(len, message) as any;
  }

  nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone"> {
    return this.min(1, message) as any;
  }

  static create = <T extends ZodTypeAny>(
    schema: T,
    params?: RawCreateParams
  ): ZodArray<T> => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params),
    });
  };
}

export type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, "atleastone">;

/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodObject      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////

export namespace objectUtil {
  export type MergeShapes<U extends ZodRawShape, V extends ZodRawShape> = {
    [k in Exclude<keyof U, keyof V>]: U[k];
  } & V;

  type optionalKeys<T extends object> = {
    [k in keyof T]: undefined extends T[k] ? k : never;
  }[keyof T];

  // type requiredKeys<T extends object> = Exclude<keyof T, optionalKeys<T>>;
  type requiredKeys<T extends object> = {
    [k in keyof T]: undefined extends T[k] ? never : k;
  }[keyof T];

  export type addQuestionMarks<T extends object> = {
    [k in optionalKeys<T>]?: T[k];
  } & { [k in requiredKeys<T>]: T[k] };

  export type identity<T> = T;
  export type flatten<T extends object> = identity<{ [k in keyof T]: T[k] }>;

  export type noNeverKeys<T extends ZodRawShape> = {
    [k in keyof T]: [T[k]] extends [never] ? never : k;
  }[keyof T];

  export type noNever<T extends ZodRawShape> = identity<{
    [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
  }>;

  export const mergeShapes = <U extends ZodRawShape, T extends ZodRawShape>(
    first: U,
    second: T
  ): T & U => {
    return {
      ...first,
      ...second, // second overwrites first
    };
  };
}

export type extendShape<A, B> = {
  [k in Exclude<keyof A, keyof B>]: A[k];
} & { [k in keyof B]: B[k] };

const AugmentFactory =
  <Def extends ZodObjectDef>(def: Def) =>
  <Augmentation extends ZodRawShape>(
    augmentation: Augmentation
  ): ZodObject<
    extendShape<ReturnType<Def["shape"]>, Augmentation>,
    Def["unknownKeys"],
    Def["catchall"]
  > => {
    return new ZodObject({
      ...def,
      shape: () => ({
        ...def.shape(),
        ...augmentation,
      }),
    }) as any;
  };

type UnknownKeysParam = "passthrough" | "strict" | "strip";

export interface ZodObjectDef<
  T extends ZodRawShape = ZodRawShape,
  UnknownKeys extends UnknownKeysParam = UnknownKeysParam,
  Catchall extends ZodTypeAny = ZodTypeAny
> extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodObject;
  shape: () => T;
  catchall: Catchall;
  unknownKeys: UnknownKeys;
}

export type baseObjectOutputType<Shape extends ZodRawShape> =
  objectUtil.flatten<
    objectUtil.addQuestionMarks<{
      [k in keyof Shape]: Shape[k]["_output"];
    }>
  >;

export type objectOutputType<
  Shape extends ZodRawShape,
  Catchall extends ZodTypeAny
> = ZodTypeAny extends Catchall
  ? baseObjectOutputType<Shape>
  : objectUtil.flatten<
      baseObjectOutputType<Shape> & { [k: string]: Catchall["_output"] }
    >;

export type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.flatten<
  objectUtil.addQuestionMarks<{
    [k in keyof Shape]: Shape[k]["_input"];
  }>
>;

export type objectInputType<
  Shape extends ZodRawShape,
  Catchall extends ZodTypeAny
> = ZodTypeAny extends Catchall
  ? baseObjectInputType<Shape>
  : objectUtil.flatten<
      baseObjectInputType<Shape> & { [k: string]: Catchall["_input"] }
    >;

type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U>
  ? deoptional<U>
  : T;

export type SomeZodObject = ZodObject<
  ZodRawShape,
  UnknownKeysParam,
  ZodTypeAny,
  any,
  any
>;

function deepPartialify(schema: ZodTypeAny): any {
  if (schema instanceof ZodObject) {
    const newShape: any = {};

    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape,
    }) as any;
  } else if (schema instanceof ZodArray) {
    return ZodArray.create(deepPartialify(schema.element));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(
      schema.items.map((item: any) => deepPartialify(item))
    );
  } else {
    return schema;
  }
}

export class ZodObject<
  T extends ZodRawShape,
  UnknownKeys extends UnknownKeysParam = "strip",
  Catchall extends ZodTypeAny = ZodTypeAny,
  Output = objectOutputType<T, Catchall>,
  Input = objectInputType<T, Catchall>
> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
  readonly _shape!: T;
  readonly _unknownKeys!: UnknownKeys;
  readonly _catchall!: Catchall;
  private _cached: { shape: T; keys: string[] } | null = null;

  _getCached(): { shape: T; keys: string[] } {
    if (this._cached !== null) return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return (this._cached = { shape, keys });
  }

  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    const { status, ctx } = this._processInputParams(input);

    const { shape, keys: shapeKeys } = this._getCached();
    const dataKeys = util.objectKeys(ctx.data);
    const extraKeys = dataKeys.filter((k) => !shapeKeys.includes(k));

    const pairs: {
      key: ParseReturnType<any>;
      value: ParseReturnType<any>;
      alwaysSet?: boolean;
    }[] = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(
          new ParseInputLazyPath(ctx, value, ctx.path, key)
        ),
        alwaysSet: key in ctx.data,
      });
    }

    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;

      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] },
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys,
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      // run catchall validation
      const catchall = this._def.catchall;

      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data,
        });
      }
    }

    if (ctx.common.async) {
      return Promise.resolve()
        .then(async () => {
          const syncPairs: any[] = [];
          for (const pair of pairs) {
            const key = await pair.key;
            syncPairs.push({
              key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet,
            });
          }
          return syncPairs;
        })
        .then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs as any);
    }
  }

  get shape() {
    return this._def.shape();
  }

  strict(message?: errorUtil.ErrMessage): ZodObject<T, "strict", Catchall> {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...(message !== undefined
        ? {
            errorMap: (issue, ctx) => {
              const defaultError =
                this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message).message ?? defaultError,
                };
              return {
                message: defaultError,
              };
            },
          }
        : {}),
    }) as any;
  }

  strip(): ZodObject<T, "strip", Catchall> {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip",
    }) as any;
  }

  passthrough(): ZodObject<T, "passthrough", Catchall> {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough",
    }) as any;
  }

  /**
   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
   * If you want to pass through unknown properties, use `.passthrough()` instead.
   */
  nonstrict = this.passthrough;

  augment = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);
  extend = AugmentFactory<ZodObjectDef<T, UnknownKeys, Catchall>>(this._def);

  setKey<Key extends string, Schema extends ZodTypeAny>(
    key: Key,
    schema: Schema
  ): ZodObject<T & { [k in Key]: Schema }, UnknownKeys, Catchall> {
    return this.augment({ [key]: schema }) as any;
  }

  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge<Incoming extends AnyZodObject>(
    merging: Incoming
  ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  ZodObject<extendShape<T, Incoming["_shape"]>, UnknownKeys, Catchall> {
    // const mergedShape = objectUtil.mergeShapes(
    //   this._def.shape(),
    //   merging._def.shape()
    // );
    const merged: any = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () =>
        objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      typeName: ZodFirstPartyTypeKind.ZodObject,
    }) as any;
    return merged;
  }

  catchall<Index extends ZodTypeAny>(
    index: Index
  ): ZodObject<T, UnknownKeys, Index> {
    return new ZodObject({
      ...this._def,
      catchall: index,
    }) as any;
  }

  pick<Mask extends { [k in keyof T]?: true }>(
    mask: Mask
  ): ZodObject<
    objectUtil.noNever<{ [k in keyof Mask]: k extends keyof T ? T[k] : never }>,
    UnknownKeys,
    Catchall
  > {
    const shape: any = {};
    util.objectKeys(mask).map((key) => {
      shape[key] = this.shape[key];
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape,
    }) as any;
  }

  omit<Mask extends { [k in keyof T]?: true }>(
    mask: Mask
  ): ZodObject<
    objectUtil.noNever<{ [k in keyof T]: k extends keyof Mask ? never : T[k] }>,
    UnknownKeys,
    Catchall
  > {
    const shape: any = {};
    util.objectKeys(this.shape).map((key) => {
      if (util.objectKeys(mask).indexOf(key) === -1) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape,
    }) as any;
  }

  deepPartial(): partialUtil.DeepPartial<this> {
    return deepPartialify(this) as any;
  }

  partial(): ZodObject<
    { [k in keyof T]: ZodOptional<T[k]> },
    UnknownKeys,
    Catchall
  >;
  partial<Mask extends { [k in keyof T]?: true }>(
    mask: Mask
  ): ZodObject<
    objectUtil.noNever<{
      [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
    }>,
    UnknownKeys,
    Catchall
  >;
  partial(mask?: any) {
    const newShape: any = {};
    if (mask) {
      util.objectKeys(this.shape).map((key) => {
        if (util.objectKeys(mask).indexOf(key) === -1) {
          newShape[key] = this.shape[key];
        } else {
          newShape[key] = this.shape[key].optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape,
      }) as any;
    } else {
      for (const key in this.shape) {
        const fieldSchema = this.shape[key];
        newShape[key] = fieldSchema.optional();
      }
    }

    return new ZodObject({
      ...this._def,
      shape: () => newShape,
    }) as any;
  }

  required(): ZodObject<
    { [k in keyof T]: deoptional<T[k]> },
    UnknownKeys,
    Catchall
  > {
    const newShape: any = {};
    for (const key in this.shape) {
      const fieldSchema = this.shape[key];
      let newField = fieldSchema;
      while (newField instanceof ZodOptional) {
        newField = (newField as ZodOptional<any>)._def.innerType;
      }

      newShape[key] = newField;
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape,
    }) as any;
  }

  static create = <T extends ZodRawShape>(
    shape: T,
    params?: RawCreateParams
  ): ZodObject<T> => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params),
    }) as any;
  };

  static strictCreate = <T extends ZodRawShape>(
    shape: T,
    params?: RawCreateParams
  ): ZodObject<T, "strict"> => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params),
    }) as any;
  };

  static lazycreate = <T extends ZodRawShape>(
    shape: () => T,
    params?: RawCreateParams
  ): ZodObject<T> => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params),
    }) as any;
  };
}

export type AnyZodObject = ZodObject<any, any, any>;

////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      ZodUnion      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
export interface ZodUnionDef<
  T extends ZodUnionOptions = Readonly<
    [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]
  >
> extends ZodTypeDef {
  options: T;
  typeName: ZodFirstPartyTypeKind.ZodUnion;
}

export class ZodUnion<T extends ZodUnionOptions> extends ZodType<
  T[number]["_output"],
  ZodUnionDef<T>,
  T[number]["_input"]
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;

    function handleResults(
      results: { ctx: ParseContext; result: SyncParseReturnType<any> }[]
    ) {
      // return first issue-free validation if it exists
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }

      for (const result of results) {
        if (result.result.status === "dirty") {
          // add issues from dirty option

          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }

      // return invalid
      const unionErrors = results.map(
        (result) => new ZodError(result.ctx.common.issues)
      );

      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors,
      });
      return INVALID;
    }

    if (ctx.common.async) {
      return Promise.all(
        options.map(async (option) => {
          const childCtx: ParseContext = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: [],
            },
            parent: null,
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx,
            }),
            ctx: childCtx,
          };
        })
      ).then(handleResults);
    } else {
      let dirty: undefined | { result: DIRTY<any>; ctx: ParseContext } =
        undefined;
      const issues: ZodIssue[][] = [];
      for (const option of options) {
        const childCtx: ParseContext = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: [],
          },
          parent: null,
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx,
        });

        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }

        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }

      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }

      const unionErrors = issues.map((issues) => new ZodError(issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors,
      });

      return INVALID;
    }
  }

  get options() {
    return this._def.options;
  }

  static create = <
    T extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>
  >(
    types: T,
    params?: RawCreateParams
  ): ZodUnion<T> => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params),
    });
  };
}

/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////

export type ZodDiscriminatedUnionOption<
  Discriminator extends string,
  DiscriminatorValue extends Primitive
> = ZodObject<
  { [key in Discriminator]: ZodLiteral<DiscriminatorValue> } & ZodRawShape,
  any,
  any
>;

export interface ZodDiscriminatedUnionDef<
  Discriminator extends string,
  DiscriminatorValue extends Primitive,
  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
> extends ZodTypeDef {
  discriminator: Discriminator;
  options: Map<DiscriminatorValue, Option>;
  typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
}

export class ZodDiscriminatedUnion<
  Discriminator extends string,
  DiscriminatorValue extends Primitive,
  Option extends ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>
> extends ZodType<
  Option["_output"],
  ZodDiscriminatedUnionDef<Discriminator, DiscriminatorValue, Option>,
  Option["_input"]
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { ctx } = this._processInputParams(input);

    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    const discriminator = this.discriminator;
    const discriminatorValue: DiscriminatorValue = ctx.data[discriminator];
    const option = this.options.get(discriminatorValue);

    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: this.validDiscriminatorValues,
        path: [discriminator],
      });
      return INVALID;
    }

    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx,
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx,
      });
    }
  }

  get discriminator() {
    return this._def.discriminator;
  }

  get validDiscriminatorValues() {
    return Array.from(this.options.keys());
  }

  get options() {
    return this._def.options;
  }

  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create<
    Discriminator extends string,
    DiscriminatorValue extends Primitive,
    Types extends [
      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
      ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>,
      ...ZodDiscriminatedUnionOption<Discriminator, DiscriminatorValue>[]
    ]
  >(
    discriminator: Discriminator,
    types: Types,
    params?: RawCreateParams
  ): ZodDiscriminatedUnion<Discriminator, DiscriminatorValue, Types[number]> {
    // Get all the valid discriminator values
    const options: Map<DiscriminatorValue, Types[number]> = new Map();

    try {
      types.forEach((type) => {
        const discriminatorValue = type.shape[discriminator].value;
        options.set(discriminatorValue, type);
      });
    } catch (e) {
      throw new Error(
        "The discriminator value could not be extracted from all the provided schemas"
      );
    }

    // Assert that all the discriminator values are unique
    if (options.size !== types.length) {
      throw new Error("Some of the discriminator values are not unique");
    }

    return new ZodDiscriminatedUnion<
      Discriminator,
      DiscriminatorValue,
      Types[number]
    >({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      ...processCreateParams(params),
    });
  }
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////                           //////////
//////////      ZodIntersection      //////////
//////////                           //////////
///////////////////////////////////////////////
///////////////////////////////////////////////
export interface ZodIntersectionDef<
  T extends ZodTypeAny = ZodTypeAny,
  U extends ZodTypeAny = ZodTypeAny
> extends ZodTypeDef {
  left: T;
  right: U;
  typeName: ZodFirstPartyTypeKind.ZodIntersection;
}

function mergeValues(
  a: any,
  b: any
): { valid: true; data: any } | { valid: false } {
  const aType = getParsedType(a);
  const bType = getParsedType(b);

  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util
      .objectKeys(a)
      .filter((key) => bKeys.indexOf(key) !== -1);

    const newObj: any = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }

    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }

    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);

      if (!sharedValue.valid) {
        return { valid: false };
      }

      newArray.push(sharedValue.data);
    }

    return { valid: true, data: newArray };
  } else if (
    aType === ZodParsedType.date &&
    bType === ZodParsedType.date &&
    +a === +b
  ) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}

export class ZodIntersection<
  T extends ZodTypeAny,
  U extends ZodTypeAny
> extends ZodType<
  T["_output"] & U["_output"],
  ZodIntersectionDef<T, U>,
  T["_input"] & U["_input"]
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (
      parsedLeft: SyncParseReturnType,
      parsedRight: SyncParseReturnType
    ): SyncParseReturnType<T & U> => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }

      const merged = mergeValues(parsedLeft.value, parsedRight.value);

      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types,
        });
        return INVALID;
      }

      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }

      return { status: status.value, value: merged.data as any };
    };

    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
      ]).then(([left, right]: any) => handleParsed(left, right));
    } else {
      return handleParsed(
        this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
        this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        })
      );
    }
  }

  static create = <T extends ZodTypeAny, U extends ZodTypeAny>(
    left: T,
    right: U,
    params?: RawCreateParams
  ): ZodIntersection<T, U> => {
    return new ZodIntersection({
      left: left,
      right: right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params),
    });
  };
}

////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      ZodTuple      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
export type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
export type AssertArray<T> = T extends any[] ? T : never;
export type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_output"] : never;
}>;
export type OutputTypeOfTupleWithRest<
  T extends ZodTupleItems | [],
  Rest extends ZodTypeAny | null = null
> = Rest extends ZodTypeAny
  ? [...OutputTypeOfTuple<T>, ...Rest["_output"][]]
  : OutputTypeOfTuple<T>;

export type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
  [k in keyof T]: T[k] extends ZodType<any, any> ? T[k]["_input"] : never;
}>;
export type InputTypeOfTupleWithRest<
  T extends ZodTupleItems | [],
  Rest extends ZodTypeAny | null = null
> = Rest extends ZodTypeAny
  ? [...InputTypeOfTuple<T>, ...Rest["_input"][]]
  : InputTypeOfTuple<T>;

export interface ZodTupleDef<
  T extends ZodTupleItems | [] = ZodTupleItems,
  Rest extends ZodTypeAny | null = null
> extends ZodTypeDef {
  items: T;
  rest: Rest;
  typeName: ZodFirstPartyTypeKind.ZodTuple;
}

export class ZodTuple<
  T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]],
  Rest extends ZodTypeAny | null = null
> extends ZodType<
  OutputTypeOfTupleWithRest<T, Rest>,
  ZodTupleDef<T, Rest>,
  InputTypeOfTupleWithRest<T, Rest>
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        type: "array",
      });

      return INVALID;
    }

    const rest = this._def.rest;

    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        type: "array",
      });
      status.dirty();
    }

    const items = (ctx.data as any[])
      .map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema) return null as any as SyncParseReturnType<any>;
        return schema._parse(
          new ParseInputLazyPath(ctx, item, ctx.path, itemIndex)
        );
      })
      .filter((x) => !!x); // filter nulls

    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items as SyncParseReturnType[]);
    }
  }

  get items() {
    return this._def.items;
  }

  rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest> {
    return new ZodTuple({
      ...this._def,
      rest,
    });
  }

  static create = <T extends [ZodTypeAny, ...ZodTypeAny[]] | []>(
    schemas: T,
    params?: RawCreateParams
  ): ZodTuple<T, null> => {
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params),
    });
  };
}

/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodRecord      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////
export interface ZodRecordDef<
  Key extends KeySchema = ZodString,
  Value extends ZodTypeAny = ZodTypeAny
> extends ZodTypeDef {
  valueType: Value;
  keyType: Key;
  typeName: ZodFirstPartyTypeKind.ZodRecord;
}

type KeySchema = ZodType<string | number | symbol, any, any>;
type RecordType<K extends string | number | symbol, V> = [string] extends [K]
  ? Record<K, V>
  : [number] extends [K]
  ? Record<K, V>
  : [symbol] extends [K]
  ? Record<K, V>
  : Partial<Record<K, V>>;
export class ZodRecord<
  Key extends KeySchema = ZodString,
  Value extends ZodTypeAny = ZodTypeAny
> extends ZodType<
  RecordType<Key["_output"], Value["_output"]>,
  ZodRecordDef<Key, Value>,
  RecordType<Key["_input"], Value["_input"]>
> {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    const pairs: {
      key: ParseReturnType<any>;
      value: ParseReturnType<any>;
    }[] = [];

    const keyType = this._def.keyType;
    const valueType = this._def.valueType;

    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(
          new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)
        ),
      });
    }

    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs as any);
    }
  }

  get element() {
    return this._def.valueType;
  }

  static create<Value extends ZodTypeAny>(
    valueType: Value,
    params?: RawCreateParams
  ): ZodRecord<ZodString, Value>;
  static create<Keys extends KeySchema, Value extends ZodTypeAny>(
    keySchema: Keys,
    valueType: Value,
    params?: RawCreateParams
  ): ZodRecord<Keys, Value>;
  static create(first: any, second?: any, third?: any): ZodRecord<any, any> {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third),
      });
    }

    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second),
    });
  }
}

//////////////////////////////////////
//////////////////////////////////////
//////////                  //////////
//////////      ZodMap      //////////
//////////                  //////////
//////////////////////////////////////
//////////////////////////////////////
export interface ZodMapDef<
  Key extends ZodTypeAny = ZodTypeAny,
  Value extends ZodTypeAny = ZodTypeAny
> extends ZodTypeDef {
  valueType: Value;
  keyType: Key;
  typeName: ZodFirstPartyTypeKind.ZodMap;
}

export class ZodMap<
  Key extends ZodTypeAny = ZodTypeAny,
  Value extends ZodTypeAny = ZodTypeAny
> extends ZodType<
  Map<Key["_output"], Value["_output"]>,
  ZodMapDef<Key, Value>,
  Map<Key["_input"], Value["_input"]>
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    const keyType = this._def.keyType;
    const valueType = this._def.valueType;

    const pairs = [...(ctx.data as Map<unknown, unknown>).entries()].map(
      ([key, value], index) => {
        return {
          key: keyType._parse(
            new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])
          ),
          value: valueType._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])
          ),
        };
      }
    );

    if (ctx.common.async) {
      const finalMap = new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }

          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map();
      for (const pair of pairs) {
        const key = pair.key as SyncParseReturnType;
        const value = pair.value as SyncParseReturnType;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }

        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
  static create = <
    Key extends ZodTypeAny = ZodTypeAny,
    Value extends ZodTypeAny = ZodTypeAny
  >(
    keyType: Key,
    valueType: Value,
    params?: RawCreateParams
  ): ZodMap<Key, Value> => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////
//////////////////////////////////////
//////////                  //////////
//////////      ZodSet      //////////
//////////                  //////////
//////////////////////////////////////
//////////////////////////////////////
export interface ZodSetDef<Value extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  valueType: Value;
  typeName: ZodFirstPartyTypeKind.ZodSet;
  minSize: { value: number; message?: string } | null;
  maxSize: { value: number; message?: string } | null;
}

export class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<
  Set<Value["_output"]>,
  ZodSetDef<Value>,
  Set<Value["_input"]>
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    const def = this._def;

    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          message: def.minSize.message,
        });
        status.dirty();
      }
    }

    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          message: def.maxSize.message,
        });
        status.dirty();
      }
    }

    const valueType = this._def.valueType;

    function finalizeSet(elements: SyncParseReturnType<any>[]) {
      const parsedSet = new Set();
      for (const element of elements) {
        if (element.status === "aborted") return INVALID;
        if (element.status === "dirty") status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }

    const elements = [...(ctx.data as Set<unknown>).values()].map((item, i) =>
      valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i))
    );

    if (ctx.common.async) {
      return Promise.all(elements).then((elements) => finalizeSet(elements));
    } else {
      return finalizeSet(elements as SyncParseReturnType[]);
    }
  }

  min(minSize: number, message?: errorUtil.ErrMessage): this {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) },
    }) as any;
  }

  max(maxSize: number, message?: errorUtil.ErrMessage): this {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) },
    }) as any;
  }

  size(size: number, message?: errorUtil.ErrMessage): this {
    return this.min(size, message).max(size, message) as any;
  }

  nonempty(message?: errorUtil.ErrMessage): ZodSet<Value> {
    return this.min(1, message) as any;
  }

  static create = <Value extends ZodTypeAny = ZodTypeAny>(
    valueType: Value,
    params?: RawCreateParams
  ): ZodSet<Value> => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params),
    });
  };
}

///////////////////////////////////////////
///////////////////////////////////////////
//////////                       //////////
//////////      ZodFunction      //////////
//////////                       //////////
///////////////////////////////////////////
///////////////////////////////////////////
export interface ZodFunctionDef<
  Args extends ZodTuple<any, any> = ZodTuple<any, any>,
  Returns extends ZodTypeAny = ZodTypeAny
> extends ZodTypeDef {
  args: Args;
  returns: Returns;
  typeName: ZodFirstPartyTypeKind.ZodFunction;
}

export type OuterTypeOfFunction<
  Args extends ZodTuple<any, any>,
  Returns extends ZodTypeAny
> = Args["_input"] extends Array<any>
  ? (...args: Args["_input"]) => Returns["_output"]
  : never;

export type InnerTypeOfFunction<
  Args extends ZodTuple<any, any>,
  Returns extends ZodTypeAny
> = Args["_output"] extends Array<any>
  ? (...args: Args["_output"]) => Returns["_input"]
  : never;

export class ZodFunction<
  Args extends ZodTuple<any, any>,
  Returns extends ZodTypeAny
> extends ZodType<
  OuterTypeOfFunction<Args, Returns>,
  ZodFunctionDef<Args, Returns>,
  InnerTypeOfFunction<Args, Returns>
> {
  _parse(input: ParseInput): ParseReturnType<any> {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    function makeArgsIssue(args: any, error: ZodError): ZodIssue {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          overrideErrorMap,
          defaultErrorMap,
        ].filter((x) => !!x) as ZodErrorMap[],
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error,
        },
      });
    }

    function makeReturnsIssue(returns: any, error: ZodError): ZodIssue {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          overrideErrorMap,
          defaultErrorMap,
        ].filter((x) => !!x) as ZodErrorMap[],
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error,
        },
      });
    }

    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;

    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args: any[]) => {
        const error = new ZodError([]);
        const parsedArgs = await this._def.args
          .parseAsync(args, params)
          .catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
        const result = await fn(...(parsedArgs as any));
        const parsedReturns = await (
          this._def.returns as ZodPromise<ZodTypeAny>
        )._def.type
          .parseAsync(result, params)
          .catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
        return parsedReturns;
      });
    } else {
      return OK((...args: any[]) => {
        const parsedArgs = this._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn(...(parsedArgs.data as any));
        const parsedReturns = this._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      }) as any;
    }
  }

  parameters() {
    return this._def.args;
  }

  returnType() {
    return this._def.returns;
  }

  args<Items extends Parameters<typeof ZodTuple["create"]>[0]>(
    ...items: Items
  ): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns> {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create()) as any,
    });
  }

  returns<NewReturnType extends ZodType<any, any>>(
    returnType: NewReturnType
  ): ZodFunction<Args, NewReturnType> {
    return new ZodFunction({
      ...this._def,
      returns: returnType,
    });
  }

  implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): F {
    const validatedFunc = this.parse(func);
    return validatedFunc as any;
  }

  strictImplement(
    func: InnerTypeOfFunction<Args, Returns>
  ): InnerTypeOfFunction<Args, Returns> {
    const validatedFunc = this.parse(func);
    return validatedFunc as any;
  }

  validate = this.implement;

  static create = <
    T extends ZodTuple<any, any> = ZodTuple<[], ZodUnknown>,
    U extends ZodTypeAny = ZodUnknown
  >(
    args?: T,
    returns?: U,
    params?: RawCreateParams
  ): ZodFunction<T, U> => {
    return new ZodFunction({
      args: (args
        ? args.rest(ZodUnknown.create())
        : ZodTuple.create([]).rest(ZodUnknown.create())) as any,
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params),
    }) as any;
  };
}

///////////////////////////////////////
///////////////////////////////////////
//////////                   //////////
//////////      ZodLazy      //////////
//////////                   //////////
///////////////////////////////////////
///////////////////////////////////////
export interface ZodLazyDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  getter: () => T;
  typeName: ZodFirstPartyTypeKind.ZodLazy;
}

export class ZodLazy<T extends ZodTypeAny> extends ZodType<
  output<T>,
  ZodLazyDef<T>,
  input<T>
> {
  get schema(): T {
    return this._def.getter();
  }

  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }

  static create = <T extends ZodTypeAny>(
    getter: () => T,
    params?: RawCreateParams
  ): ZodLazy<T> => {
    return new ZodLazy({
      getter: getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////////
//////////////////////////////////////////
//////////                      //////////
//////////      ZodLiteral      //////////
//////////                      //////////
//////////////////////////////////////////
//////////////////////////////////////////
export interface ZodLiteralDef<T = any> extends ZodTypeDef {
  value: T;
  typeName: ZodFirstPartyTypeKind.ZodLiteral;
}

export class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value,
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }

  get value() {
    return this._def.value;
  }

  static create = <T extends Primitive>(
    value: T,
    params?: RawCreateParams
  ): ZodLiteral<T> => {
    return new ZodLiteral({
      value: value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params),
    });
  };
}

///////////////////////////////////////
///////////////////////////////////////
//////////                   //////////
//////////      ZodEnum      //////////
//////////                   //////////
///////////////////////////////////////
///////////////////////////////////////
export type ArrayKeys = keyof any[];
export type Indices<T> = Exclude<keyof T, ArrayKeys>;

type EnumValues = [string, ...string[]];

type Values<T extends EnumValues> = {
  [k in T[number]]: k;
};

export interface ZodEnumDef<T extends EnumValues = EnumValues>
  extends ZodTypeDef {
  values: T;
  typeName: ZodFirstPartyTypeKind.ZodEnum;
}

type Writeable<T> = { -readonly [P in keyof T]: T[P] };

function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(
  values: T
): ZodEnum<Writeable<T>>;
function createZodEnum<U extends string, T extends [U, ...U[]]>(
  values: T
): ZodEnum<T>;
function createZodEnum(values: any) {
  return new ZodEnum({
    values: values as any,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
  }) as any;
}

export class ZodEnum<T extends [string, ...string[]]> extends ZodType<
  T[number],
  ZodEnumDef<T>
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_enum_value,
        options: this._def.values,
      });
      return INVALID;
    }
    return OK(input.data);
  }

  get options() {
    return this._def.values;
  }

  get enum(): Values<T> {
    const enumValues: any = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues as any;
  }

  get Values(): Values<T> {
    const enumValues: any = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues as any;
  }

  get Enum(): Values<T> {
    const enumValues: any = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues as any;
  }

  static create = createZodEnum;
}

/////////////////////////////////////////////
/////////////////////////////////////////////
//////////                         //////////
//////////      ZodNativeEnum      //////////
//////////                         //////////
/////////////////////////////////////////////
/////////////////////////////////////////////
export interface ZodNativeEnumDef<T extends EnumLike = EnumLike>
  extends ZodTypeDef {
  values: T;
  typeName: ZodFirstPartyTypeKind.ZodNativeEnum;
}

type EnumLike = { [k: string]: string | number; [nu: number]: string };

export class ZodNativeEnum<T extends EnumLike> extends ZodType<
  T[keyof T],
  ZodNativeEnumDef<T>
> {
  _parse(input: ParseInput): ParseReturnType<T[keyof T]> {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_enum_value,
        options: util.objectValues(nativeEnumValues),
      });
      return INVALID;
    }
    return OK(input.data);
  }

  get enum() {
    return this._def.values;
  }

  static create = <T extends EnumLike>(
    values: T,
    params?: RawCreateParams
  ): ZodNativeEnum<T> => {
    return new ZodNativeEnum({
      values: values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////////
//////////////////////////////////////////
//////////                      //////////
//////////      ZodPromise      //////////
//////////                      //////////
//////////////////////////////////////////
//////////////////////////////////////////
export interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  type: T;
  typeName: ZodFirstPartyTypeKind.ZodPromise;
}

export class ZodPromise<T extends ZodTypeAny> extends ZodType<
  Promise<T["_output"]>,
  ZodPromiseDef<T>,
  Promise<T["_input"]>
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { ctx } = this._processInputParams(input);
    if (
      ctx.parsedType !== ZodParsedType.promise &&
      ctx.common.async === false
    ) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    const promisified =
      ctx.parsedType === ZodParsedType.promise
        ? ctx.data
        : Promise.resolve(ctx.data);

    return OK(
      promisified.then((data: any) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap,
        });
      })
    );
  }

  static create = <T extends ZodTypeAny>(
    schema: T,
    params?: RawCreateParams
  ): ZodPromise<T> => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params),
    });
  };
}

//////////////////////////////////////////////
//////////////////////////////////////////////
//////////                          //////////
//////////        ZodEffects        //////////
//////////                          //////////
//////////////////////////////////////////////
//////////////////////////////////////////////

export type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
export type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void;

export type RefinementEffect<T> = {
  type: "refinement";
  refinement: (arg: T, ctx: RefinementCtx) => any;
};
export type TransformEffect<T> = {
  type: "transform";
  transform: (arg: T) => any;
};
export type PreprocessEffect<T> = {
  type: "preprocess";
  transform: (arg: T) => any;
};
export type Effect<T> =
  | RefinementEffect<T>
  | TransformEffect<T>
  | PreprocessEffect<T>;

export interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  schema: T;
  typeName: ZodFirstPartyTypeKind.ZodEffects;
  effect: Effect<any>;
}

export class ZodEffects<
  T extends ZodTypeAny,
  Output = T["_output"],
  Input = T["_input"]
> extends ZodType<Output, ZodEffectsDef<T>, Input> {
  innerType() {
    return this._def.schema;
  }

  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { status, ctx } = this._processInputParams(input);

    const effect = this._def.effect || null;

    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);

      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed) => {
          return this._def.schema._parseAsync({
            data: processed,
            path: ctx.path,
            parent: ctx,
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx,
        });
      }
    }

    if (effect.type === "refinement") {
      const checkCtx: RefinementCtx = {
        addIssue: (arg: IssueData) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        },
      };

      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);

      const executeRefinement = (
        acc: unknown
        // effect: RefinementEffect<any>
      ): any => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
          );
        }
        return acc;
      };

      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
        if (inner.status === "aborted") return INVALID;
        if (inner.status === "dirty") status.dirty();

        // return value is ignored
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema
          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
          .then((inner) => {
            if (inner.status === "aborted") return INVALID;
            if (inner.status === "dirty") status.dirty();

            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
      }
    }

    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
        // if (base.status === "aborted") return INVALID;
        // if (base.status === "dirty") {
        //   return { status: "dirty", value: base.value };
        // }
        if (!isValid(base)) return base;

        const result = effect.transform(base.value);
        if (result instanceof Promise) {
          throw new Error(
            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
          );
        }
        return OK(result);
      } else {
        return this._def.schema
          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
          .then((base) => {
            if (!isValid(base)) return base;
            // if (base.status === "aborted") return INVALID;
            // if (base.status === "dirty") {
            //   return { status: "dirty", value: base.value };
            // }
            return Promise.resolve(effect.transform(base.value)).then(OK);
          });
      }
    }

    util.assertNever(effect);
  }

  static create = <I extends ZodTypeAny>(
    schema: I,
    effect: Effect<I["_output"]>,
    params?: RawCreateParams
  ): ZodEffects<I, I["_output"]> => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params),
    });
  };

  static createWithPreprocess = <I extends ZodTypeAny>(
    preprocess: (arg: unknown) => unknown,
    schema: I,
    params?: RawCreateParams
  ): ZodEffects<I, I["_output"]> => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params),
    });
  };
}

export { ZodEffects as ZodTransformer };

///////////////////////////////////////////
///////////////////////////////////////////
//////////                       //////////
//////////      ZodOptional      //////////
//////////                       //////////
///////////////////////////////////////////
///////////////////////////////////////////
export interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  innerType: T;
  typeName: ZodFirstPartyTypeKind.ZodOptional;
}

export type ZodOptionalType<T extends ZodTypeAny> = ZodOptional<T>;

export class ZodOptional<T extends ZodTypeAny> extends ZodType<
  T["_output"] | undefined,
  ZodOptionalDef<T>,
  T["_input"] | undefined
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }

  unwrap() {
    return this._def.innerType;
  }

  static create = <T extends ZodTypeAny>(
    type: T,
    params?: RawCreateParams
  ): ZodOptional<T> => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params),
    }) as any;
  };
}

///////////////////////////////////////////
///////////////////////////////////////////
//////////                       //////////
//////////      ZodNullable      //////////
//////////                       //////////
///////////////////////////////////////////
///////////////////////////////////////////
export interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  innerType: T;
  typeName: ZodFirstPartyTypeKind.ZodNullable;
}

export type ZodNullableType<T extends ZodTypeAny> = ZodNullable<T>;

export class ZodNullable<T extends ZodTypeAny> extends ZodType<
  T["_output"] | null,
  ZodNullableDef<T>,
  T["_input"] | null
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }

  unwrap() {
    return this._def.innerType;
  }

  static create = <T extends ZodTypeAny>(
    type: T,
    params?: RawCreateParams
  ): ZodNullable<T> => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params),
    }) as any;
  };
}

////////////////////////////////////////////
////////////////////////////////////////////
//////////                        //////////
//////////       ZodDefault       //////////
//////////                        //////////
////////////////////////////////////////////
////////////////////////////////////////////
export interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny>
  extends ZodTypeDef {
  innerType: T;
  defaultValue: () => util.noUndefined<T["_input"]>;
  typeName: ZodFirstPartyTypeKind.ZodDefault;
}

export class ZodDefault<T extends ZodTypeAny> extends ZodType<
  util.noUndefined<T["_output"]>,
  ZodDefaultDef<T>,
  T["_input"] | undefined
> {
  _parse(input: ParseInput): ParseReturnType<this["_output"]> {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx,
    });
  }

  removeDefault() {
    return this._def.innerType;
  }

  static create = <T extends ZodTypeAny>(
    type: T,
    params?: RawCreateParams
  ): ZodOptional<T> => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params),
    }) as any;
  };
}

/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodNaN         //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////

export interface ZodNaNDef extends ZodTypeDef {
  typeName: ZodFirstPartyTypeKind.ZodNaN;
}

export class ZodNaN extends ZodType<number, ZodNaNDef> {
  _parse(input: ParseInput): ParseReturnType<any> {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType,
      });
      return INVALID;
    }

    return { status: "valid", value: input.data };
  }

  static create = (params?: RawCreateParams): ZodNaN => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params),
    });
  };
}

export const custom = <T>(
  check?: (data: unknown) => any,
  params?: Parameters<ZodTypeAny["refine"]>[1]
): ZodType<T> => {
  if (check) return ZodAny.create().refine(check, params);
  return ZodAny.create();
};

export { ZodType as Schema, ZodType as ZodSchema };

export const late = {
  object: ZodObject.lazycreate,
};

export enum ZodFirstPartyTypeKind {
  ZodString = "ZodString",
  ZodNumber = "ZodNumber",
  ZodNaN = "ZodNaN",
  ZodBigInt = "ZodBigInt",
  ZodBoolean = "ZodBoolean",
  ZodDate = "ZodDate",
  ZodUndefined = "ZodUndefined",
  ZodNull = "ZodNull",
  ZodAny = "ZodAny",
  ZodUnknown = "ZodUnknown",
  ZodNever = "ZodNever",
  ZodVoid = "ZodVoid",
  ZodArray = "ZodArray",
  ZodObject = "ZodObject",
  ZodUnion = "ZodUnion",
  ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
  ZodIntersection = "ZodIntersection",
  ZodTuple = "ZodTuple",
  ZodRecord = "ZodRecord",
  ZodMap = "ZodMap",
  ZodSet = "ZodSet",
  ZodFunction = "ZodFunction",
  ZodLazy = "ZodLazy",
  ZodLiteral = "ZodLiteral",
  ZodEnum = "ZodEnum",
  ZodEffects = "ZodEffects",
  ZodNativeEnum = "ZodNativeEnum",
  ZodOptional = "ZodOptional",
  ZodNullable = "ZodNullable",
  ZodDefault = "ZodDefault",
  ZodPromise = "ZodPromise",
}
export type ZodFirstPartySchemaTypes =
  | ZodString
  | ZodNumber
  | ZodNaN
  | ZodBigInt
  | ZodBoolean
  | ZodDate
  | ZodUndefined
  | ZodNull
  | ZodAny
  | ZodUnknown
  | ZodNever
  | ZodVoid
  | ZodArray<any, any>
  | ZodObject<any, any, any, any, any>
  | ZodUnion<any>
  | ZodDiscriminatedUnion<any, any, any>
  | ZodIntersection<any, any>
  | ZodTuple<any, any>
  | ZodRecord<any, any>
  | ZodMap<any>
  | ZodSet<any>
  | ZodFunction<any, any>
  | ZodLazy<any>
  | ZodLiteral<any>
  | ZodEnum<any>
  | ZodEffects<any, any, any>
  | ZodNativeEnum<any>
  | ZodOptional<any>
  | ZodNullable<any>
  | ZodDefault<any>
  | ZodPromise<any>;

const instanceOfType = <T extends new (...args: any[]) => any>(
  cls: T,
  params: Parameters<ZodTypeAny["refine"]>[1] = {
    message: `Input not instance of ${cls.name}`,
  }
) => custom<InstanceType<T>>((data) => data instanceof cls, params);

const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();

export {
  anyType as any,
  arrayType as array,
  bigIntType as bigint,
  booleanType as boolean,
  dateType as date,
  discriminatedUnionType as discriminatedUnion,
  effectsType as effect,
  enumType as enum,
  functionType as function,
  instanceOfType as instanceof,
  intersectionType as intersection,
  lazyType as lazy,
  literalType as literal,
  mapType as map,
  nanType as nan,
  nativeEnumType as nativeEnum,
  neverType as never,
  nullType as null,
  nullableType as nullable,
  numberType as number,
  objectType as object,
  oboolean,
  onumber,
  optionalType as optional,
  ostring,
  preprocessType as preprocess,
  promiseType as promise,
  recordType as record,
  setType as set,
  strictObjectType as strictObject,
  stringType as string,
  effectsType as transformer,
  tupleType as tuple,
  undefinedType as undefined,
  unionType as union,
  unknownType as unknown,
  voidType as void,
};
````

## File: src/ZodError.ts
````typescript
import { ZodParsedType } from "./helpers/parseUtil";
import { Primitive } from "./helpers/typeAliases";
import { util } from "./helpers/util";

export const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
]);

export type ZodIssueCode = keyof typeof ZodIssueCode;

export type ZodIssueBase = {
  path: (string | number)[];
  message?: string;
};

export interface ZodInvalidTypeIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_type;
  expected: ZodParsedType;
  received: ZodParsedType;
}

export interface ZodInvalidLiteralIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_literal;
  expected: unknown;
}

export interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.unrecognized_keys;
  keys: string[];
}

export interface ZodInvalidUnionIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_union;
  unionErrors: ZodError[];
}

export interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_union_discriminator;
  options: Primitive[];
}

export interface ZodInvalidEnumValueIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_enum_value;
  options: (string | number)[];
}

export interface ZodInvalidArgumentsIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_arguments;
  argumentsError: ZodError;
}

export interface ZodInvalidReturnTypeIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_return_type;
  returnTypeError: ZodError;
}

export interface ZodInvalidDateIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_date;
}

export type StringValidation = "email" | "url" | "uuid" | "regex" | "cuid";

export interface ZodInvalidStringIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_string;
  validation: StringValidation;
}

export interface ZodTooSmallIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.too_small;
  minimum: number;
  inclusive: boolean;
  type: "array" | "string" | "number" | "set";
}

export interface ZodTooBigIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.too_big;
  maximum: number;
  inclusive: boolean;
  type: "array" | "string" | "number" | "set";
}

export interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.invalid_intersection_types;
}

export interface ZodNotMultipleOfIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.not_multiple_of;
  multipleOf: number;
}

export interface ZodCustomIssue extends ZodIssueBase {
  code: typeof ZodIssueCode.custom;
  params?: { [k: string]: any };
}

export type DenormalizedError = { [k: string]: DenormalizedError | string[] };

export type ZodIssueOptionalMessage =
  | ZodInvalidTypeIssue
  | ZodInvalidLiteralIssue
  | ZodUnrecognizedKeysIssue
  | ZodInvalidUnionIssue
  | ZodInvalidUnionDiscriminatorIssue
  | ZodInvalidEnumValueIssue
  | ZodInvalidArgumentsIssue
  | ZodInvalidReturnTypeIssue
  | ZodInvalidDateIssue
  | ZodInvalidStringIssue
  | ZodTooSmallIssue
  | ZodTooBigIssue
  | ZodInvalidIntersectionTypesIssue
  | ZodNotMultipleOfIssue
  | ZodCustomIssue;

export type ZodIssue = ZodIssueOptionalMessage & { message: string };

export const quotelessJson = (obj: any) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

export type ZodFormattedError<T> = {
  _errors: string[];
} & (T extends [any, ...any[]]
  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
  : T extends any[]
  ? ZodFormattedError<T[number]>[]
  : T extends object
  ? { [K in keyof T]?: ZodFormattedError<T[K]> }
  : unknown);

export class ZodError<T = any> extends Error {
  issues: ZodIssue[] = [];

  get errors() {
    return this.issues;
  }

  constructor(issues: ZodIssue[]) {
    super();

    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      // eslint-disable-next-line ban/ban
      Object.setPrototypeOf(this, actualProto);
    } else {
      (this as any).__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }

  format = (): ZodFormattedError<T> => {
    const fieldErrors: ZodFormattedError<T> = { _errors: [] } as any;
    const processError = (error: ZodError) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          (fieldErrors as any)._errors.push(issue.message);
        } else {
          let curr: any = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;

            if (!terminal) {
              if (typeof el === "string") {
                curr[el] = curr[el] || { _errors: [] };
              } else if (typeof el === "number") {
                const errorArray: any = [];
                errorArray._errors = [];
                curr[el] = curr[el] || errorArray;
              }
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(issue.message);
            }

            curr = curr[el];
            i++;
          }
        }
      }
    };

    processError(this);
    return fieldErrors;
  };

  static create = (issues: ZodIssue[]) => {
    const error = new ZodError(issues);
    return error;
  };

  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, null, 2);
  }

  get isEmpty(): boolean {
    return this.issues.length === 0;
  }

  addIssue = (sub: ZodIssue) => {
    this.issues = [...this.issues, sub];
  };

  addIssues = (subs: ZodIssue[] = []) => {
    this.issues = [...this.issues, ...subs];
  };

  flatten(mapper?: (issue: ZodIssue) => string): {
    formErrors: string[];
    fieldErrors: { [k: string]: string[] };
  };
  flatten<U>(mapper?: (issue: ZodIssue) => U): {
    formErrors: U[];
    fieldErrors: { [k: string]: U[] };
  };
  flatten<U = string>(
    mapper: (issue: ZodIssue) => U = (issue: ZodIssue) => issue.message as any
  ): {
    formErrors: U[];
    fieldErrors: { [k: string]: U[] };
  } {
    const fieldErrors: any = {};
    const formErrors: U[] = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }

  get formErrors() {
    return this.flatten();
  }
}

type stripPath<T extends object> = T extends any
  ? util.OmitKeys<T, "path">
  : never;

export type IssueData = stripPath<ZodIssueOptionalMessage> & {
  path?: (string | number)[];
  fatal?: boolean;
};
export type MakeErrorData = IssueData;

type ErrorMapCtx = {
  defaultError: string;
  data: any;
};

export type ZodErrorMap = typeof defaultErrorMap;
export const defaultErrorMap = (
  issue: ZodIssueOptionalMessage,
  _ctx: ErrorMapCtx
): { message: string } => {
  let message: string;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === "undefined") {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(
        issue.expected
      )}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${issue.keys
        .map((k) => `'${k}'`)
        .join(", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${issue.options
        .map((val) => (typeof val === "string" ? `'${val}'` : val))
        .join(" | ")}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${issue.options
        .map((val) => (typeof val === "string" ? `'${val}'` : val))
        .join(" | ")}`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
      else message = "Invalid";
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${
          issue.inclusive ? `at least` : `more than`
        } ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${
          issue.inclusive ? `at least` : `over`
        } ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be greater than ${
          issue.inclusive ? `or equal to ` : ``
        }${issue.minimum}`;
      else message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${
          issue.inclusive ? `at most` : `less than`
        } ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${
          issue.inclusive ? `at most` : `under`
        } ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be less than ${
          issue.inclusive ? `or equal to ` : ``
        }${issue.maximum}`;
      else message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};

export let overrideErrorMap = defaultErrorMap;

export const setErrorMap = (map: ZodErrorMap) => {
  overrideErrorMap = map;
};
````

## File: .dependency-cruiser.js
````javascript
module.exports = {
  forbidden: [
    /* rules from the 'recommended' preset: */
    {
      name: "no-circular",
      severity: "warn",
      comment:
        "This dependency is part of a circular relationship. You might want to revise " +
        "your solution (i.e. use dependency inversion, make sure the modules have a single responsibility) ",
      from: {},
      to: {
        circular: true,
      },
    },
    {
      name: "no-deprecated-core",
      comment:
        "A module depends on a node core module that has been deprecated. Find an alternative - these are " +
        "bound to exist - node doesn't deprecate lightly.",
      severity: "warn",
      from: {},
      to: {
        dependencyTypes: ["core"],
        path: [
          "^(v8/tools/codemap)$",
          "^(v8/tools/consarray)$",
          "^(v8/tools/csvparser)$",
          "^(v8/tools/logreader)$",
          "^(v8/tools/profile_view)$",
          "^(v8/tools/profile)$",
          "^(v8/tools/SourceMap)$",
          "^(v8/tools/splaytree)$",
          "^(v8/tools/tickprocessor-driver)$",
          "^(v8/tools/tickprocessor)$",
          "^(node-inspect/lib/_inspect)$",
          "^(node-inspect/lib/internal/inspect_client)$",
          "^(node-inspect/lib/internal/inspect_repl)$",
          "^(async_hooks)$",
          "^(assert)$",
          "^(punycode)$",
          "^(domain)$",
          "^(constants)$",
          "^(sys)$",
          "^(_linklist)$",
          "^(_stream_wrap)$",
        ],
      },
    },
    {
      name: "not-to-deprecated",
      comment:
        "This module uses a (version of an) npm module that has been deprecated. Either upgrade to a later " +
        "version of that module, or find an alternative. Deprecated modules are a security risk.",
      severity: "warn",
      from: {},
      to: {
        dependencyTypes: ["deprecated"],
      },
    },
    {
      name: "no-non-package-json",
      severity: "error",
      comment:
        "This module depends on an npm package that isn't in the 'dependencies' section of your package.json. " +
        "That's problematic as the package either (1) won't be available on live (2 - worse) will be " +
        "available on live with an non-guaranteed version. Fix it by adding the package to the dependencies " +
        "in your package.json.",
      from: {},
      to: {
        dependencyTypes: ["npm-no-pkg", "npm-unknown"],
      },
    },
    {
      name: "not-to-unresolvable",
      comment:
        "This module depends on a module that cannot be found ('resolved to disk'). If it's an npm " +
        "module: add it to your package.json. In all other cases you likely already know what to do.",
      severity: "error",
      from: {},
      to: {
        couldNotResolve: true,
      },
    },
    {
      name: "no-duplicate-dep-types",
      comment:
        "Likely this module depends on an external ('npm') package that occurs more than once " +
        "in your package.json i.e. bot as a devDependencies and in dependencies. This will cause " +
        "maintenance problems later on.",
      severity: "warn",
      from: {},
      to: {
        moreThanOneDependencyType: true,
      },
    },

    /* rules you might want to tweak for your specific situation: */
    {
      name: "not-to-spec",
      comment:
        "This module depends on a spec (test) file. The sole responsibility of a spec file is to test code. " +
        "If there's something in a spec that's of use to other modules, it doesn't have that single " +
        "responsibility anymore. Factor it out into (e.g.) a separate utility/ helper or a mock.",
      severity: "error",
      from: {},
      to: {
        path: "\\.(spec|test)\\.(js|mjs|cjs|ts|ls|coffee|litcoffee|coffee\\.md)$",
      },
    },
    {
      name: "not-to-dev-dep",
      severity: "error",
      comment:
        "This module depends on an npm package from the 'devDependencies' section of your " +
        "package.json. It looks like something that ships to production, though. To prevent problems " +
        "with npm packages that aren't there on production declare it (only!) in the 'dependencies'" +
        "section of your package.json. If this module is development only - add it to the " +
        "from.pathNot re of the not-to-dev-dep rule in the dependency-cruiser configuration",
      from: {
        path: "^(src)",
        pathNot:
          "\\.(spec|test)\\.(js|mjs|cjs|ts|ls|coffee|litcoffee|coffee\\.md)$",
      },
      to: {
        dependencyTypes: ["npm-dev"],
      },
    },
    {
      name: "optional-deps-used",
      severity: "info",
      comment:
        "This module depends on an npm package that is declared as an optional dependency " +
        "in your package.json. As this makes sense in limited situations only, it's flagged here. " +
        "If you're using an optional dependency here by design - add an exception to your" +
        "dependency-cruiser configuration.",
      from: {},
      to: {
        dependencyTypes: ["npm-optional"],
      },
    },
    {
      name: "peer-deps-used",
      comment:
        "This module depends on an npm package that is declared as a peer dependency " +
        "in your package.json. This makes sense if your package is e.g. a plugin, but in " +
        "other cases - maybe not so much. If the use of a peer dependency is intentional " +
        "add an exception to your dependency-cruiser configuration.",
      severity: "warn",
      from: {},
      to: {
        dependencyTypes: ["npm-peer"],
      },
    },
  ],
  options: {
    /* conditions specifying which files not to follow further when encountered:
       - path: a regular expression to match
       - dependencyTypes: see https://github.com/sverweij/dependency-cruiser/blob/master/doc/rules-reference.md#dependencytypes
       for a complete list
    */
    doNotFollow: {
      path: "node_modules",
      dependencyTypes: [
        "npm",
        "npm-dev",
        "npm-optional",
        "npm-peer",
        "npm-bundled",
        "npm-no-pkg",
      ],
    },

    /* conditions specifying which dependencies to exclude
       - path: a regular expression to match
       - dynamic: a boolean indicating whether to ignore dynamic (true) or static (false) dependencies.
          leave out if you want to exclude neither (recommended!)
    */
    // exclude : {
    //   path: '',
    //   dynamic: true
    // },

    /* pattern specifying which files to include (regular expression)
       dependency-cruiser will skip everything not matching this pattern
    */
    // includeOnly : '',

    /* dependency-cruiser will include modules matching against the focus
       regular expression in its output, as well as their neighbours (direct
       dependencies and dependents)
    */
    // focus : '',

    /* list of module systems to cruise */
    // moduleSystems: ['amd', 'cjs', 'es6', 'tsd'],

    /* prefix for links in html and svg output (e.g. 'https://github.com/you/yourrepo/blob/develop/'
       to open it on your online repo or `vscode://file/${process.cwd()}/` to 
       open it in visual studio code),
     */
    // prefix: '',

    /* false (the default): ignore dependencies that only exist before typescript-to-javascript compilation
       true: also detect dependencies that only exist before typescript-to-javascript compilation
       "specify": for each dependency identify whether it only exists before compilation or also after
     */
    // tsPreCompilationDeps: false,

    /* if true combines the package.jsons found from the module up to the base
       folder the cruise is initiated from. Useful for how (some) mono-repos
       manage dependencies & dependency definitions.
     */
    // combinedDependencies: false,

    /* if true leave symlinks untouched, otherwise use the realpath */
    // preserveSymlinks: false,

    /* TypeScript project file ('tsconfig.json') to use for
       (1) compilation and
       (2) resolution (e.g. with the paths property)

       The (optional) fileName attribute specifies which file to take (relative to
       dependency-cruiser's current working directory). When not provided
       defaults to './tsconfig.json'.
     */
    tsConfig: {
      fileName: "tsconfig.json",
    },

    /* Webpack configuration to use to get resolve options from.

       The (optional) fileName attribute specifies which file to take (relative
       to dependency-cruiser's current working directory. When not provided defaults
       to './webpack.conf.js'.

       The (optional) `env` and `args` attributes contain the parameters to be passed if
       your webpack config is a function and takes them (see webpack documentation
       for details)
     */
    // webpackConfig: {
    //  fileName: './webpack.config.js',
    //  env: {},
    //  args: {},
    // },

    /* Babel config ('.babelrc', '.babelrc.json', '.babelrc.json5', ...) to use
      for compilation (and whatever other naughty things babel plugins do to
      source code). This feature is well tested and usable, but might change
      behavior a bit over time (e.g. more precise results for used module 
      systems) without dependency-cruiser getting a major version bump.
     */
    // babelConfig: {
    //   fileName: './.babelrc'
    // },

    /* How to resolve external modules - use "yarn-pnp" if you're using yarn's Plug'n'Play.
       otherwise leave it out (or set to the default, which is 'node_modules')
    */
    // externalModuleResolutionStrategy: 'node_modules',
    /* List of strings you have in use in addition to cjs/ es6 requires
       & imports to declare module dependencies. Use this e.g. if you've
       redeclared require, use a require-wrapper or use window.require as
       a hack.
    */
    // exoticRequireStrings: [],
    reporterOptions: {
      dot: {
        /* pattern of modules that can be consolidated in the detailed
           graphical dependency graph. The default pattern in this configuration
           collapses everything in node_modules to one folder deep so you see
           the external modules, but not the innards your app depends upon.
         */
        collapsePattern: "node_modules/[^/]+",

        /* Options to tweak the appearance of your graph.See
           https://github.com/sverweij/dependency-cruiser/blob/master/doc/options-reference.md#reporteroptions
           for details and some examples. If you don't specify a theme
           don't worry - dependency-cruiser will fall back to the default one.
        */
        // theme: {
        //   graph: {
        //     /* use splines: "ortho" for straight lines. Be aware though
        //       graphviz might take a long time calculating ortho(gonal)
        //       routings.
        //    */
        //     splines: "true"
        //   },
        //   modules: [
        //     {
        //       criteria: { source: "^src/model" },
        //       attributes: { fillcolor: "#ccccff" }
        //     },
        //     {
        //       criteria: { source: "^src/view" },
        //       attributes: { fillcolor: "#ccffcc" }
        //     }
        //   ],
        //   dependencies: [
        //     {
        //       criteria: { "rules[0].severity": "error" },
        //       attributes: { fontcolor: "red", color: "red" }
        //     },
        //     {
        //       criteria: { "rules[0].severity": "warn" },
        //       attributes: { fontcolor: "orange", color: "orange" }
        //     },
        //     {
        //       criteria: { "rules[0].severity": "info" },
        //       attributes: { fontcolor: "blue", color: "blue" }
        //     },
        //     {
        //       criteria: { resolved: "^src/model" },
        //       attributes: { color: "#0000ff77" }
        //     },
        //     {
        //       criteria: { resolved: "^src/view" },
        //       attributes: { color: "#00770077" }
        //     }
        //   ]
        // }
      },
      archi: {
        /* pattern of modules that can be consolidated in the high level
          graphical dependency graph. If you use the high level graphical
          dependency graph reporter (`archi`) you probably want to tweak
          this collapsePattern to your situation.
        */
        collapsePattern:
          "^(node_modules|packages|src|lib|app|bin|test(s?)|spec(s?))/[^/]+",

        /* Options to tweak the appearance of your graph.See
           https://github.com/sverweij/dependency-cruiser/blob/master/doc/options-reference.md#reporteroptions
           for details and some examples. If you don't specify a theme
           for 'archi' dependency-cruiser will use the one specified in the
           dot section (see above), if any, and otherwise use the default one.
         */
        // theme: {
        // },
      },
    },
  },
};
// generated: dependency-cruiser@9.19.0 on 2020-12-12T06:59:50.855Z
````

## File: .editorconfig
````
# EditorConfig is awesome: https://EditorConfig.org

# top-most EditorConfig file
root = true

# Unix-style newlines with a newline ending every file
[*]
end_of_line = lf
insert_final_newline = true
indent_style = space
indent_size = 2
charset = utf-8
````

## File: .eslintrc.js
````javascript
module.exports = {
  env: { browser: true, node: true },
  root: true,
  parser: "@typescript-eslint/parser",
  plugins: [
    "@typescript-eslint",
    "import",
    "simple-import-sort",
    "unused-imports",
    "ban",
  ],
  extends: [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "prettier",
  ],
  rules: {
    "import/order": 0, // turn off in favor of eslint-plugin-simple-import-sort
    "import/no-unresolved": 0,
    "import/no-duplicates": 1,

    /**
     * eslint-plugin-simple-import-sort @see https://github.com/lydell/eslint-plugin-simple-import-sort
     */
    "sort-imports": 0, // we use eslint-plugin-import instead
    "simple-import-sort/imports": 1,
    "simple-import-sort/exports": 1,

    /**
     * @typescript-eslint/eslint-plugin @see https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin
     */
    "@typescript-eslint/no-namespace": "off",
    "@typescript-eslint/explicit-module-boundary-types": "off",
    "@typescript-eslint/no-explicit-any": "off",
    "@typescript-eslint/ban-types": "off",
    "@typescript-eslint/no-unused-vars": "off",
    "@typescript-eslint/no-empty-function": "off",
    "@typescript-eslint/ban-ts-comment": "off",
    "@typescript-eslint/no-non-null-assertion": "off",
    "@typescript-eslint/no-empty-interface": "off",
    /**
     * ESLint core rules @see https://eslint.org/docs/rules/
     */
    "no-case-declarations": "off",
    "no-empty": "off",
    "no-useless-escape": "off",
    "no-control-regex": "off",

    "ban/ban": [
      2,
      {
        name: ["Object", "keys"],
        message:
          "Object.keys() is not supported in legacy browsers, use objectKeys()",
      },
      {
        name: ["Object", "setPrototypeOf"],
        message: "Object.setPrototypeOf() is not supported in legacy browsers",
      },
      {
        name: ["Number", "isNaN"],
        message: "Number.isNaN() is not supported in legacy browsers",
      },
      {
        name: ["Number", "isInteger"],
        message: "Number.isInteger() is not supported in legacy browsers",
      },
    ],
  },
};
````

## File: .gitignore
````
**/.DS_Store
node_modules
/lib
coverage
.vscode
.idea
*.log
src/playground.ts
deno/lib/playground.ts
.eslintcache
````

## File: .prettierrc.yaml
````yaml
# .prettierrc or .prettierrc.yaml
trailingComma: "es5"
tabWidth: 2
semi: true
singleQuote: false
````

## File: CHANGELOG.md
````markdown
# Changelog

### 3.10

- New parser that allows parsing to continue after non-fatal errors have occured. This allows Zod to surface more errors to the user at once.

### 3.9

- Custom error messages in schemas

```ts
const name = z.string({
  invalid_type_error: "Name must be string",
  required_error: "Name is required",
});
```

Under the hood, this creates a custom error map that's bound to the schema. You can also pass a custom error map explicitly.

```ts
const name = z.string({ errorMap: myErrorMap });
```

- Rest parameters for tuples

```ts
const myTuple = z.tuple([z.string(), z.number()]).rest(z.boolean());
type t1 = z.output<typeof myTuple>; // [string, number, ...boolean[]]
```

- Selective `.partial`

You can specify certain fields to make optional with the `ZodObject.partial` method.

```ts
const user = z.object({
  name: z.string(),
  age: z.number(),
});

const optionalNameUser = user.partial({ name: true });
// { name?: string; age: number; }
```

- Specify key schema in ZodRecord

Previously, `z.record` only accepted a single schema:

```ts
z.record(z.boolean()); // Record<string, boolean>;
```

Now `z.record` has been overloaded to support two schemas. The first validates the _keys_ of the record, and the second validates the _values_.

```ts
const schema = z.record(z.number(), z.boolean());
type schema = z.infer<typeof schema>; // Record<number, boolean>

const schema = z.record(z.enum(["Tuna", "Trout"]), z.boolean());
type schema = z.infer<typeof schema>; // Record<"Tuna" | "Trout", boolean>
```

### 3.8

- Add `z.preprocess`
- Implement CUID validation on ZodString (`z.string().cuid()`)
- Improved `.deepPartial()`: now recursively operates on arrays, tuples, optionals, and nullables (in addition to objects)

### 3.7

- Eliminate `ZodNonEmptyArray`, add `Cardinality` to `ZodArray`
- Add optional error message to `ZodArray.nonempty`
- Add `.gt/.gte/.lt/.lte` to `ZodNumber`

### 3.6

- Add IE11 support
- `ZodError.flatten` now optionally accepts a map function for customizing the output
- `.void()` now only accepts undefined, not null.
- `z.enum` now supports `Readonly` string tuples

### 3.5

- Add discriminator to all first-party schema defs

### 3.4

- `unknown` and `any` schemas are always interpreted as optional. Reverts change from 3.3.

### 3.3

- HUGE speed improvements
- Added benchmarking: `yarn benchmark`
- Type signature of `ZodType#_parse` has changed. This will affects users who have implemented custom subclasses of `ZodType`.
- [reverted] Object fields of type `unknown` are no longer inferred as optional.

### 3.2

- Certain methods (`.or`, `.transform`) now return a new instance that wrap the current instance, instead of trying to avoid additional nesting. For example:

```ts
z.union([z.string(), z.number()]).or(z.boolean());
// previously
// => ZodUnion<[ZodString, ZodNumber, ZodBoolean]>

// now
// => ZodUnion<[ZodUnion<[ZodString, ZodNumber]>, ZodBoolean]>
```

This change was made due to recursion limitations in TypeScript 4.3 that made it impossible to properly type these methods.

### 3.0.0-beta.1

- Moved default value logic into ZodDefault. Implemented `.nullish()` method.

### 3.0.0-alpha.33

- Added `.returnType` and `.parameters` methods to ZodFunction

### 3.0.0-alpha.32

- Added `.required()` method to ZodObject

### 3.0.0-alpha.30

- Added Rollup for bundling ESM module

### zod@3.0.0-alpha.24

- Added back ZodIntersection
- Added .and() method to base class

### zod@3.0.0-alpha.9

- Added `z.strictCreate`

### zod@3.0.0-alpha.8

- Allowing optional default values on ZodOptional

### zod@3.0.0-alpha.5

March 17, 2021

- Refactored parsing logic into individual subclass methods
- Eliminated ZodTypes to enable custom ZodType subclasses
- Removed ZodIntersection
- Added ZodEffects as a container for refinement and transform logic
- Added `or` method to `ZodType`
- Added `format` method to `ZodError`
- Added `unwrap` method to `ZodOptional` and `ZodNullable`
- Added new `default` method and moved default functionality into ZodOptional
- Implemented `z.setErrorMap`
- Exporting `z` variable from `index.ts` to enable `import { z } from 'zod';`

### zod@3.0.0-alpha.4

Jan 25, 2021

- New implementation of transformers
- Removed type guards

### zod@2

- Added ZodTransformer
- Async refinements

### zod@1.11

- Introduced `.safeParse` option
- Introduced .regex method on string schemas
- Implemented `.primitives()` and `.nonprimitives()` on object schemas
- Implemented `z.nativeEnum()` for creating schemas from TypeScript `enum`s
- Switched to `new URL()` constructor to check valid URLs

### zod@1.10

- Dropping support for TypeScript 3.2

### zod@1.9

- Added z.instanceof() and z.custom()
- Implemented ZodSchema.array() method

### zod@1.8

- Introduced z.void()
- Major overhaul to error handling system, including the introduction of custom error maps
- Wrote new [error handling guide](./ERROR_HANDLING.md)

### zod@1.7

- Added several built-in validators to string, number, and array schemas
- Calls to `.refine` now return new instance

### zod@1.5

- Introduces ZodAny and ZodUnknown

### zod@1.4

- Refinement types (`.refine`)
- Parsing no longer returns deep clone

### zod@1.3

- Promise schemas

### zod@1.2.6

- `.parse` accepts `unknown`
- `bigint` schemas

### zod@1.2.5

- `.partial` and `.deepPartial` on object schemas

### zod@1.2.3

- Added ZodDate

### zod@1.2.0

- Added `.pick`, `.omit`, and `.extend` on object schemas

### zod@1.1.0

- Added ZodRecord

### zod@1.0.11

- Added `.nonstrict`

### zod@1.0.10

- Added type assertions with `.check`

### zod@1.0.4

- Support for empty tuples

### zod@1.0.2

- Added type assertions
- Added ZodLiteral
- Added ZodEnum
- Improved error reporting

### zod@1.0.0

- Initial release
````

## File: CODE_OF_CONDUCT.md
````markdown
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual
identity and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

- Demonstrating empathy and kindness toward other people
- Being respectful of differing opinions, viewpoints, and experiences
- Giving and gracefully accepting constructive feedback
- Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
- Focusing on what is best not just for us as individuals, but for the overall
  community

Examples of unacceptable behavior include:

- The use of sexualized language or imagery, and sexual attention or advances of
  any kind
- Trolling, insulting or derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or email address,
  without their explicit permission
- Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
colinmcd94@gmail.com or scott@scotttrinh.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series of
actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or permanent
ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within the
community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.1, available at
[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].

Community Impact Guidelines were inspired by
[Mozilla's code of conduct enforcement ladder][mozilla coc].

For answers to common questions about this code of conduct, see the FAQ at
[https://www.contributor-covenant.org/faq][faq]. Translations are available at
[https://www.contributor-covenant.org/translations][translations].

[homepage]: https://www.contributor-covenant.org
[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html
[mozilla coc]: https://github.com/mozilla/diversity
[faq]: https://www.contributor-covenant.org/faq
[translations]: https://www.contributor-covenant.org/translations
````

## File: CONTRIBUTING.md
````markdown
When it comes to open source, there are different ways you can contribute, all
of which are valuable. Here's few guidelines that should help you as you prepare
your contribution.

## Initial steps

Before you start working on a contribution, create an issue describing what you want to build. It's possible someone else is already working on something similar, or perhaps there is a reason that feature isn't implemented. The maintainers will point you in the right direction.

<!-- ## Submitting a Pull Request

- Fork the repo
- Clone your forked repository: `git clone git@github.com:{your_username}/zod.git`
- Enter the zod directory: `cd zod`
- Create a new branch off the `master` branch: `git checkout -b your-feature-name`
- Implement your contributions (see the Development section for more information)
- Push your branch to the repo: `git push origin your-feature-name`
- Go to https://github.com/colinhacks/zod/compare and select the branch you just pushed in the "compare:" dropdown
- Submit the PR. The maintainers will follow up ASAP. -->

## Development

The following steps will get you setup to contribute changes to this repo:

1. Fork this repo.

2. Clone your forked repo: `git clone git@github.com:{your_username}/zod.git`

3. Run `yarn` to install dependencies.

4. Start playing with the code! You can do some simple experimentation in `src/playground.ts` (see `yarn play` below) or start implementing a feature right away.

### Commands

**`yarn build`**

- deletes `lib` and re-compiles `src` to `lib`

**`yarn test`**

- runs all Jest tests and generates coverage badge

**`yarn test:one`**

- runs a single test file
- example: `yarn test src/__tests__/testFileNameHere.ts`

**`yarn play`**

- executes `src/playground.ts`, watches for changes. useful for experimentation

### Tests

Zod uses Jest for testing. After implementing your contribution, write tests for it. Just create a new file under `src/__tests__` or add additional tests to the appropriate existing file.

Before submitting your PR, run `yarn test` to make sure there are no (unintended) breaking changes.

### Documentation

The Zod documentation lives in the README.md. Be sure to document any API changes you implement.

## License

By contributing your code to the zod GitHub repository, you agree to
license your contribution under the MIT license.
````

## File: ERROR_HANDLING.md
````markdown
# Error Handling in Zod

This guide explains Zod's internal error handling system, and the various ways you can customize it for your purposes.

## ZodError

All validation errors thrown by Zod are instances of `ZodError`.

```ts
class ZodError extends Error {
  issues: ZodIssue[];
}
```

ZodError is a subclass of `Error`; you can create your own instance easily:

```ts
import * as z from "zod";

const myError = new z.ZodError([]);
```

Each ZodError has an `issues` property that is an array of `ZodIssues`. Each issue documents a problem that occurred during validation.

## ZodIssue

`ZodIssue` is _not_ a class. It is a [discriminated union](https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions).

The link above is the best way to learn about the concept. Discriminated unions are an ideal way to represent a data structures that may be one of many possible variants. You can see all the possible variants defined [here](./src/ZodError.ts). They are also described in the table below if you prefer.

_Every_ ZodIssue has these fields:

| field     | type                   | details                                                                                           |
| --------- | ---------------------- | ------------------------------------------------------------------------------------------------- |
| `code`    | `z.ZodIssueCode`       | You can access this enum with `z.ZodIssueCode`. A full breakdown of the possible values is below. |
| `path`    | `(string \| number)[]` | e.g, `['addresses', 0, 'line1']`                                                                  |
| `message` | `string`               | e.g. `Invalid type. Expected string, received number.`                                            |

**However** depending on the error code, there may be additional properties as well. Here is a full breakdown of the additional fields by error code:

## ZodIssueCode

| code                             | additional fields                                                                                                                                                                                                                                                                                                                                                    |
| -------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ZodIssueCode.invalid_type        | `expected: ZodParsedType` <br> `received: ZodParsedType` <br><br>Jump to [this section](#parsedtype) for a breakdown of the possible values of ZodParsedType.                                                                                                                                                                                                        |
| ZodIssueCode.unrecognized_keys   | `keys: string[]`<br>The list of unrecognized keys<br>                                                                                                                                                                                                                                                                                                                |
| ZodIssueCode.invalid_union       | `unionErrors: ZodError[]` <br> The errors thrown by each element of the union.                                                                                                                                                                                                                                                                                       |
| ZodIssueCode.invalid_enum_value  | `options: string[]` <br> The set of acceptable string values for this enum.                                                                                                                                                                                                                                                                                          |
| ZodIssueCode.invalid_arguments   | `argumentsError: ZodError` <br> This is a special error code only thrown by a wrapped function returned by `ZodFunction.implement()`. The `argumentsError` property is another ZodError containing the validation error details.                                                                                                                                     |
| ZodIssueCode.invalid_return_type | `returnTypeError: ZodError` <br> This is a special error code only thrown by a wrapped function returned by `ZodFunction.implement()`. The `returnTypeError` property is another ZodError containing the validation error details.                                                                                                                                   |
| ZodIssueCode.invalid_date        | _no additional properties_                                                                                                                                                                                                                                                                                                                                           |
| ZodIssueCode.invalid_string      | `validation: "url" \| "email" \| "uuid"`<br> Which built-in string validator failed                                                                                                                                                                                                                                                                                  |
| ZodIssueCode.too_small           | `type: "string" \| "number" \| "array"` <br>The type of the data failing validation<br><br> `minimum: number` <br>The expected length/value.<br><br>`inclusive: boolean`<br>Whether the minimum is included in the range of acceptable values.<br>                                                                                                                   |
| ZodIssueCode.too_big             | `type: "string" \| "number" \| "array"` <br>The type of the data failing validation<br><br> `maximum: number` <br>The expected length/value.<br><br>`inclusive: boolean`<br>Whether the maximum is included in the range of acceptable values.<br>                                                                                                                   |
| ZodIssueCode.not_multiple_of     | `multipleOf: number` <br>The value the number should be a multiple of.<br>                                                                                                                                                                                                                                                                                           |
| ZodIssueCode.custom              | `params: { [k: string]: any }` <br> This is the error code throw by refinements (unless you are using `superRefine` in which case it's possible to throw issues of any `code`). You are able to pass in a `params` object here that is available in your custom error maps (see [ZodErrorMap](#Customizing-errors-with-ZodErrorMap) below for details on error maps) |

<!--
| ZodIssueCode.nonempty_array_is_empty | _no additional properties_                                      |
| ZodIssueCode.invalid_literal_value   | `expected: string \| number \| boolean` <br> The literal value. |
-->

## ZodParsedType

This is an enum used by Zod internally to represent the type of a parsed value. The possible values are:

- `string`
- `nan`
- `number`
- `integer`
- `float`
- `boolean`
- `date`
- `bigint`
- `symbol`
- `function`
- `undefined`
- `null`
- `array`
- `object`
- `unknown`
- `promise`
- `void`
- `never`
- `map`
- `set`

## A demonstrative example

Here's a sample Person schema.

```ts
const person = z.object({
  names: z.array(z.string()).nonempty(), // at least 1 name
  address: z.object({
    line1: z.string(),
    zipCode: z.number().min(10000), // American 5-digit code
  }),
});
```

Let's pass in some improperly formatted data.

```ts
try {
  person.parse({
    names: ["Dave", 12], // 12 is not a string
    address: {
      line1: "123 Maple Ave",
      zipCode: 123, // zip code isn't 5 digits
      extra: "other stuff", // unrecognized key
    },
  });
} catch (err) {
  if (err instanceof z.ZodError) {
    console.log(err.issues);
  }
}
```

Here are the errors that will be printed:

```ts
[
  {
    code: "invalid_type",
    expected: "string",
    received: "number",
    path: ["names", 1],
    message: "Invalid input: expected string, received number",
  },
  {
    code: "unrecognized_keys",
    keys: ["extra"],
    path: ["address"],
    message: "Unrecognized key(s) in object: 'extra'",
  },
  {
    code: "too_small",
    minimum: 10000,
    type: "number",
    inclusive: true,
    path: ["address", "zipCode"],
    message: "Value should be greater than or equal to 10000",
  },
];
```

As you can see three different issues were identified. Every ZodIssue has a `code` property and additional metadata about the validation failure. For instance the `unrecognized_keys` error provides a list of the unrecognized keys detected in the input.

## Customizing errors with ZodErrorMap

You can customize **all** error messages produced by Zod by providing a custom "error map" to Zod, like so:

```ts
import { z } from "zod";

const customErrorMap: z.ZodErrorMap = (issue, ctx) => {
  if (issue.code === z.ZodIssueCode.invalid_type) {
    if (issue.expected === "string") {
      return { message: "bad type!" };
    }
  }
  if (issue.code === z.ZodIssueCode.custom) {
    return { message: `less-than-${(issue.params || {}).minimum}` };
  }
  return { message: ctx.defaultError };
};

z.setErrorMap(customErrorMap);
```

`ZodErrorMap` is a special function. It accepts two arguments: `issue` and `ctx`. The return type is `{ message: string }`. Essentially the error map accepts some information about the validation that is failing and returns an appropriate error message.

- `issue: Omit<ZodIssue, "message">`

  As mentioned above, ZodIssue is a discriminated union.

- `ctx: { defaultError: string; data: any }`

  - `ctx.default` is the error message generated by the default error map. If you only want to override the message for a single type of error, you can do that. Just return `defaultError` for everything

  - `ctx.data` contains the data that was passed into `.parse`. You can use this to customize the error message.

As in the example, you can modify certain error messages and simply fall back to `ctx.defaultError` otherwise.

## Error map priority

A custom error maps doesn't need to produce an error message for every kind of issue in Zod. Instead, your error map can override certain errors and return `ctx.defaultError` for everything else.

But how is the value of `ctx.defaultError` determined?

Error messages in Zod are generated by passing metadata about a validation issue through a chain of error maps. Error maps with higher priority override messages generated by maps with lower priority.

The lowest priority map is the `defaultErrorMap`, which defined in [`src/ZodError.ts`](https://github.com/colinhacks/zod/blob/master/src/ZodError.ts). This produces the default error message for all issues in Zod.

### Global error map

This message is then passed as `ctx.defaultError` into `overrideErrorMap`. This is a global error map you can set with `z.setErrorMap`:

```ts
const myErrorMap: z.ZodErrorMap = /* ... */;
z.setErrorMap(errorMap);
```

### Schema-bound error map

The `overrideErrorMap` message is then passed as `ctx.defaultError` into any schema-bound error maps. Every schema can be associated with an error map.

```ts
z.string({ errorMap: myErrorMap });

// this creates an error map under the hood
z.string({
  invalid_type_error: "Invalid name",
  required_error: "Name is required",
});
```

### Contextual error map

Finally, you can pass an error map as a parameter to any `parse` method. This error map, if provided, has highest priority.

```ts
z.string().parse("adsf", { errorMap: myErrorMap });
```

## A working example

Let's look at a practical example of of customized error map:

```ts
import * as z from "zod";

const errorMap: z.ZodErrorMap = (error, ctx) => {
  /*
  This is where you override the various error codes
  */
  switch (error.code) {
    case z.ZodIssueCode.invalid_type:
      if (error.expected === "string") {
        return { message: `This ain't a string!` };
      }
      break;
    case z.ZodIssueCode.custom:
      // produce a custom message using error.params
      // error.params won't be set unless you passed
      // a `params` arguments into a custom validator
      const params = error.params || {};
      if (params.myField) {
        return { message: `Bad input: ${params.myField}` };
      }
      break;
  }

  // fall back to default message!
  return { message: ctx.defaultError };
};

z.string().parse(12, { errorMap });

/* throws: 
  ZodError {
    errors: [{
      code: "invalid_type",
      path: [],
      message: "This ain't a string!",
      expected: "string",
      received: "number",
    }]
  }
*/
```

## Error handling for forms

If you're using Zod to validate the inputs from a web form, there is a convenient way to "flatten" a ZodError to a format that can be easily displayed to the end user.

Consider this example of a simple signup form:

```ts
const FormData = z
  .object({
    email: z.string().email(),
    password: z.string().min(10),
    confirm: z.string().min(10),
  })
  .refine(obj => obj.password === obj.confirm, {
    message: 'Passwords do not match',
    path: ['confirm'], // this value is concatenated to the end of the actual path of the error
  });
}
```

Now lets pass in some invalid data:

```ts
FormData.parse({
  email: "not an email",
  password: "tooshort",
  confirm: "nomatch",
});
```

This will throw a ZodError with four issues:

```ts
console.log(err.issues);
/*
  [
    { code: 'invalid_string', validation: 'email', path: ['email'], message: 'Invalid email' },
    {
      code: 'too_small',
      minimum: 10,
      type: 'string',
      inclusive: true,
      path: ['password'],
      message: 'Should be at least 10 characters',
    },
    {
      code: 'too_small',
      minimum: 10,
      type: 'string',
      inclusive: true,
      path: ['confirm'],
      message: 'Should be at least 10 characters',
    },
    { code: 'custom', message: 'Passwords do not match', path: ['confirm'] },
  ]; 
  */
```

But using the `flatten()` method, we can make those errors much easier to work with:

```ts
console.log(err.flatten());
/*
  {
  formErrors: [],
  fieldErrors: {
    email: ['Invalid email'],
    password: ['Should be at least 10 characters'],
    confirm: ['Should be at least 10 characters', 'Passwords do not match'],
  },
}
*/
```

Additionally, you can pass a mapping function of `(issue: ZodIssue) => U` to `flatten()`, which is applied to the during the transformation of `ZodIssue`s.
This can be particularly useful when integrating Zod with form validation, as it allows you to pass back whatever `ZodIssue` specific context you might need.

```ts
err.flatten( (i: ZodIssue) => {
  message: i.message,
  errorCode: i.code
});
/*
  {
  formErrors: [],
  fieldErrors: {
    email: [{ message: 'Invalid email', errorCode: 'invalid_string' }],
    password: [{ message: 'Should be at least 10 characters', errorCode: 'too_small' }],
    confirm: [{ message: 'Should be at least 10 characters', errorCode: 'too_small' }, { message: 'Passwords do not match', errorCode: 'custom' }],
  },
}
*/
```

- `fieldErrors` is an object. The keys are the field(s) that threw the error. The values are an array of error strings that can be easily presented in the interface.
- `formErrors: string[]` is an array of errors that occurred on the "root" of the object schema. For instance if you called `FormData.parse(null)`, `formErrors` would be:
  ```ts
  ["Invalid input: expected object, received null"];
  ```

## Type-safety with `safeParse`.

If you're using `safeParse`, and need more type-safety around error results, you can use `z.inferFlattenedErrors` to infer the result of error result called with `flatten()`, based on your schema.

```ts
type FormDataErrors = z.inferFlattenedErrors<typeof FormData>;

/*
  formErrors: string[],
  fieldErrors: {
    email?: string[],
    password?: string[],
    confirm?: string[]
  } 
*/
```

By default all error types are assumed to be `string`. If you're using a mapping function to transform `ZodIssue`s, you can provide the error type to `z.inferFlattenedErrors`.

```ts
type FormDataErrors = z.inferFlattenedErrors<
  typeof FormData,
  { message: string; errorCode: string }
>;

/*
  formErrors: { message: string, errorCode: string }[],
  fieldErrors: {
    email?: { message: string, errorCode: string }[],
    password?: { message: string, errorCode: string }[],
    confirm?: { message: string, errorCode: string }[]
  } 
*/

const result = FormData.safeParse({
  email: "not email",
  password: "tooshort",
  confirm: "nomatch",
});

if (!result.success) {
  let bad: FormDataErrors = err.flatten(); // Type error: Type 'string' is not assignable to type '{ message: string; }'.
  let good: FormDataErrors = err.flatten((i) => ({
    message: i.message,
    errorCode: i.code,
  }));
}
```

Additionally, you can use `z.inferFormErrors` as a convienience for `z.inferFlattenedErrors<T, string>` in combination with `formErrors`.

```ts
type FormDataErrors = z.inferFormErrors<
  typeof FormData,
  { message: string; errorCode: string }
>;

let formErrors: FormDataErrors = result.error.formErrors;
```
````

## File: FUNDING.yml
````yaml
github: colinhacks
````

## File: jest.config.json
````json
{
  "rootDir": ".",
  "transform": {
    "^.+\\.tsx?$": "ts-jest"
  },
  "testRegex": "src/.*\\.test\\.ts$",
  "moduleFileExtensions": [
    "ts",
    "tsx",
    "js",
    "jsx",
    "json",
    "node"
  ],
  "coverageReporters": [
    "json-summary",
    "text",
    "lcov"
  ],
  "globals": {
    "ts-jest": {
      "tsconfig": "tsconfig.json"
    }
  }
}
````

## File: LICENSE
````
MIT License

Copyright (c) 2020 Colin McDonnell

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
````

## File: logo.svg
````
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 1080 1080" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-miterlimit:5;">
    <use xlink:href="#_Image1" x="112.458" y="229.1" width="867.625px" height="669.651px" transform="matrix(0.999568,0,0,0.999479,0,0)"/>
    <g transform="matrix(0.116243,0,0,0.473619,-23.7923,-3587.35)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.0900481,0,0,0.473619,101.204,-3534.08)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.0481846,0,0,0.133311,454.599,-550.685)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.17212,-0.0993737,0.446387,0.773164,-4264.21,-6040.13)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.110306,-0.0636855,0.0916929,0.158817,-1037.66,-798.056)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.110306,-0.0636855,0.0916929,0.158817,-1050.22,-812.682)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.110306,-0.0636855,0.0916929,0.158817,-1062.67,-824.113)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.116652,-0.067349,0.0722158,0.125081,-870.022,-471.251)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.12113,-0.0699344,0.0722158,0.125081,-874.027,-449.65)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.129529,-0.0747837,0.0916929,0.158817,-1067.52,-724.985)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <g transform="matrix(0.0389201,-0.0224705,0.296775,0.514029,-2065.36,-4228.86)">
        <rect x="3083.23" y="8972.31" width="3500.78" height="135.721" style="fill:rgb(39,77,130);"/>
    </g>
    <use xlink:href="#_Image2" x="30" y="160" width="1045px" height="842px"/>
    <g transform="matrix(1.01688,0,-5.64483e-17,1.01688,-1013.22,-4627.54)">
        <path d="M1825.05,4726.89L1250.49,4726.89L1040.57,4935.73L1517.16,5509.64L1555.18,5466.98L2026.94,4937.69L1825.05,4726.89ZM1804.06,4776.06L1960,4938.89L1518.48,5434.26L1107.11,4938.89L1270.78,4776.06L1804.06,4776.06Z" style="fill:rgb(48,104,183);"/>
    </g>
    <defs>
        <image id="_Image1" width="868px" height="670px" xlink:href="data:image/png;base64,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"/>
        <image id="_Image2" width="1045px" height="842px" xlink:href="data:image/png;base64,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"/>
    </defs>
</svg>
````

## File: MIGRATION.md
````markdown
# Migration guide

This is a migration guide to walk you through the process of upgrading to Zod 3.

- If you're upgrading directly from Zod 1, you should read through the list of features + changes in both Zod 2 and Zod 3.
- If you're upgrading from Zod 2 -> 3, you can skip to the

## Upgrading from Zod 1 → Zod 2

Zod 2 is being retired and will not leave beta. This is due to some unintuitive ramifications of the transformers API: details [here](https://github.com/colinhacks/zod/issues/264).

### New features

- Transformers! These let you provide default values, do casting/coercion, and a lot more. Read more here: [Transformers](https://github.com/colinhacks/zod#transformers)
- Asynchronous refinements and new .parseAsync and .safeParseAsync methods. Read more here: [Refinements](https://github.com/colinhacks/zod#refinements)
- Modify unknown key behavior for object schemas: `.strip()` (the default), `.passthrough()`, and `.strict()`
- New .catchall() method for object schemas: [catchall](https://github.com/colinhacks/zod#catchall)

### Breaking changes

- Object schemas now _strip_ unknown keys by default.
- Schema parsing now returns a deep clone of the data you pass in (instead of the exact value you pass in)
- Relatedly, Zod no longer supports cyclical data. Recursive schemas are still supported, but Zod can't properly parse nested objects that contain cycles.
- Optional and nullable schemas are now represented with the dedicated ZodOptional and ZodNullable classes, instead of using ZodUnion.

## Upgrading from Zod 2 → Zod 3

### New features

- You can now import Zod like `import { z } from 'zod';` instead of using `import * as` syntax.
- **Structured error messages**. Use the `.format()` method to ZodError to convert the error into a strongly-typed, nested object: [format method](#error-formatting)
- **Easier unions**. Use the `or` method to ZodType (the base class for all Zod schemas) to easily create union types like `z.string().or(z.number())`
- **Easier intersections**. Use the `and` method to ZodType (the base class for all Zod schemas) to easily create intersection types
- **Global error customization**. Use `z.setErrorMap(myErrorMap)` to _globally_ customize the error messages produced by Zod: [setErrorMap](ERROR_HANDLING.md#customizing-errors-with-zoderrormap)
- **Maps and sets**. Zod now supports [`Map`](#maps) and [`Set`](#set) schemas.
- **Optional and nullable unwrapping**. ZodOptional and ZodNullable now have a `.unwrap()` method for retrieving the schema they wrap.
- **A new implementation of transformers**. Details below.

### Breaking changes

- The **minimum TypeScript version** is now _4.1_ (up from 3.7 for Zod 2). Several features have been rewritten to use [recursive conditional types](https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#recursive-conditional-types), an incredibly powerful new feature introduced in TS4.1.

- **Transformers syntax**. Previously, creating a transformer required an input schema, an output schema, and a function to transform between them. You created transformers like `z.transform(A, B, func)`, where `A` and `B` are Zod schemas. This is no longer the case. Accordingly:

  The old syntax is no longer available:

  ```ts
  # not available
  z.transformer(A, B, func);
  A.transform(B, func)
  ```

  Instead, apply transformations by simply using the `.transform()` method that exists on all Zod schemas.

  ```ts
  z.string().transform((val) => val.length);
  ```

- Under the hood, all refinements and transformations are executed inside a dedicated "ZodEffects" class. Post-parsing, ZodEffects passes the data through a chain of refinements and transformations, then returns the final value. As such, you can now _interleave_ transformations and refinements. For instance:

  ```ts
  const test = z
    .string()
    .transform((val) => val.length)
    .refine((val) => val > 5, { message: "Input is too short" })
    .transform((val) => val * 2);

  test.parse("12characters"); // => 24
  ```

- **Type guards** (the `.check()` method) have been removed. Type guards interact with transformers in unintuitive ways so they were removed. Use `.safeParse` instead.

- Object merging now behaves differently. If you merge two object schema (`A.merge(B)`), the fields of B will overwrite the fields of A if there are shared keys. This is how the `.extend` method already works. If you're looking to create an intersection of the two types, use `z.intersection(A, B)` or use the new `.and` method (`A.and(B)`).

- **Default values**: default value logic is now implemented inside a `ZodDefault` class, instead of using transformers. (In a previous alpha version of Zod 3, default values were implemented inside the ZodOptional class.)

- There have been small internal changes to the ZodIssue subtypes. See the new subtypes in the [Error Handling guide](ERROR_HANDLING.md). This may impact user who have written a custom error maps. Most users will not be affected.
````

## File: package.json
````json
{
  "name": "zod",
  "version": "3.14.3",
  "description": "TypeScript-first schema declaration and validation library with static type inference",
  "main": "./lib/index.js",
  "types": "./lib/index.d.ts",
  "module": "./lib/index.mjs",
  "dependencies": {},
  "exports": {
    ".": {
      "require": "./lib/index.js",
      "import": "./lib/index.mjs",
      "types": "./lib/index.d.ts"
    },
    "./package.json": "./package.json"
  },
  "files": [
    "/lib"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/colinhacks/zod"
  },
  "author": "Colin McDonnell <colin@colinhacks.com>",
  "license": "MIT",
  "sideEffects": false,
  "bugs": {
    "url": "https://github.com/colinhacks/zod/issues"
  },
  "homepage": "https://github.com/colinhacks/zod",
  "funding": "https://github.com/sponsors/colinhacks",
  "support": {
    "backing": {
      "npm-funding": true
    }
  },
  "keywords": [
    "typescript",
    "schema",
    "validation",
    "type",
    "inference"
  ],
  "scripts": {
    "prettier:check": "prettier --check src/**/*.ts deno/lib/**/*.ts --no-error-on-unmatched-pattern",
    "prettier:fix": "prettier --write src/**/*.ts deno/lib/**/*.ts --ignore-unknown --no-error-on-unmatched-pattern",
    "lint:check": "eslint --ext .ts ./src",
    "lint:fix": "eslint --fix --ext .ts ./src",
    "check": "yarn lint:check && yarn prettier:check",
    "fix": "yarn lint:fix && yarn prettier:fix",
    "clean": "rm -rf lib/* deno/lib/*",
    "build": "yarn run clean && npm run build:cjs && npm run build:esm && npm run build:deno",
    "build:deno": "node ./deno/build.mjs",
    "build:esm": "rollup --config rollup.config.js",
    "build:cjs": "tsc --p tsconfig.cjs.json",
    "build:types": "tsc --p tsconfig.types.json",
    "rollup": "rollup --config rollup.config.js",
    "test": "jest --coverage",
    "test:deno": "cd deno && deno test",
    "prepublishOnly": "npm run test && npm run build && npm run build:deno",
    "play": "nodemon -e ts -w . -x ts-node src/playground.ts --project tsconfig.json --trace-warnings",
    "depcruise": "depcruise -c .dependency-cruiser.js src",
    "benchmark": "ts-node src/benchmarks/index.ts",
    "prepare": "husky install"
  },
  "devDependencies": {
    "@rollup/plugin-typescript": "^8.2.0",
    "@types/benchmark": "^2.1.0",
    "@types/jest": "^26.0.17",
    "@types/node": "14",
    "@typescript-eslint/eslint-plugin": "^5.15.0",
    "@typescript-eslint/parser": "^5.15.0",
    "benchmark": "^2.1.4",
    "dependency-cruiser": "^9.19.0",
    "eslint": "^8.11.0",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-ban": "^1.6.0",
    "eslint-plugin-import": "^2.25.4",
    "eslint-plugin-simple-import-sort": "^7.0.0",
    "eslint-plugin-unused-imports": "^2.0.0",
    "husky": "^7.0.4",
    "jest": "^27.5.1",
    "lint-staged": "^12.3.7",
    "nodemon": "^2.0.15",
    "prettier": "^2.6.0",
    "pretty-quick": "^3.1.3",
    "rollup": "^2.70.1",
    "ts-jest": "^27.1.3",
    "ts-node": "^10.7.0",
    "tslib": "^2.3.1",
    "typescript": "^4.6.2"
  },
  "lint-staged": {
    "src/*.ts": [
      "eslint --cache --fix",
      "prettier --ignore-unknown --write"
    ]
  }
}
````

## File: README_ZH.md
````markdown
<p align="center">
  <img src="logo.svg" width="200px" align="center" />
  <h1 align="center">Zod</h1>
</p>
<p align="center">
<a href="https://twitter.com/colinhacks" rel="nofollow"><img src="https://img.shields.io/badge/created%20by-@colinhacks-4BBAAB.svg" alt="Created by Colin McDonnell"></a>
<a href="https://opensource.org/licenses/MIT" rel="nofollow"><img src="https://img.shields.io/github/license/colinhacks/zod" alt="License"></a>
<a href="https://www.npmjs.com/package/zod" rel="nofollow"><img src="https://img.shields.io/npm/dw/zod.svg" alt="npm"></a>
<a href="https://www.npmjs.com/package/zod" rel="nofollow"><img src="https://img.shields.io/github/stars/colinhacks/zod" alt="stars"></a>
<a href="./src/__tests__" rel="nofollow"><img src="./coverage.svg" alt="coverage"></a>

</p>
<p align="center">
⭐️ smash that star button ⭐️
</p>

> 如果你喜欢 Zod，你会喜欢我的新库 [tRPC](https://trpc.io). 这是一种建立端到端类型安全 API 的方法，无需 GraphQL 或代码生成 请在[trpc.io](https://trpc.io)上查看他.

<br/>

## 二零二一年五月十七日: Zod v3 已经进入稳定版!

查看 [迁移指南](https://github.com/colinhacks/zod/blob/master/MIGRATION.md) 进行升级.

以前的版本:

- [`Zod 1 docs`](https://github.com/colinhacks/zod/tree/v1)
- [`Zod 2 docs`](https://github.com/colinhacks/zod/tree/v2)

#### 新功能

- **更容易的引入**: 你现在可以像`import { z } from 'zod';`那样导入 Zod，而不是使用`import * as`语法。
- **结构化的错误消息**. 对 ZodError 使用`.format()`方法，将错误转换为强类型的嵌套对象: [format method](#error-formatting)
- **更容易的联合类型**. 使用 ZodType（所有 Zod 模式的基类）的`or`方法，可以轻松创建联合类型，如 `z.string().or(z.number())`
- **更容易的交叉类型**. 对 ZodType（所有 Zod 模式的基类）使用`and`方法，可以轻松创建交叉类型
- **全局错误定制**. 使用`z.setErrorMap(myErrorMap)`来全面定制 Zod 产生的错误信息: [setErrorMap](ERROR_HANDLING.md#customizing-errors-with-zoderrormap)
- **Maps and sets**. Zod 现在支持 [`Map`](#maps) 和 [`Set`](#sets) 模式。
- **可选的和可忽略的解包**. ZodOptional 和 ZodNullable 现在有一个`.unwrap()`方法来检索它们所包裹的模式。
- **A new implementation of transformers**. 请参阅[迁移指南](https://github.com/colinhacks/zod/blob/master/MIGRATION.md)部分以了解语法的变化。

# 內容

- [什么是 Zod](#什么是Zod)
- [安装](#安装)
- [生态体系](#生态系统)
- [基本用法](#基本用法)
- [定义模式](#定义模式)
  - [基本原理](#基本原理)
  - [字面意义](#字面意义)
  - [Strings](#strings)
  - [Numbers](#numbers)
  - [Objects](#objects)
    - [.shape](#shape)
    - [.extend](#extend)
    - [.merge](#merge)
    - [.pick/.omit](#pickomit)
    - [.partial](#partial)
    - [.deepPartial](#deepPartial)
    - [.passthrough](#passthrough)
    - [.strict](#strict)
    - [.strip](#strip)
    - [.catchall](#catchall)
  - [Records](#records)
  - [Maps](#maps)
  - [Sets](#sets)
  - [Arrays](#arrays)
    - [.nonempty](#nonempty)
    - [.min/.max/.length](#minmaxlength)
  - [Unions](#unions)
  - [Optionals](#optionals)
  - [Nullables](#nullables)
  - [Enums](#enums)
    - [Zod enums](#zod-enums)
    - [Native enums](#native-enums)
  - [Tuples](#tuples)
  - [Recursive types](#recursive-types)
    - [JSON type](#json-type)
    - [Cyclical data](#cyclical-objects)
  - [Promises](#promises)
  - [Instanceof](#instanceof)
  - [Function schemas](#function-schemas)
- [基础类方法 (ZodType)](#zodtype-methods-and-properties)
  - [.parse](#parse)
  - [.parseAsync](#parseasync)
  - [.safeParse](#safeparse)
  - [.safeParseAsync](#safeparseasync)
  - [.refine](#refine)
  - [.superRefine](#superRefine)
  - [.transform](#transform)
  - [.default](#default)
  - [.optional](#optional)
  - [.nullable](#nullable)
  - [.nullish](#nullish)
  - [.array](#array)
  - [.or](#or)
  - [.and](#and)
- [类型推断](#type-inference)
- [Errors](#errors)
- [比较](#comparison)
  - [Joi](#joi)
  - [Yup](#yup)
  - [io-ts](#io-ts)
  - [Runtypes](#runtypes)
- [Changelog](#changelog)

<!-- **Zod 2 is coming! Follow [@colinhacks](https://twitter.com/colinhacks) to stay updated and discuss the future of Zod.** -->

# 什么是 Zod

Zod 是一个以 TypeScript 为首的模式声明和验证库。我使用术语 "模式 "来广义地指任何数据类型，从简单的 `字符串` 到复杂的嵌套对象。

Zod 被设计成对开发者尽可能友好。其目的是消除重复的类型声明。使用 Zod，你只需声明 _一次_ 验证器，Zod 就会自动推断出静态 TypeScript 类型。它很容易将较简单的类型组成复杂的数据结构。

其他一些重要方面:

- 零依赖
- 可以工作在浏览器和 Node.js
- 小巧: 8kb minified + zipped
- 不可变: 方法(即 `.optional()` 返回一个新的实例
- 简洁的、可连锁的接口
- 功能性方法: [解析，不验证](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)
- 也可用于普通的 JavaScript! 你不需要使用 TypeScript。

# 赞助

我们感谢并鼓励任何级别的赞助。Zod 是由一个单独的开发者维护的 ([hi!](https://twitter.com/colinhacks)). 对于个人开发者来说，可以考虑[一杯咖啡级别](https://github.com/sponsors/colinhacks). 如果你使用 Zod 建立了一个付费产品，可以考虑[初创企业级别](https://github.com/sponsors/colinhacks). 你可以在以下网站上了解更多关于等级的信息 [github.com/sponsors/colinhacks](https://github.com/sponsors/colinhacks).

### 贊助者

<table>
  <tr>
   <td align="center">
      <a href="https://deletype.com/">
        <img src="https://avatars0.githubusercontent.com/u/15068039?s=200&v=4" width="100px;" alt="" />
      </a>
      <br>
      <b>Deletype</b>
      <br>
      <a href="https://deletype.com/">https://deletype.com/</a>
    </td>
  <td align="center">
      <a href="https://github.com/kevinsimper">
        <img src="https://avatars1.githubusercontent.com/u/1126497?s=460&v=4" width="100px;" alt="" />
      </a>
      <br>
      <b>Kevin Simper</b>
      <br>
      <a href="https://github.com/kevinsimper">@kevinsimper</a>
    </td>
    <td align="center">
      <a href="https://twitter.com/flybayer">
        <img src="https://avatars2.githubusercontent.com/u/8813276?s=460&u=4ff8beb9a67b173015c4b426a92d89cab960af1b&v=4" width="100px;" alt=""/>
      </a>
      <br>
      <b>Brandon Bayer</b>
      <br/>
      <a href="https://twitter.com/flybayer">@flybayer</a>,
      <span>creator of <a href="https://blitzjs.com">Blitz.js</a></span>
      <br />
    </td>
    
  </tr>
  <tr>
    <td align="center">
      <a href="https://www.bamboocreative.nz/">
        <img src="https://avatars1.githubusercontent.com/u/41406870?s=460&v=4" width="100px;" alt="" />
      </a>
      <br>
      <b>Bamboo Creative</b>
      <br>
      <a href="https://www.bamboocreative.nz/">https://bamboocreative.nz</a>
    </td>
    <td align="center">
      <a href="https://github.com/jeremyBanks">
        <img src="https://avatars.githubusercontent.com/u/18020?s=400&u=dba6c1402ae1746a276a5d256e01d68e774a0e9d&v=4" width="100px;" alt="" />
      </a>
      <br>
      <b>Jeremy Banks</b>
      <br>
      <a href="https://github.com/jeremyBanks">github.com/jeremyBanks</a>
    </td>
     <td align="center">
      <a href="https://marcatopartners.com/">
        <img src="https://avatars.githubusercontent.com/u/84106192?s=200&v=4" width="100px;" alt="Marcato Partners" />
      </a>
      <br>
      <b>Marcato Partners</b>
      <br>
      <a href="https://marcatopartners.com/">marcatopartners.com</a>
    </td>
  </tr>
</table>

_要在这里看到你的名字 + Twitter + 網站 , 请在[Freelancer](https://github.com/sponsors/colinhacks) 或 [Consultancy](https://github.com/sponsors/colinhacks)赞助 Zod ._

# 安装

安装 Zod v3:

```sh
npm install zod
```

⚠️ 重要提示：你必须在你的`tsconfig.json`中启用`strict`模式。这是所有 TypeScript 项目的最佳实践。

```ts
// tsconfig.json
{
  // ...
  "compilerOptions": {
    // ...
    "strict": true
  }
}
```

#### TypeScript 的要求

- Zod 3.x requires TypeScript 4.1+
- Zod 2.x requires TypeScript 3.7+
- Zod 1.x requires TypeScript 3.3+

# 生态系统

有越来越多的工具是建立在 Zod 之上或原生支持 Zod 的! 如果你在 Zod 的基础上建立了一个工具或库，请在[Twitter](https://twitter.com/colinhacks) 或者 [Discussion](https://github.com/colinhacks/zod/discussions)上告诉我。我会在下面添加，并在推特上发布。

- [`tRPC`](https://github.com/trpc/trpc): 在没有 GraphQL 的情况下建立端到端的类型安全 API
- [`react-hook-form`](https://github.com/react-hook-form/resolvers): 使用 React Hook Form 和 Zod 解析器轻松构建类型安全的表单。
- [`ts-to-zod`](https://github.com/fabien0102/ts-to-zod): 将 TypeScript 定义转换成 Zod 模式。
- [`zod-mocking`](https://github.com/dipasqualew/zod-mocking): 从你的 Zod 模式中生成模拟数据。
- [`zod-fast-check`](https://github.com/DavidTimms/zod-fast-check): 从 Zod 模式中生成 `fast-check` 的任意数据。
- [`zod-endpoints`](https://github.com/flock-community/zod-endpoints): 约定优先的严格类型的端点与 Zod。兼容 OpenAPI。
- [`express-zod-api`](https://github.com/RobinTail/express-zod-api): 用 I/O 模式验证和自定义中间件构建基于 Express 的 API 服务

# 基本用法

创建一个简单的字符串模式

```ts
import { z } from "zod";

// 创建一个字符串的模式
const mySchema = z.string();
mySchema.parse("tuna"); // => "tuna"
mySchema.parse(12); // => throws ZodError
```

创建一个 Object 模式

```ts
import { z } from "zod";

const User = z.object({
  username: z.string(),
});

User.parse({ username: string });

// 抽出推断的类型
type User = z.infer<typeof User>;
// { username: string }
```

# 定义模式

## 基本原理

```ts
import { z } from "zod";

// 原始值
z.string();
z.number();
z.bigint();
z.boolean();
z.date();

// 空类型
z.undefined();
z.null();
z.void(); // 接受null或undefined

// 全能类型
// 允许 any value
z.any();
z.unknown();

// never 类型
// 允许没有 values
z.never();
```

## 字面意义

```ts
const tuna = z.literal("tuna");
const twelve = z.literal(12);
const tru = z.literal(true);

// 检索字面意义的值
tuna.value; // "tuna"
```

> 目前在 Zod 中不支持 Date 或 bigint 字面。如果你有这个功能的用例，请提交一个 Issue。

## Strings

Zod 包括一些针对字符串的验证。

```ts
z.string().max(5);
z.string().min(5);
z.string().length(5);
z.string().email();
z.string().url();
z.string().uuid();
z.string().regex(regex);

// 已废弃，等同于 .min(1)
z.string().nonempty();
```

> 查看 [validator.js](https://github.com/validatorjs/validator.js)，了解其他一些有用的字符串验证函数

#### 自定义错误信息

你可以选择传入第二个参数来提供一个自定义的错误信息。

```ts
z.string().min(5, { message: "Must be 5 or more characters long" });
z.string().max(5, { message: "Must be 5 or fewer characters long" });
z.string().length(5, { message: "Must be exactly 5 characters long" });
z.string().email({ message: "Invalid email address." });
z.string().url({ message: "Invalid url" });
z.string().uuid({ message: "Invalid UUID" });
```

## Numbers

Zod 包括一些特定的数字验证。

```ts
z.number().gt(5);
z.number().gte(5); // alias .min(5)
z.number().lt(5);
z.number().lte(5); // alias .max(5)

z.number().int(); // 值必须是一个整数

z.number().positive(); //     > 0
z.number().nonnegative(); //  >= 0
z.number().negative(); //     < 0
z.number().nonpositive(); //  <= 0

z.number().multipleOf(5); // x % 5 === 0
```

你可以选择传入第二个参数来提供一个自定义的错误信息。

```ts
z.number().max(5, { message: "this👏is👏too👏big" });
```

## Objects

```ts
// 所有属性都是默认需要的
const Dog = z.object({
  name: z.string(),
  age: z.number(),
});

// 像这样提取推断出的类型
type Dog = z.infer<typeof Dog>;

// 相当于:
type Dog = {
  name: string;
  age: number;
};
```

### `.shape`

使用`.shape`来访问特定键的模式。

```ts
Dog.shape.name; // => string schema
Dog.shape.age; // => number schema
```

### `.extend`

你可以用`.extend`方法在对象模式中添加额外的字段。

```ts
const DogWithBreed = Dog.extend({
  breed: z.string(),
});
```

你可以使用`.extend`来覆盖字段! 要小心使用这种方式!

### `.merge`

相当于 `A.extend(B.shape)`.

```ts
const BaseTeacher = z.object({ students: z.array(z.string()) });
const HasID = z.object({ id: z.string() });

const Teacher = BaseTeacher.merge(HasID);
type Teacher = z.infer<typeof Teacher>; // => { students: string[], id: string }
```

> 如果两个模式共享 keys，那么 B 的属性将覆盖 A 的属性。返回的模式也继承了 "unknownKeys 密钥 "策略(strip/strict/passthrough+)和 B 的全面模式。

### `.pick/.omit`

受 TypeScript 内置的`Pick`和`Omit`工具类型的启发，所有 Zod 对象模式都有`.pick`和 `.omit`方法，可以返回一个修改后的版本。考虑一下这个 Recipe 模式。

```ts
const Recipe = z.object({
  id: z.string(),
  name: z.string(),
  ingredients: z.array(z.string()),
});
```

要想只保留某些 Key，使用 `.pick` .

```ts
const JustTheName = Recipe.pick({ name: true });
type JustTheName = z.infer<typeof JustTheName>;
// => { name: string }
```

要删除某些 Key，请使用 `.omit` .

```ts
const NoIDRecipe = Recipe.omit({ id: true });

type NoIDRecipe = z.infer<typeof NoIDRecipe>;
// => { name: string, ingredients: string[] }
```

### `.partial`

受 TypeScript 内置的实用类型[Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt)的启发, `.partial` 方法使所有属性都是可选的。

从这个对象开始:

```ts
const user = z.object({
  username: z.string(),
});
// { username: string }
```

我们可以创建一个 Partial 版本:

```ts
const partialUser = user.partial();
// { username?: string | undefined }
```

### `.deepPartial`

T`.partial` 只是一个浅层的使用 — 它只适用于一个层次的深度。还有一个 "深层" 版本:

```ts
const user = z.object({
  username: z.string(),
  location: z.object({
    latitude: z.number(),
    longitude: z.number(),
  }),
});

const deepPartialUser = user.deepPartial();

/* 
{
  username?: string | undefined, 
  location?: {
    latitude?: number | undefined;
    longitude?: number | undefined;
  } | undefined
}
*/
```

> 重要的限制: `deep partials` 只在对象模式的直接层次中按预期工作。嵌套的对象模式不能是可选的，不能是空的，不能包含细化，不能包含转换，等等...

#### 未被识别的 keys

默认情况下，Zod 对象的模式在解析过程中会剥离出未被识别的 keys

```ts
const person = z.object({
  name: z.string(),
});

person.parse({
  name: "bob dylan",
  extraKey: 61,
});
// => { name: "bob dylan" }
// extraKey已经被剥离
```

### `.passthrough`

相反，如果你想通过未知的 keys，使用`.passthrough()`。

```ts
person.passthrough().parse({
  name: "bob dylan",
  extraKey: 61,
});
// => { name: "bob dylan", extraKey: 61 }
```

### `.strict`

你可以用`.strict()`来 _禁止_ 未知键。如果输入中存在任何未知的 keys，Zod 将抛出一个错误。

```ts
const person = z
  .object({
    name: z.string(),
  })
  .strict();

person.parse({
  name: "bob dylan",
  extraKey: 61,
});
// => throws ZodError
```

### `.strip`

你可以使用`.strip`方法将一个对象模式重置为默认行为(剥离未识别的 keys)。

### `.catchall`

你可以将一个 "catchall "模式传递给一个对象模式。所有未知的 keys 都将根据它进行验证。

```ts
const person = z
  .object({
    name: z.string(),
  })
  .catchall(z.number());

person.parse({
  name: "bob dylan",
  validExtraKey: 61, // 运行良好
});

person.parse({
  name: "bob dylan",
  validExtraKey: false, // 未能成功
});
// => throws ZodError
```

使用`.catchall()`可以避免`.passthrough()`，`.strip()`，或`.strict()`。现在所有的键都被视为 "已知(known)"。

## Arrays

```ts
const stringArray = z.array(z.string());

// 相当于
const stringArray = z.string().array();
```

要小心使用`.array()`方法。它返回一个新的`ZodArray`实例。这意味着你调用方法的 _顺序_ 很重要。比如说:

```ts
z.string().optional().array(); // (string | undefined)[]
z.string().array().optional(); // string[] | undefined
```

### `.nonempty`

如果你想确保一个数组至少包含一个元素，使用 `.nonempty()`.

```ts
const nonEmptyStrings = z.string().array().nonempty();
// 现在推断的类型是
// [string, ...string[]]

nonEmptyStrings.parse([]); // throws: "Array cannot be empty"
nonEmptyStrings.parse(["Ariana Grande"]); // passes
```

### `.min/.max/.length`

```ts
z.string().array().min(5); // 必须包含5个或更多元素
z.string().array().max(5); // 必须包含5个或更少元素
z.string().array().length(5); // 必须正好包含5个元素
```

与`.nonempty()`不同，这些方法不会改变推断的类型。

## Unions

Zod 包括一个内置的`z.union`方法，用于合成 "OR" 类型。

```ts
const stringOrNumber = z.union([z.string(), z.number()]);

stringOrNumber.parse("foo"); // 通过
stringOrNumber.parse(14); // 通过
```

Zod 将按照每个 "选项" 的顺序测试输入，并返回第一个成功验证的值。

为了方便，你也可以使用`.or`方法:

```ts
const stringOrNumber = z.string().or(z.number());
```

## Optionals

你可以用`z.optional()`使任何模式成为可选:

```ts
const schema = z.optional(z.string());

schema.parse(undefined); // => returns undefined
type A = z.infer<typeof schema>; // string | undefined
```

你可以用`.optional()`方法使一个现有的模式成为可选的:

```ts
const user = z.object({
  username: z.string().optional(),
});
type C = z.infer<typeof user>; // { username?: string | undefined };
```

#### `.unwrap`

```ts
const stringSchema = z.string();
const optionalString = stringSchema.optional();
optionalString.unwrap() === stringSchema; // true
```

## Nullables

类似地，你可以这样创建 nullable 类型:

```ts
const nullableString = z.nullable(z.string());
nullableString.parse("asdf"); // => "asdf"
nullableString.parse(null); // => null
```

你可以用`nullable`方法使一个现有的模式变成 nullable:

```ts
const E = z.string().nullable(); // equivalent to D
type E = z.infer<typeof E>; // string | null
```

#### `.unwrap`

```ts
const stringSchema = z.string();
const nullableString = stringSchema.nullable();
nullableString.unwrap() === stringSchema; // true
```

<!--

``` ts
/* Custom Union Types */

const F = z
  .union([z.string(), z.number(), z.boolean()])
  .optional()
  .nullable();

F.parse('tuna'); // => tuna
F.parse(42); // => 42
F.parse(true); // => true
F.parse(undefined); // => undefined
F.parse(null); // => null
F.parse({}); // => throws Error!

type F = z.infer<typeof F>; // string | number | boolean | undefined | null;
``` -->

## Records

Record 模式用于验证诸如`{ [k: string]: number }`这样的类型。

如果你想根据某种模式验证一个对象的 _value_ ，但不关心 keys，使用`Record'。

```ts
const NumberCache = z.record(z.number());

type NumberCache = z.infer<typeof NumberCache>;
// => { [k: string]: number }
```

这对于按 ID 存储或缓存项目特别有用。

```ts
const userStore: UserStore = {};

userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
  name: "Carlotta",
}; // passes

userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
  whatever: "Ice cream sundae",
}; // TypeError
```

#### 关于数字键的说明

你可能期望`z.record()`接受两个参数，一个是 key，一个是 value。毕竟，TypeScript 的内置 Record 类型是这样的：`Record<KeyType, ValueType>` 。否则，你如何在 Zod 中表示 TypeScript 类型`Record<number, any>`？

事实证明，TypeScript 围绕`[k: number]`的行为有点不直观:

```ts
const testMap: { [k: number]: string } = {
  1: "one",
};

for (const key in testMap) {
  console.log(`${key}: ${typeof key}`);
}
// prints: `1: string`
```

正如你所看到的，JavaScript 会自动将所有对象 key 转换为字符串。

由于 Zod 试图弥合静态类型和运行时类型之间的差距，提供一种创建带有数字键的记录模式的方法是没有意义的，因为在 JavaScript runtime 中没有数字键这回事。

## Maps

```ts
const stringNumberMap = z.map(z.string(), z.number());

type StringNumberMap = z.infer<typeof stringNumberMap>;
// type StringNumber = Map<string, number>
```

## Sets

```ts
const numberSet = z.set(z.number());
type numberSet = z.infer<typeof numberSet>;
// Set<number>
```

## Enums

在 Zod 中，有两种方法来定义枚举。

### Zod enums

<!-- An enum is just a union of string literals, so you _could_ define an enum like this:

```ts
const FishEnum = z.union([
  z.literal("Salmon"),
  z.literal("Tuna"),
  z.literal("Trout"),
]);

FishEnum.parse("Salmon"); // => "Salmon"
FishEnum.parse("Flounder"); // => throws
```

For convenience Zod provides a built-in `z.enum()` function. Here's is the equivalent code: -->

```ts
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
type FishEnum = z.infer<typeof FishEnum>;
// 'Salmon' | 'Tuna' | 'Trout'
```

你必须将数值数组直接传入`z.enum()`。这样做是不行的:

```ts
const fish = ["Salmon", "Tuna", "Trout"];
const FishEnum = z.enum(fish);
```

在这种情况下，Zod 无法推断出各个枚举元素；相反，推断出的类型将是 `string` 而不是`'Salmon'|'Tuna'|'Trout'`。

**自动补全**

为了获得 Zod 枚举的自动完成，请使用你的模式的`.enum`属性:

```ts
FishEnum.enum.Salmon; // => 自动补全

FishEnum.enum;
/* 
=> {
  Salmon: "Salmon",
  Tuna: "Tuna",
  Trout: "Trout",
} 
*/
```

你也可以用`.options`属性检索选项列表，作为一个元组:

```ts
FishEnum.options; // ["Salmon", "Tuna", "Trout"]);
```

### Native enums

Zod 枚举是定义和验证枚举的推荐方法。但是如果你需要对第三方库的枚举进行验证（或者你不想重写你现有的枚举），你可以使用`z.nativeEnum()`。

**数字枚举**

```ts
enum Fruits {
  Apple,
  Banana,
}

const FruitEnum = z.nativeEnum(Fruits);
type FruitEnum = z.infer<typeof FruitEnum>; // Fruits

FruitEnum.parse(Fruits.Apple); // 通过
FruitEnum.parse(Fruits.Banana); // 通过
FruitEnum.parse(0); // 通过
FruitEnum.parse(1); // 通过
FruitEnum.parse(3); // 未通过
```

**String enums**

```ts
enum Fruits {
  Apple = "apple",
  Banana = "banana",
  Cantaloupe, // 你可以混合使用数字和字符串的枚举
}

const FruitEnum = z.nativeEnum(Fruits);
type FruitEnum = z.infer<typeof FruitEnum>; // Fruits

FruitEnum.parse(Fruits.Apple); // 通过
FruitEnum.parse(Fruits.Cantaloupe); // 通过
FruitEnum.parse("apple"); // 通过
FruitEnum.parse("banana"); // 通过
FruitEnum.parse(0); // 通过
FruitEnum.parse("Cantaloupe"); // 未通过
```

**常量枚举**

`.nativeEnum()`函数也适用于`as const`对象。 ⚠️ `as const`需要 TypeScript 3.4+!

```ts
const Fruits = {
  Apple: "apple",
  Banana: "banana",
  Cantaloupe: 3,
} as const;

const FruitEnum = z.nativeEnum(Fruits);
type FruitEnum = z.infer<typeof FruitEnum>; // "apple" | "banana" | 3

FruitEnum.parse("apple"); // passes
FruitEnum.parse("banana"); // passes
FruitEnum.parse(3); // passes
FruitEnum.parse("Cantaloupe"); // fails
```

## Intersections

<!-- > ⚠️ Intersections are deprecated. If you are trying to merge objects, use the `.merge` method instead. -->

交叉类型对于创建 "logical AND"类型很有用。这对于两个对象类型的相交很有用。

```ts
const Person = z.object({
  name: z.string(),
});

const Employee = z.object({
  role: z.string(),
});

const EmployedPerson = z.intersection(Person, Employee);

// equivalent to:
const EmployedPerson = Person.and(Employee);
```

虽然在很多情况下，建议使用`A.merge(B)`来合并两个对象。`.merge`方法返回一个新的`ZodObject`实例，而`A.and(B)`返回一个不太有用的`ZodIntersection`实例，它缺乏像`pick`和`omit`这样的常用对象方法。

```ts
const a = z.union([z.number(), z.string()]);
const b = z.union([z.number(), z.boolean()]);
const c = z.intersection(a, b);

type c = z.infer<typeof c>; // => number
```

<!-- Intersections in Zod are not smart. Whatever data you pass into `.parse()` gets passed into the two intersected schemas. Because Zod object schemas don't allow any unknown keys by default, there are some unintuitive behavior surrounding intersections of object schemas. -->

<!--

``` ts
const A = z.object({
  a: z.string(),
});

const B = z.object({
  b: z.string(),
});

const AB = z.intersection(A, B);

type Teacher = z.infer<typeof Teacher>;
// { id:string; name:string };
```  -->

## Tuples

与数组不同，tuples 有固定数量的元素，每个元素可以有不同的类型。

```ts
const athleteSchema = z.tuple([
  z.string(), // name
  z.number(), // jersey number
  z.object({
    pointsScored: z.number(),
  }), // statistics
]);

type Athlete = z.infer<typeof athleteSchema>;
// type Athlete = [string, number, { pointsScored: number }]
```

## Recursive types

你可以在 Zod 中定义一个递归模式，但由于 TypeScript 的限制，它们的类型不能被静态推断。相反，你需要手动定义类型，并将其作为 "类型提示" 提供给 Zod。

```ts
interface Category {
  name: string;
  subcategories: Category[];
}

// cast to z.ZodSchema<Category>
const Category: z.ZodSchema<Category> = z.lazy(() =>
  z.object({
    name: z.string(),
    subcategories: z.array(Category),
  })
);

Category.parse({
  name: "People",
  subcategories: [
    {
      name: "Politicians",
      subcategories: [{ name: "Presidents", subcategories: [] }],
    },
  ],
}); // 通过
```

不幸的是，这段代码有点重复，因为你声明了两次类型：一次在接口中，另一次在 Zod 定义中。

<!-- If your schema has lots of primitive fields, there's a way of reducing the amount of duplication:

```ts
// define all the non-recursive stuff here
const BaseCategory = z.object({
  name: z.string(),
  tags: z.array(z.string()),
  itemCount: z.number(),
});

// create an interface that extends the base schema
interface Category extends z.infer<typeof BaseCategory> {
  subcategories: Category[];
}

// merge the base schema with
// a new Zod schema containing relations
const Category: z.ZodSchema<Category> = BaseCategory.merge(
  z.object({
    subcategories: z.lazy(() => z.array(Category)),
  })
);
``` -->

#### JSON type

如果你想验证任何 JSON 值，你可以使用下面的片段。

```ts
type Literal = boolean | null | number | string;
type Json = Literal | { [key: string]: Json } | Json[];
const literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);
const jsonSchema: z.ZodSchema<Json> = z.lazy(() =>
  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])
);

jsonSchema.parse(data);
```

感谢[ggoodman](https://github.com/ggoodman)的建议。

#### Cyclical objects

尽管支持递归模式，但将一个循环数据传入 Zod 会导致无限循环。

## Promises

```ts
const numberPromise = z.promise(z.number());
```

"Parsing"的工作方式与 promise 模式有点不同。验证分两部分进行:

1. Zod 同步检查输入是否是 Promise 的实例(即一个具有`.then`和`.catch`方法的对象)。
2. Zod 使用`.then`在现有的 Promise 上附加一个额外的验证步骤。你必须在返回的 Promise 上使用`.catch`来处理验证失败的问题。

```ts
numberPromise.parse("tuna");
// ZodError: Non-Promise type: string

numberPromise.parse(Promise.resolve("tuna"));
// => Promise<number>

const test = async () => {
  await numberPromise.parse(Promise.resolve("tuna"));
  // ZodError: Non-number type: string

  await numberPromise.parse(Promise.resolve(3.14));
  // => 3.14
};
```

<!-- #### Non-native promise implementations

When "parsing" a promise, Zod checks that the passed value is an object with `.then` and `.catch` methods — that's it. So you should be able to pass non-native Promises (Bluebird, etc) into `z.promise(...).parse` with no trouble. One gotcha: the return type of the parse function will be a _native_ `Promise` , so if you have downstream logic that uses non-standard Promise methods, this won't work. -->

## Instanceof

你可以使用`z.instanceof`来检查输入是否是一个类的实例。这对于验证从第三方库中导出的类的输入很有用。

```ts
class Test {
  name: string;
}

const TestSchema = z.instanceof(Test);

const blob: any = "whatever";
TestSchema.parse(new Test()); // passes
TestSchema.parse("blob"); // throws
```

## Function schemas

Zod 还允许你定义 "函数模式(function schemas)"。这使得验证一个函数的输入和输出变得很容易，而不需要把验证代码和 "业务逻辑(business logic)"混在一起。

你可以用`z.function(args, returnType)`创建一个函数模式。

```ts
const myFunction = z.function();

type myFunction = z.infer<typeof myFunction>;
// => ()=>unknown
```

**定义输入和输出**

```ts
const myFunction = z
  .function()
  .args(z.string(), z.number()) // 接受任意数量的参数
  .returns(z.boolean());
type myFunction = z.infer<typeof myFunction>;
// => (arg0: string, arg1: number)=>boolean
```

**提取输入和输出模式**
你可以提取一个函数模式的参数和返回类型。

```ts
myFunction.parameters();
// => ZodTuple<[ZodString, ZodNumber]>

myFunction.returnType();
// => ZodBoolean
```

<!-- `z.function()` accepts two arguments:

* `args: ZodTuple` The first argument is a tuple (created with `z.tuple([...])` and defines the schema of the arguments to your function. If the function doesn't accept arguments, you can pass an empty tuple (`z.tuple([])`).
* `returnType: any Zod schema` The second argument is the function's return type. This can be any Zod schema. -->

> 如果你的函数没有返回任何东西，你可以使用特殊的`z.void()`选项。这将让 Zod 正确地推断出无效返回的函数的类型。(无效返回的函数实际上可以返回未定义或空。)

<!--

``` ts
const args = z.tuple([z.string()]);

const returnType = z.number();

const myFunction = z.function(args, returnType);
type myFunction = z.infer<typeof myFunction>;
// => (arg0: string)=>number
``` -->

函数模式有一个`.implement()`方法，它接受一个函数并返回一个自动验证其输入和输出的新函数。

```ts
const trimmedLength = z
  .function()
  .args(z.string()) // accepts an arbitrary number of arguments
  .returns(z.number())
  .implement((x) => {
    // TypeScript knows x is a string!
    return x.trim().length;
  });

trimmedLength("sandwich"); // => 8
trimmedLength(" asdf "); // => 4
```

如果你只关心验证输入，那就好了:

```ts
const myFunction = z
  .function()
  .args(z.string())
  .implement((arg) => {
    return [arg.length]; //
  });
myFunction; // (arg: string)=>number[]
```

# ZodType: methods and properties

所有的 Zod 模式都包含一些方法。

### `.parse`

`.parse(data:unknown): T`

给定任何 Zod 模式，你可以调用其`.parse`方法来检查`data`是否有效。如果是的话，就会返回一个带有完整类型信息的值。否则，会产生一个错误。

> IMPORTANT: 在 Zod 2 和 Zod 1.11+中，`.parse`返回的值是你传入的变量的 _deep clone_ 。这在zod@1.4 和更早的版本中也是如此。

```ts
const stringSchema = z.string();
stringSchema.parse("fish"); // => returns "fish"
stringSchema.parse(12); // throws Error('Non-string type: number');
```

### `.parseAsync`

`.parseAsync(data:unknown): Promise<T>`

如果你使用异步的[refinements](#refine)或[transforms](#transform)（后面会有更多介绍），你需要使用`.parseAsync`

```ts
const stringSchema = z.string().refine(async (val) => val.length > 20);
const value = await stringSchema.parseAsync("hello"); // => hello
```

### `.safeParse`

`.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }`

如果你不希望 Zod 在验证失败时抛出错误，请使用`.safeParse`。该方法返回一个包含成功解析的数据的对象，或者一个包含验证问题详细信息的 ZodError 实例。

```ts
stringSchema.safeParse(12);
// => { success: false; error: ZodError }

stringSchema.safeParse("billie");
// => { success: true; data: 'billie' }
```

结果是一个 _discriminated union_ ，所以你可以非常方便地处理错误:

```ts
const result = stringSchema.safeParse("billie");
if (!result.success) {
  // handle error then return
  result.error;
} else {
  // do something
  result.data;
}
```

### `.safeParseAsync`

> Alias: `.spa`

一个异步版本的`safeParse`。

```ts
await stringSchema.safeParseAsync("billie");
```

为方便起见，它已被别名为`.spa`:

```ts
await stringSchema.spa("billie");
```

### `.refine`

`.refine(validator: (data:T)=>any, params?: RefineParams)`

Zod 允许你通过 _refinements_ 提供自定义验证逻辑。(关于创建多个问题和自定义错误代码等高级功能，见[`.superRefine`](#superrefine))。

Zod 被设计为尽可能地反映 TypeScript。但有许多所谓的 "细化类型"，你可能希望检查不能在 TypeScript 的类型系统中表示。例如：检查一个数字是否是一个整数，或者一个字符串是否是一个有效的电子邮件地址。

例如，你可以用`.refine`对任何 Zod 模式定义一个自定义验证检查:

```ts
const myString = z.string().refine((val) => val.length <= 255, {
  message: "String can't be more than 255 characters",
});
```

> ⚠️ 精细化函数不应该抛出。相反，它们应该返回一个虚假的值来表示失败。

#### Arguments

正如你所看到的，`.refine`需要两个参数。

1. 第一个是验证函数。这个函数接受一个输入（类型为`T`--模式的推断类型）并返回`any`。任何真实的值都会通过验证。(在zod@1.6.2 之前，验证函数必须返回一个布尔值。)
2. 第二个参数接受一些选项。你可以用它来定制某些错误处理行为:

```ts
type RefineParams = {
  // 覆盖错误信息
  message?: string;

  // 附加到错误路径中
  path?: (string | number)[];

  // params对象，你可以用它来定制消息
  // 在错误map中
  params?: object;
};
```

对于高级情况，第二个参数也可以是一个返回`RefineParams`的函数

```ts
z.string().refine(
  (val) => val.length > 10,
  (val) => ({ message: `${val} is not more than 10 characters` })
);
```

#### Customize error path

```ts
const passwordForm = z
  .object({
    password: z.string(),
    confirm: z.string(),
  })
  .refine((data) => data.password === data.confirm, {
    message: "Passwords don't match",
    path: ["confirm"], // path of error
  })
  .parse({ password: "asdf", confirm: "qwer" });
```

因为你提供了一个`路径(path)`参数，产生的错误将是:

```ts
ZodError {
  issues: [{
    "code": "custom",
    "path": [ "confirm" ],
    "message": "Passwords don't match"
  }]
}
```

#### Asynchronous refinements

细化也可以是异步的:

```ts
const userId = z.string().refine(async (id) => {
  // verify that ID exists in database
  return true;
});
```

> ⚠️ 如果你使用异步细化，你必须使用`.parseAsync`方法来解析数据! 否则 Zod 会抛出一个错误。

#### Relationship to transforms

变换(transforms)和细化(refinements)可以交错进行:

```ts
z.string()
  .transform((val) => val.length)
  .refine((val) => val > 25);
```

<!-- Note that the `path` is set to `["confirm"]` , so you can easily display this error underneath the "Confirm password" textbox.


```ts
const allForms = z.object({ passwordForm }).parse({
  passwordForm: {
    password: "asdf",
    confirm: "qwer",
  },
});
```

would result in

```

ZodError {
  issues: [{
    "code": "custom",
    "path": [ "passwordForm", "confirm" ],
    "message": "Passwords don't match"
  }]
}
``` -->

### `.superRefine`

`.refine`方法实际上是在一个更通用的（也更啰嗦）的`superRefine`方法之上的语法糖。下面是一个例子:

```ts
const Strings = z.array(z.string()).superRefine((val, ctx) => {
  if (val.length > 3) {
    ctx.addIssue({
      code: z.ZodIssueCode.too_big,
      maximum: 3,
      type: "array",
      inclusive: true,
      message: "Too many items 😡",
    });
  }

  if (val.length !== new Set(val).size) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `No duplicated allowed.`,
    });
  }
});
```

你可以随心所欲地添加问题(issues)。如果`ctx.addIssue`在函数的执行过程中没有被调用，则验证通过。

通常情况下，细化总是创建具有`ZodIssueCode.custom`错误代码的问题，但通过`superRefine`你可以创建任何代码的任何问题。每个问题代码在错误处理指南 [ERROR_HANDLING.md](ERROR_HANDLING.md) 中都有详细描述。

### `.transform`

要在解析后转换数据，请使用`transform`方法。

```ts
const stringToNumber = z.string().transform((val) => myString.length);
stringToNumber.parse("string"); // => 6
```

> ⚠️ 转化函数不得抛出。确保在转化器之前使用细化功能，以确保输入可以被转化器解析。

#### Chaining order

注意，上面的`stringToNumber`是`ZodEffects`子类的一个实例。它不是`ZodString`的实例。如果你想使用`ZodString`的内置方法（例如`.email()`），你必须在进行任何转换 _之前_ 应用这些方法。

```ts
const emailToDomain = z
  .string()
  .email()
  .transform((val) => val.split("@")[1]);

emailToDomain.parse("colinhacks@example.com"); // => example.com
```

#### Relationship to refinements

转换和细化可以交错进行:

```ts
z.string()
  .transform((val) => val.length)
  .refine((val) => val > 25);
```

#### Async transformations

转换也可以是异步的。

```ts
const IdToUser = z
  .string()
  .uuid()
  .transform(async (id) => {
    return await getUserById(id);
  });
```

> ⚠️ 如果你的模式包含异步变换器，你必须使用.parseAsync()或.safeParseAsync()来解析数据。否则，Zod 将抛出一个错误。

### `.default`

你可以使用变换器来实现 Zod 中 "默认值 "的概念。

```ts
const stringWithDefault = z.string().default("tuna");

stringWithDefault.parse(undefined); // => "tuna"
```

你可以选择在`.default`中传递一个函数，当需要生成默认值时，该函数将被重新执行:

```ts
const numberWithRandomDefault = z.number().default(Math.random);

numberWithRandomDefault.parse(undefined); // => 0.4413456736055323
numberWithRandomDefault.parse(undefined); // => 0.1871840107401901
numberWithRandomDefault.parse(undefined); // => 0.7223408162401552
```

### `.optional`

一个方便的方法，返回一个模式的可选版本。

```ts
const optionalString = z.string().optional(); // string | undefined

// equivalent to
z.optional(z.string());
```

### `.nullable`

一个方便的方法，返回一个模式的可空版本。

```ts
const nullableString = z.string().nullable(); // string | null

// equivalent to
z.nullable(z.string());
```

### `.nullish`

一个方便的方法，用于返回模式的 "nullish "版本。空白模式将同时接受`undefined`和`null`。阅读更多关于 "nullish "的概念[这里](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing).

```ts
const nullishString = z.string().nullish(); // string | null | undefined

// equivalent to
z.string().optional().nullable();
```

### `.array`

一个方便的方法，为给定类型返回一个数组模式:

```ts
const nullableString = z.string().array(); // string[]

// equivalent to
z.array(z.string());
```

### `.or`

一个用于联合类型的方便方法。

```ts
z.string().or(z.number()); // string | number

// equivalent to
z.union([z.string(), z.number()]);
```

### `.and`

一个方便的方法，用于创建交叉类型。

```ts
z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } & { age: number }

// equivalent to
z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));
```

# Type inference

你可以用`z.infer<typeof mySchema>`提取任何模式的 TypeScript 类型。

```ts
const A = z.string();
type A = z.infer<typeof A>; // string

const u: A = 12; // TypeError
const u: A = "asdf"; // compiles
```

#### What about transforms?

在现实中，每个 Zod 模式实际上都与**两种**类型相关：一个输入和一个输出。对于大多数模式（例如`z.string()`），这两种类型是相同的。但是一旦你把转换添加到混合中，这两个值就会发生分歧。例如，`z.string().transform(val => val.length)`的输入为`string`，输出为`number`。

你可以像这样分别提取输入和输出类型:

```ts
const stringToNumber = z.string().transform((val) => val.length);

// ⚠️ Important: z.infer返回OUTPUT类型!
type input = z.input<stringToNumber>; // string
type output = z.output<stringToNumber>; // number

// equivalent to z.output!
type inferred = z.infer<stringToNumber>; // number
```

# Errors

Zod 提供了一个名为 `ZodError` 的错误子类。ZodErrors 包含一个`issues` 数组，包含关于验证问题的详细信息。

```ts
const data = z
  .object({
    name: z.string(),
  })
  .safeParse({ name: 12 });

if (!data.success) {
  data.error.issues;
  /* [
      {
        "code": "invalid_type",
        "expected": "string",
        "received": "number",
        "path": [ "name" ],
        "message": "Expected string, received number"
      }
  ] */
}
```

#### Error formatting

你可以使用`.format()`方法将这个错误转换为一个嵌套对象。

```ts
data.error.format();
/* {
  name: { _errors: [ 'Expected string, received number' ] }
} */
```

关于可能的错误代码和如何定制错误信息的详细信息，请查看专门的错误处理指南: [ERROR_HANDLING.md](ERROR_HANDLING.md)

# Comparison

还有一些其他广泛使用的验证库，但它们都有一定的设计局限性，使开发者的体验不理想。

<!-- The table below summarizes the feature differences. Below the table there are more involved discussions of certain alternatives, where necessary. -->

<!-- | Feature                                                                                                                | [Zod](https://github.com/colinhacks) | [Joi](https://github.com/hapijs/joi) | [Yup](https://github.com/jquense/yup) | [io-ts](https://github.com/gcanti/io-ts) | [Runtypes](https://github.com/pelotom/runtypes) | [ow](https://github.com/sindresorhus/ow) | [class-validator](https://github.com/typestack/class-validator) |
| ---------------------------------------------------------------------------------------------------------------------- | :-----------------------------: | :----------------------------------: | :-----------------------------------: | :--------------------------------------: | :---------------------------------------------: | :--------------------------------------: | :-------------------------------------------------------------: |
| <abbr title='Any ability to extract a TypeScript type from a validator instance counts.'>Type inference</abbr>         |               🟢                |                  🔴                  |                  🟢                   |                    🟢                    |                       🟢                        |                    🟢                    |                               🟢                                |
| <abbr title="Yup's inferred types are incorrect in certain cases, see discussion below.">Correct type inference</abbr> |               🟢                |                  🔴                  |                  🔴                   |                    🟢                    |                       🟢                        |                    🟢                    |                               🟢                                |

<abbr title="number, string, boolean, null, undefined">Primitive Types</abbr>
<abbr title="Includes any checks beyond 'Is this a string?', e.g. min/max length, isEmail, isURL, case checking, etc.">String Validation</abbr>
<abbr title="Includes any checks beyond 'Is this a number?', e.g. min/max, isPositive, integer vs float, etc.">Number Validation</abbr>
Dates

Primitive Literals
Object Literals
Tuple Literals
Objects
Arrays
Non-empty arrays
Unions
Optionals
Nullable
Enums
Enum Autocomplete
Intersections
Object Merging
Tuples
Recursive Types
Function Schemas

<abbr title="For instance, Yup allows custmo error messages with the syntax yup.number().min(5, 'Number must be more than 5!')">Validation Messages</abbr>
Immutable instances
Type Guards
Validity Checking
Casting
Default Values
Rich Errors
Branded -->

<!-- - Missing object methods: (pick, omit, partial, deepPartial, merge, extend)

* Missing nonempty arrays with proper typing (`[T, ...T[]]`)
* Missing lazy/recursive types
* Missing promise schemas
* Missing function schemas
* Missing union & intersection schemas
* Missing support for parsing cyclical data (maybe)
* Missing error customization -->

#### Joi

[https://github.com/hapijs/joi](https://github.com/hapijs/joi)

不支持静态类型推理 😕

#### Yup

[https://github.com/jquense/yup](https://github.com/jquense/yup)

Yup 是一个全功能的库，首先用 vanilla JS 实现，后来又用 TypeScript 重写。

不同之处

- 支持铸造和转换
- 所有的对象字段默认都是可选的
- 缺少方法: (partial, deepPartial)
<!-- - Missing nonempty arrays with proper typing (`[T, ...T[]]`) -->
- 缺少 promise 模式
- 缺少 function 模式
- 缺少联合和交叉模式

<!-- ¹Yup has a strange interpretation of the word `required`. Instead of meaning "not undefined", Yup uses it to mean "not empty". So `yup.string().required()` will not accept an empty string, and `yup.array(yup.string()).required()` will not accept an empty array. Instead, Yup us Zod arrays there is a dedicated `.nonempty()` method to indicate this, or you can implement it with a custom refinement. -->

#### io-ts

[https://github.com/gcanti/io-ts](https://github.com/gcanti/io-ts)

io-ts 是 gcanti 的一个优秀库。io-ts 的 API 极大地启发了 Zod 的设计。

根据我们的经验，在许多情况下，io-ts 优先考虑功能编程的纯洁性，而不是开发者的经验。这是一个有效的和令人钦佩的设计目标，但它使 io-ts 特别难以集成到一个现有的程序化或面向对象的代码库中。例如，考虑如何在 io-ts 中定义一个具有可选属性的对象:

```ts
import * as t from "io-ts";

const A = t.type({
  foo: t.string,
});

const B = t.partial({
  bar: t.number,
});

const C = t.intersection([A, B]);

type C = t.TypeOf<typeof C>;
// returns { foo: string; bar?: number | undefined }
```

你必须在不同的对象验证器中定义必需的和可选的道具，通过`t.partial`（它将所有属性标记为可选）传递选项，然后用`t.intersection`组合它们。

考虑在 Zod 中的对应关系:

```ts
const C = z.object({
  foo: z.string(),
  bar: z.number().optional(),
});

type C = z.infer<typeof C>;
// returns { foo: string; bar?: number | undefined }
```

这种更具声明性的 API 使模式定义更加简明。

`io-ts`也需要使用 gcanti 的函数式编程库`fp-ts`来解析结果和处理错误。对于希望严格保持代码库功能的开发者来说，这是另一个极好的资源。但是，依赖`fp-ts`必然带来大量的知识开销；开发人员必须熟悉函数式编程的概念和`fp-ts`的命名，才能使用这个库。

- 支持具有序列化和反序列化转换功能的编解码器
- 支持 branded types
- 支持高级函数式编程、高级类型、`fp-ts`。compatibility
- 缺少的方法:(pick, omit, partial, deepPartial, merge, extend)
- 缺少具有正确类型的非空数组（`[T, ...T[]]）。
- 缺少 promise 模式
- 缺少 function 模式

#### Runtypes

[https://github.com/pelotom/runtypes](https://github.com/pelotom/runtypes)

良好的类型推理支持，但对象类型屏蔽的选项有限（没有`.pick`，`.omit`，`.extend`，等等）。不支持 `Record`（他们的 `Record` 等同于 Zod 的 `object` ）。他们确实支持 branded 和 readonly 类型，而 Zod 不支持。

- 支持 "模式匹配(pattern matching)"：分布在联合体上的计算属性
- 支持只读类型
- 缺少的方法:(deepPartial, merge)
- 缺少具有适当类型的非空数组（`[T, ...T[]]）。
- 缺少 promise 模式
- 缺少错误定制功能

#### Ow

[https://github.com/sindresorhus/ow](https://github.com/sindresorhus/ow)

Ow 专注于函数输入验证。它是一个使复杂的断言语句容易表达的库，但它不能让你解析未定型的数据。他们支持更多的类型；Zod 与 TypeScript 的类型系统几乎是一对一的映射，而 Ow 可以让你验证几个高度特定的类型（例如`int32Array`，见他们的 README 中的完整列表）。

如果你想验证函数输入，请在 Zod 中使用函数模式! 这是一个更简单的方法，让你可以重复使用一个函数类型声明，而不需要重复自己（即在每个函数的开头复制粘贴一堆 ow assertions）。此外，Zod 还可以让你验证你的返回类型，所以你可以确保不会有任何意外的数据传递到下游。

# Changelog

查看更新日志点击 [CHANGELOG.md](CHANGELOG.md)
````

## File: README.md
````markdown
<p align="center">
  <img src="logo.svg" width="200px" align="center" />
  <h1 align="center">Zod</h1>
</p>
<p align="center">
<a href="https://github.com/edgedb/edgedb-js/actions"><img src="https://github.com/colinhacks/zod/actions/workflows/test.yml/badge.svg?event=push&branch=master" alt="Zod CI status" /></a>
<a href="https://twitter.com/colinhacks" rel="nofollow"><img src="https://img.shields.io/badge/created%20by-@colinhacks-4BBAAB.svg" alt="Created by Colin McDonnell"></a>
<a href="https://opensource.org/licenses/MIT" rel="nofollow"><img src="https://img.shields.io/github/license/colinhacks/zod" alt="License"></a>
<a href="https://www.npmjs.com/package/zod" rel="nofollow"><img src="https://img.shields.io/npm/dw/zod.svg" alt="npm"></a>
<a href="https://www.npmjs.com/package/zod" rel="nofollow"><img src="https://img.shields.io/github/stars/colinhacks/zod" alt="stars"></a>
<a href="https://discord.gg/KaSRdyX2vc" rel="nofollow"><img src="https://img.shields.io/discord/893487829802418277?label=Discord&logo=discord&logoColor=white" alt="discord server"></a>
</p>

<div align="center">
  <a href="https://discord.gg/RcG33DQJdf">Discord</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://www.npmjs.com/package/zod">NPM</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://github.com/colinhacks/zod/issues/new">Issues</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://twitter.com/colinhacks">@colinhacks</a>
  <span>&nbsp;&nbsp;•&nbsp;&nbsp;</span>
  <a href="https://trpc.io">tRPC</a>
  <br />
</div>

<br/>

These docs have been translated into [Chinese](./README_ZH.md).

## Table of contents

<!-- The full documentation is available both on the [official documentation site](https://zod.js.org/) (recommended) and in `README.md`.

### Go to [zod.js.org](https://zod.js.org) >> -->

- [What is Zod](#what-is-zod)
- [Installation](#installation)
- [Ecosystem](#ecosystem)
- [Basic usage](#basic-usage)
- [Defining schemas](#defining-schemas)
  - [Primitives](#primitives)
  - [Literals](#literals)
  - [Strings](#strings)
  - [Numbers](#numbers)
  - [NaNs](#nans)
  - [Booleans](#booleans)
  - [Dates](#dates)
  - [Zod enums](#zod-enums)
  - [Native enums](#native-enums)
  - [Optionals](#optionals)
  - [Nullables](#nullables)
  - [Objects](#objects)
    - [.shape](#shape)
    - [.extend](#extend)
    - [.merge](#merge)
    - [.pick/.omit](#pickomit)
    - [.partial](#partial)
    - [.deepPartial](#deepPartial)
    - [.passthrough](#passthrough)
    - [.strict](#strict)
    - [.strip](#strip)
    - [.catchall](#catchall)
  - [Arrays](#arrays)
    - [.element](#element)
    - [.nonempty](#nonempty)
    - [.min/.max/.length](#minmaxlength)
  - [Tuples](#tuples)
  - [Records](#records)
  - [Maps](#maps)
  - [Sets](#sets)
  - [Unions](#unions)
    - [Discriminated Unions](#discriminated-unions)
  - [Recursive types](#recursive-types)
    - [JSON type](#json-type)
    - [Cyclical data](#cyclical-objects)
  - [Promises](#promises)
  - [Instanceof](#instanceof)
  - [Function schemas](#function-schemas)
  - [Preprocess](#preprocess)
- [Common methods](#common-methods)
  - [.parse](#parse)
  - [.parseAsync](#parseasync)
  - [.safeParse](#safeparse)
  - [.safeParseAsync](#safeparseasync)
  - [.refine](#refine)
  - [.superRefine](#superRefine)
  - [.transform](#transform)
  - [.default](#default)
  - [.optional](#optional)
  - [.nullable](#nullable)
  - [.nullish](#nullish)
  - [.array](#array)
  - [.promise](#promise)
  - [.or](#or)
  - [.and](#and)
- [Guides and concepts](#guides-and-concepts)
  - [Type inference](#type-inference)
  - [Writing generic functions](#writing-generic-functions)
  - [Error handling](#error-handling)
- [Comparison](#comparison)
  - [Joi](#joi)
  - [Yup](#yup)
  - [io-ts](#io-ts)
  - [Runtypes](#runtypes)
- [Changelog](#changelog)

<!-- **Zod 2 is coming! Follow [@colinhacks](https://twitter.com/colinhacks) to stay updated and discuss the future of Zod.** -->

## What is Zod

Zod is a TypeScript-first schema declaration and validation library. I'm using the term "schema" to broadly refer to any data type, from a simple `string` to a complex nested object.

Zod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator _once_ and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures.

Some other great aspects:

- Zero dependencies
- Works in Node.js and all modern browsers
- Tiny: 8kb minified + zipped
- Immutable: methods (i.e. `.optional()`) return a new instance
- Concise, chainable interface
- Functional approach: [parse, don't validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)
- Works with plain JavaScript too! You don't need to use TypeScript.

## Sponsorship

Sponsorship at any level is appreciated and encouraged. Zod is maintained by a solo developer ([hi!](https://twitter.com/colinhacks)). For individual developers, consider the [Cup of Coffee tier](https://github.com/sponsors/colinhacks). If you built a paid product using Zod, consider the [Startup tier](https://github.com/sponsors/colinhacks). You can learn more about the tiers at [github.com/sponsors/colinhacks](https://github.com/sponsors/colinhacks).

<table>
  <tr>
   <td align="center">
      <a href="https://deletype.com/">
        <img src="https://avatars0.githubusercontent.com/u/15068039?s=200&v=4" width="100px;" alt="" />
      </a>
      <br>
      <b>Deletype</b>
      <br>
      <a href="https://deletype.com/">deletype.com/</a>
    </td>
  <td align="center">
      <a href="https://github.com/kevinsimper">
        <img src="https://avatars1.githubusercontent.com/u/1126497?s=460&v=4" width="100px;" alt="" />
      </a>
      <br>
      <b>Kevin Simper</b>
      <br>
      <a href="https://github.com/kevinsimper">@kevinsimper</a>
    </td>
    <td align="center">
      <a href="https://twitter.com/flybayer">
        <img src="https://avatars2.githubusercontent.com/u/8813276?s=460&u=4ff8beb9a67b173015c4b426a92d89cab960af1b&v=4" width="100px;" alt=""/>
      </a>
      <br>
      <b>Brandon Bayer</b>
      <br/>
      <a href="https://twitter.com/flybayer">@flybayer</a>,
      <span>creator of <a href="https://blitzjs.com">Blitz.js</a></span>
      <br />
    </td>

  </tr>
  <tr>
    <td align="center">
      <a href="https://www.bamboocreative.nz/">
        <img src="https://avatars1.githubusercontent.com/u/41406870?s=460&v=4" width="100px;" alt="" />
      </a>
      <br>
      <b>Bamboo Creative</b>
      <br>
      <a href="https://www.bamboocreative.nz/">bamboocreative.nz</a>
    </td>
    <td align="center">
      <a href="https://github.com/jeremyBanks">
        <img src="https://avatars.githubusercontent.com/u/18020?s=400&u=dba6c1402ae1746a276a5d256e01d68e774a0e9d&v=4" width="100px;" alt="" />
      </a>
      <br>
      <b>Jeremy Banks</b>
      <br>
      <a href="https://github.com/jeremyBanks">github.com/jeremyBanks</a>
    </td>
     <td align="center">
      <a href="https://marcatopartners.com/">
        <img src="https://avatars.githubusercontent.com/u/84106192?s=200&v=4" width="100px;" alt="Marcato Partners" />
      </a>
      <br>
      <b>Marcato Partners</b>
      <br>
      <a href="https://marcatopartners.com/">marcatopartners.com</a>
    </td>
  </tr>
</table>

_To get your name + Twitter + website here, sponsor Zod at the [Freelancer](https://github.com/sponsors/colinhacks) or [Consultancy](https://github.com/sponsors/colinhacks) tier._

## Installation

To install Zod v3:

```sh
npm install zod
```

⚠️ IMPORTANT: You must enable `strict` mode in your `tsconfig.json`. This is a best practice for all TypeScript projects.

```ts
// tsconfig.json
{
  // ...
  "compilerOptions": {
    // ...
    "strict": true
  }
}
```

**TypeScript requirements**

- Zod 3.x requires TypeScript 4.1+
- Zod 2.x requires TypeScript 3.7+
- Zod 1.x requires TypeScript 3.3+

## Ecosystem

There are a growing number of tools that are built atop or support Zod natively! If you've built a tool or library on top of Zod, tell me about it [on Twitter](https://twitter.com/colinhacks) or [start a Discussion](https://github.com/colinhacks/zod/discussions). I'll add it below and tweet it out.

- [`tRPC`](https://github.com/trpc/trpc): Build end-to-end typesafe APIs without GraphQL.
- [`ts-to-zod`](https://github.com/fabien0102/ts-to-zod): Convert TypeScript definitions into Zod schemas.
- [`zod-to-ts`](https://github.com/sachinraja/zod-to-ts): Generate TypeScript definitions from Zod schemas.
- [`@anatine/zod-openapi`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-openapi): Converts a Zod schema to an OpenAPI v3.x `SchemaObject`.
- [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/Marak/Faker.js).
- [`@anatine/zod-nestjs`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-nestjs): Helper methods for using Zod in a NestJS project.
- [`zod-mocking`](https://github.com/dipasqualew/zod-mocking): Generate mock data from your Zod schemas.
- [`zod-fast-check`](https://github.com/DavidTimms/zod-fast-check): Generate `fast-check` arbitraries from Zod schemas.
- [`zod-endpoints`](https://github.com/flock-community/zod-endpoints): Contract-first strictly typed endpoints with Zod. OpenAPI compatible.
- [`express-zod-api`](https://github.com/RobinTail/express-zod-api): Build Express-based APIs with I/O schema validation and custom middlewares.
- [`zod-to-json-schema`](https://github.com/StefanTerdell/zod-to-json-schema): Convert your Zod schemas into [JSON Schemas](https://json-schema.org/).
- [`json-schema-to-zod`](https://github.com/StefanTerdell/json-schema-to-zod): Convert your [JSON Schemas](https://json-schema.org/) into Zod schemas. Use it live [here](https://StefanTerdell.github.io/json-schema-to-zod-react/).
- [`json-to-zod`](https://github.com/rsinohara/json-to-zod): Convert JSON objects into Zod schemas. Use it live [here](https://rsinohara.github.io/json-to-zod-react/).
- [`zod-dto`](https://github.com/kbkk/abitia/tree/master/packages/zod-dto): Generate Nest.js DTOs from a Zod schema.
- [`soly`](https://github.com/mdbetancourt/soly): Create CLI applications with zod.
- [`graphql-codegen-typescript-validation-schema`](https://github.com/Code-Hex/graphql-codegen-typescript-validation-schema): GraphQL Code Generator plugin to generate form validation schema from your GraphQL schema
- [`zod-prisma`](https://github.com/CarterGrimmeisen/zod-prisma): Generate Zod schemas from your Prisma schema.
- [`fastify-type-provider-zod`](https://github.com/turkerdev/fastify-type-provider-zod): Create Fastify type providers from Zod schemas
- [`Supervillain`](https://github.com/Southclaws/supervillain): Generate Zod schemas from your Go structs

**Form integrations**

- [`react-hook-form`](https://github.com/react-hook-form/resolvers#zod): A first-party Zod resolver for React Hook Form
- [`zod-formik-adapter`](https://github.com/robertLichtnow/zod-formik-adapter): A community-maintained Formik adapter for Zod
- [`react-zorm`](https://github.com/esamattis/react-zorm): Standalone `<form>` generation and validation for React using Zod

## Basic usage

Create a string schema

```ts
import { z } from "zod";

// creating a schema for strings
const mySchema = z.string();

// parsing
mySchema.parse("tuna"); // => "tuna"
mySchema.parse(12); // => throws ZodError

// "safe" parsing (doesn't throw error if validation fails)
mySchema.safeParse("tuna"); // => { success: true; data: "tuna" }
mySchema.safeParse(12); // => { success: false; error: ZodError }
```

Create an object schema

```ts
import { z } from "zod";

const User = z.object({
  username: z.string(),
});
```

Parse a value

```ts
User.parse({ username: "Ludwig" });
// => { username: "Ludwig" }

User.parse({ usrnm: "Ludwig" });
// error
```

Extract an inferred type

```ts
type User = z.infer<typeof User>;
// { username: string }

const bobby: User = { username: "bobby" };
```

### <hr />

## Primitives

```ts
import { z } from "zod";

// primitive values
z.string();
z.number();
z.bigint();
z.boolean();
z.date();

// empty types
z.undefined();
z.null();
z.void(); // accepts undefined

// catch-all types
// allows any value
z.any();
z.unknown();

// never type
// allows no values
z.never();
```

## Literals

```ts
const tuna = z.literal("tuna");
const twelve = z.literal(12);
const tru = z.literal(true);

// retrieve literal value
tuna.value; // "tuna"
```

> Currently there is no support for Date or bigint literals in Zod. If you have a use case for this feature, please file an issue.

## Strings

Zod includes a handful of string-specific validations.

```ts
z.string().max(5);
z.string().min(5);
z.string().length(5);
z.string().email();
z.string().url();
z.string().uuid();
z.string().cuid();
z.string().regex(regex);

// deprecated, equivalent to .min(1)
z.string().nonempty();

// optional custom error message
z.string().nonempty({ message: "Can't be empty" });
```

> Check out [validator.js](https://github.com/validatorjs/validator.js) for a bunch of other useful string validation functions.

### Custom error messages

You can customize certain errors when creating a string schema.

```ts
const name = z.string({
  required_error: "Name is required",
  invalid_type_error: "Name must be a string",
});
```

When using validation methods, you can pass in an additional argument to provide a custom error message.

```ts
z.string().min(5, { message: "Must be 5 or more characters long" });
z.string().max(5, { message: "Must be 5 or fewer characters long" });
z.string().length(5, { message: "Must be exactly 5 characters long" });
z.string().email({ message: "Invalid email address" });
z.string().url({ message: "Invalid url" });
z.string().uuid({ message: "Invalid UUID" });
```

## Numbers

You can customize certain error messages when creating a number schema.

```ts
const age = z.number({
  required_error: "Age is required",
  invalid_type_error: "Age must be a number",
});
```

Zod includes a handful of number-specific validations.

```ts
z.number().gt(5);
z.number().gte(5); // alias .min(5)
z.number().lt(5);
z.number().lte(5); // alias .max(5)

z.number().int(); // value must be an integer

z.number().positive(); //     > 0
z.number().nonnegative(); //  >= 0
z.number().negative(); //     < 0
z.number().nonpositive(); //  <= 0

z.number().multipleOf(5); // Evenly divisible by 5. Alias .step(5)
```

Optionally, you can pass in a second argument to provide a custom error message.

```ts
z.number().lte(5, { message: "this👏is👏too👏big" });
```

## NaNs

You can customize certain error messages when creating a nan schema.

```ts
const isNaN = z.nan({
  required_error: "isNaN is required",
  invalid_type_error: "isNaN must be not a number",
});
```

## Booleans

You can customize certain error messages when creating a boolean schema.

```ts
const isActive = z.boolean({
  required_error: "isActive is required",
  invalid_type_error: "isActive must be a boolean",
});
```

## Dates

z.date() accepts a date, not a date string

```ts
z.date().safeParse(new Date()); // success: true
z.date().safeParse("2022-01-12T00:00:00.000Z"); // success: false
```

To allow for dates or date strings, you can use preprocess

```ts
const dateSchema = z.preprocess((arg) => {
  if (typeof arg == "string" || arg instanceof Date) return new Date(arg);
}, z.date());
type DateSchema = z.infer<typeof dateSchema>;
// type DateSchema = Date

dateSchema.safeParse(new Date("1/12/22")); // success: true
dateSchema.safeParse("2022-01-12T00:00:00.000Z"); // success: true
```

## Zod enums

```ts
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
type FishEnum = z.infer<typeof FishEnum>;
// 'Salmon' | 'Tuna' | 'Trout'
```

`z.enum` is a Zod-native way to declare a schema with a fixed set of allowable _string_ values. Pass the array of values directly into `z.enum()`. Alternatively, use `as const` to define your enum values as a tuple of strings. See the [const assertion docs](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) for details.

```ts
const VALUES = ["Salmon", "Tuna", "Trout"] as const;
const FishEnum = z.enum(VALUES);
```

This is not allowed, since Zod isn't able to infer the exact values of each elements.

```ts
const fish = ["Salmon", "Tuna", "Trout"];
const FishEnum = z.enum(fish);
```

**Autocompletion**

To get autocompletion with a Zod enum, use the `.enum` property of your schema:

```ts
FishEnum.enum.Salmon; // => autocompletes

FishEnum.enum;
/*
=> {
  Salmon: "Salmon",
  Tuna: "Tuna",
  Trout: "Trout",
}
*/
```

You can also retrieve the list of options as a tuple with the `.options` property:

```ts
FishEnum.options; // ["Salmon", "Tuna", "Trout"]);
```

## Native enums

Zod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-party library (or you don't want to rewrite your existing enums) you can use `z.nativeEnum()` .

**Numeric enums**

```ts
enum Fruits {
  Apple,
  Banana,
}

const FruitEnum = z.nativeEnum(Fruits);
type FruitEnum = z.infer<typeof FruitEnum>; // Fruits

FruitEnum.parse(Fruits.Apple); // passes
FruitEnum.parse(Fruits.Banana); // passes
FruitEnum.parse(0); // passes
FruitEnum.parse(1); // passes
FruitEnum.parse(3); // fails
```

**String enums**

```ts
enum Fruits {
  Apple = "apple",
  Banana = "banana",
  Cantaloupe, // you can mix numerical and string enums
}

const FruitEnum = z.nativeEnum(Fruits);
type FruitEnum = z.infer<typeof FruitEnum>; // Fruits

FruitEnum.parse(Fruits.Apple); // passes
FruitEnum.parse(Fruits.Cantaloupe); // passes
FruitEnum.parse("apple"); // passes
FruitEnum.parse("banana"); // passes
FruitEnum.parse(0); // passes
FruitEnum.parse("Cantaloupe"); // fails
```

**Const enums**

The `.nativeEnum()` function works for `as const` objects as well. ⚠️ `as const` required TypeScript 3.4+!

```ts
const Fruits = {
  Apple: "apple",
  Banana: "banana",
  Cantaloupe: 3,
} as const;

const FruitEnum = z.nativeEnum(Fruits);
type FruitEnum = z.infer<typeof FruitEnum>; // "apple" | "banana" | 3

FruitEnum.parse("apple"); // passes
FruitEnum.parse("banana"); // passes
FruitEnum.parse(3); // passes
FruitEnum.parse("Cantaloupe"); // fails
```

You can access the underlying object with the `.enum` property:

```ts
FruitEnum.enum.Apple; // "apple"
```

## Optionals

You can make any schema optional with `z.optional()`:

```ts
const schema = z.optional(z.string());

schema.parse(undefined); // => returns undefined
type A = z.infer<typeof schema>; // string | undefined
```

You can make an existing schema optional with the `.optional()` method:

```ts
const user = z.object({
  username: z.string().optional(),
});
type C = z.infer<typeof user>; // { username?: string | undefined };
```

### `.unwrap`

```ts
const stringSchema = z.string();
const optionalString = stringSchema.optional();
optionalString.unwrap() === stringSchema; // true
```

## Nullables

Similarly, you can create nullable types like so:

```ts
const nullableString = z.nullable(z.string());
nullableString.parse("asdf"); // => "asdf"
nullableString.parse(null); // => null
```

You can make an existing schema nullable with the `nullable` method:

```ts
const E = z.string().nullable(); // equivalent to D
type E = z.infer<typeof E>; // string | null
```

### `.unwrap`

```ts
const stringSchema = z.string();
const nullableString = stringSchema.nullable();
nullableString.unwrap() === stringSchema; // true
```

## Objects

```ts
// all properties are required by default
const Dog = z.object({
  name: z.string(),
  age: z.number(),
});

// extract the inferred type like this
type Dog = z.infer<typeof Dog>;

// equivalent to:
type Dog = {
  name: string;
  age: number;
};
```

### `.shape`

Use `.shape` to access the schemas for a particular key.

```ts
Dog.shape.name; // => string schema
Dog.shape.age; // => number schema
```

### `.extend`

You can add additional fields an object schema with the `.extend` method.

```ts
const DogWithBreed = Dog.extend({
  breed: z.string(),
});
```

You can use `.extend` to overwrite fields! Be careful with this power!

### `.merge`

Equivalent to `A.extend(B.shape)`.

```ts
const BaseTeacher = z.object({ students: z.array(z.string()) });
const HasID = z.object({ id: z.string() });

const Teacher = BaseTeacher.merge(HasID);
type Teacher = z.infer<typeof Teacher>; // => { students: string[], id: string }
```

> If the two schemas share keys, the properties of B overrides the property of A. The returned schema also inherits the "unknownKeys" policy (strip/strict/passthrough) and the catchall schema of B.

### `.pick/.omit`

Inspired by TypeScript's built-in `Pick` and `Omit` utility types, all Zod object schemas have `.pick` and `.omit` methods that return a modified version. Consider this Recipe schema:

```ts
const Recipe = z.object({
  id: z.string(),
  name: z.string(),
  ingredients: z.array(z.string()),
});
```

To only keep certain keys, use `.pick` .

```ts
const JustTheName = Recipe.pick({ name: true });
type JustTheName = z.infer<typeof JustTheName>;
// => { name: string }
```

To remove certain keys, use `.omit` .

```ts
const NoIDRecipe = Recipe.omit({ id: true });

type NoIDRecipe = z.infer<typeof NoIDRecipe>;
// => { name: string, ingredients: string[] }
```

### `.partial`

Inspired by the built-in TypeScript utility type [Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt), the `.partial` method makes all properties optional.

Starting from this object:

```ts
const user = z.object({
  email: z.string()
  username: z.string(),
});
// { email: string; username: string }
```

We can create a partial version:

```ts
const partialUser = user.partial();
// { email?: string | undefined; username?: string | undefined }
```

You can also specify which properties to make optional:

```ts
const optionalEmail = user.partial({
  email: true,
});
/*
{
  email?: string | undefined;
  username: string
}
*/
```

### `.deepPartial`

The `.partial` method is shallow — it only applies one level deep. There is also a "deep" version:

```ts
const user = z.object({
  username: z.string(),
  location: z.object({
    latitude: z.number(),
    longitude: z.number(),
  }),
  strings: z.array(z.object({ value: z.string() })),
});

const deepPartialUser = user.deepPartial();

/*
{
  username?: string | undefined,
  location?: {
    latitude?: number | undefined;
    longitude?: number | undefined;
  } | undefined,
  strings?: { value?: string}[]
}
*/
```

> Important limitation: deep partials only work as expected in hierarchies of objects, arrays, and tuples.

### Unrecognized keys

By default Zod objects schemas strip out unrecognized keys during parsing.

```ts
const person = z.object({
  name: z.string(),
});

person.parse({
  name: "bob dylan",
  extraKey: 61,
});
// => { name: "bob dylan" }
// extraKey has been stripped
```

### `.passthrough`

Instead, if you want to pass through unknown keys, use `.passthrough()` .

```ts
person.passthrough().parse({
  name: "bob dylan",
  extraKey: 61,
});
// => { name: "bob dylan", extraKey: 61 }
```

### `.strict`

You can _disallow_ unknown keys with `.strict()` . If there are any unknown keys in the input, Zod will throw an error.

```ts
const person = z
  .object({
    name: z.string(),
  })
  .strict();

person.parse({
  name: "bob dylan",
  extraKey: 61,
});
// => throws ZodError
```

### `.strip`

You can use the `.strip` method to reset an object schema to the default behavior (stripping unrecognized keys).

### `.catchall`

You can pass a "catchall" schema into an object schema. All unknown keys will be validated against it.

```ts
const person = z
  .object({
    name: z.string(),
  })
  .catchall(z.number());

person.parse({
  name: "bob dylan",
  validExtraKey: 61, // works fine
});

person.parse({
  name: "bob dylan",
  validExtraKey: false, // fails
});
// => throws ZodError
```

Using `.catchall()` obviates `.passthrough()` , `.strip()` , or `.strict()`. All keys are now considered "known".

## Arrays

```ts
const stringArray = z.array(z.string());

// equivalent
const stringArray = z.string().array();
```

Be careful with the `.array()` method. It returns a new `ZodArray` instance. This means the _order_ in which you call methods matters. For instance:

```ts
z.string().optional().array(); // (string | undefined)[]
z.string().array().optional(); // string[] | undefined
```

### `.element`

Use `.element` to access the schema for an element of the array.

```ts
stringArray.element; // => string schema
```

### `.nonempty`

If you want to ensure that an array contains at least one element, use `.nonempty()`.

```ts
const nonEmptyStrings = z.string().array().nonempty();
// the inferred type is now
// [string, ...string[]]

nonEmptyStrings.parse([]); // throws: "Array cannot be empty"
nonEmptyStrings.parse(["Ariana Grande"]); // passes
```

You can optionally specify a custom error message:

```ts
// optional custom error message
const nonEmptyStrings = z.string().array().nonempty({
  message: "Can't be empty!",
});
```

### `.min/.max/.length`

```ts
z.string().array().min(5); // must contain 5 or more items
z.string().array().max(5); // must contain 5 or fewer items
z.string().array().length(5); // must contain 5 items exactly
```

Unlike `.nonempty()` these methods do not change the inferred type.

## Tuples

Unlike arrays, tuples have a fixed number of elements and each element can have a different type.

```ts
const athleteSchema = z.tuple([
  z.string(), // name
  z.number(), // jersey number
  z.object({
    pointsScored: z.number(),
  }), // statistics
]);

type Athlete = z.infer<typeof athleteSchema>;
// type Athlete = [string, number, { pointsScored: number }]
```

## Unions

Zod includes a built-in `z.union` method for composing "OR" types.

```ts
const stringOrNumber = z.union([z.string(), z.number()]);

stringOrNumber.parse("foo"); // passes
stringOrNumber.parse(14); // passes
```

Zod will test the input against each of the "options" in order and return the first value that validates successfully.

For convenience, you can also use the `.or` method:

```ts
const stringOrNumber = z.string().or(z.number());
```

## Discriminated unions

If the union consists of object schemas all identifiable by a common property, it is possible to use the `z.discriminatedUnion` method.

```ts
const item = z
  .discriminatedUnion("type", [
    z.object({ type: z.literal("a"), a: z.string() }),
    z.object({ type: z.literal("b"), b: z.string() }),
  ])
  .parse({ type: "a", a: "abc" });
```

This provides more efficient evaluation and more human-friendly errors. Using simple unions, the input is tested against each of the provided "options" in order. If all options fail validation, the returned error contains the "suberrors" thrown by each option.

By contrast, the discriminated union uses the discriminator key to determine which option to testing against.

## Records

Record schemas are used to validate types such as `{ [k: string]: number }`.

If you want to validate the _values_ of an object against some schema but don't care about the keys, use `Record`.

```ts
const NumberCache = z.record(z.number());

type NumberCache = z.infer<typeof NumberCache>;
// => { [k: string]: number }
```

This is particularly useful for storing or caching items by ID.

```ts
const userStore: UserStore = {};

userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
  name: "Carlotta",
}; // passes

userStore["77d2586b-9e8e-4ecf-8b21-ea7e0530eadd"] = {
  whatever: "Ice cream sundae",
}; // TypeError
```

### A note on numerical keys

You may have expected `z.record()` to accept two arguments, one for the keys and one for the values. After all, TypeScript's built-in Record type does: `Record<KeyType, ValueType>` . Otherwise, how do you represent the TypeScript type `Record<number, any>` in Zod?

As it turns out, TypeScript's behavior surrounding `[k: number]` is a little unintuitive:

```ts
const testMap: { [k: number]: string } = {
  1: "one",
};

for (const key in testMap) {
  console.log(`${key}: ${typeof key}`);
}
// prints: `1: string`
```

As you can see, JavaScript automatically casts all object keys to strings under the hood.

Since Zod is trying to bridge the gap between static and runtime types, it doesn't make sense to provide a way of creating a record schema with numerical keys, since there's no such thing as a numerical key in runtime JavaScript.

## Maps

```ts
const stringNumberMap = z.map(z.string(), z.number());

type StringNumberMap = z.infer<typeof stringNumberMap>;
// type StringNumberMap = Map<string, number>
```

## Sets

```ts
const numberSet = z.set(z.number());
type NumberSet = z.infer<typeof numberSet>;
// type NumberSet = Set<number>
```

### `.nonempty/.min/.max/.size`

```ts
z.set(z.string()).nonempty(); // must contain at least one item
z.set(z.string()).min(5); // must contain 5 or more items
z.set(z.string()).max(5); // must contain 5 or fewer items
z.set(z.string()).size(5); // must contain 5 items exactly
```

## Intersections

<!-- > ⚠️ Intersections are deprecated. If you are trying to merge objects, use the `.merge` method instead. -->

Intersections are useful for creating "logical AND" types. This is useful for intersecting two object types.

```ts
const Person = z.object({
  name: z.string(),
});

const Employee = z.object({
  role: z.string(),
});

const EmployedPerson = z.intersection(Person, Employee);

// equivalent to:
const EmployedPerson = Person.and(Employee);
```

Though in many cases, it is recommended to use `A.merge(B)` to merge two objects. The `.merge` method returns a new `ZodObject` instance, whereas `A.and(B)` returns a less useful `ZodIntersection` instance that lacks common object methods like `pick` and `omit`.

```ts
const a = z.union([z.number(), z.string()]);
const b = z.union([z.number(), z.boolean()]);
const c = z.intersection(a, b);

type c = z.infer<typeof c>; // => number
```

<!-- Intersections in Zod are not smart. Whatever data you pass into `.parse()` gets passed into the two intersected schemas. Because Zod object schemas don't allow any unknown keys by default, there are some unintuitive behavior surrounding intersections of object schemas. -->

<!--

``` ts
const A = z.object({
  a: z.string(),
});

const B = z.object({
  b: z.string(),
});

const AB = z.intersection(A, B);

type Teacher = z.infer<typeof Teacher>;
// { id:string; name:string };
```  -->

## Recursive types

You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a "type hint".

```ts
interface Category {
  name: string;
  subcategories: Category[];
}

// cast to z.ZodType<Category>
const Category: z.ZodType<Category> = z.lazy(() =>
  z.object({
    name: z.string(),
    subcategories: z.array(Category),
  })
);

Category.parse({
  name: "People",
  subcategories: [
    {
      name: "Politicians",
      subcategories: [{ name: "Presidents", subcategories: [] }],
    },
  ],
}); // passes
```

Unfortunately this code is a bit duplicative, since you're declaring the types twice: once in the interface and again in the Zod definition.

<!-- If your schema has lots of primitive fields, there's a way of reducing the amount of duplication:

```ts
// define all the non-recursive stuff here
const BaseCategory = z.object({
  name: z.string(),
  tags: z.array(z.string()),
  itemCount: z.number(),
});

// create an interface that extends the base schema
interface Category extends z.infer<typeof BaseCategory> {
  subcategories: Category[];
}

// merge the base schema with
// a new Zod schema containing relations
const Category: z.ZodType<Category> = BaseCategory.merge(
  z.object({
    subcategories: z.lazy(() => z.array(Category)),
  })
);
``` -->

### JSON type

If you want to validate any JSON value, you can use the snippet below.

```ts
type Literal = boolean | null | number | string;
type Json = Literal | { [key: string]: Json } | Json[];
const literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);
const jsonSchema: z.ZodType<Json> = z.lazy(() =>
  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])
);

jsonSchema.parse(data);
```

Thanks to [ggoodman](https://github.com/ggoodman) for suggesting this.

### Cyclical objects

Despite supporting recursive schemas, passing cyclical data into Zod will cause an infinite loop.

## Promises

```ts
const numberPromise = z.promise(z.number());
```

"Parsing" works a little differently with promise schemas. Validation happens in two parts:

1. Zod synchronously checks that the input is an instance of Promise (i.e. an object with `.then` and `.catch` methods.).
2. Zod uses `.then` to attach an additional validation step onto the existing Promise. You'll have to use `.catch` on the returned Promise to handle validation failures.

```ts
numberPromise.parse("tuna");
// ZodError: Non-Promise type: string

numberPromise.parse(Promise.resolve("tuna"));
// => Promise<number>

const test = async () => {
  await numberPromise.parse(Promise.resolve("tuna"));
  // ZodError: Non-number type: string

  await numberPromise.parse(Promise.resolve(3.14));
  // => 3.14
};
```

<!-- #### Non-native promise implementations

When "parsing" a promise, Zod checks that the passed value is an object with `.then` and `.catch` methods — that's it. So you should be able to pass non-native Promises (Bluebird, etc) into `z.promise(...).parse` with no trouble. One gotcha: the return type of the parse function will be a _native_ `Promise` , so if you have downstream logic that uses non-standard Promise methods, this won't work. -->

## Instanceof

You can use `z.instanceof` to check that the input is an instance of a class. This is useful to validate inputs against classes that are exported from third-party libraries.

```ts
class Test {
  name: string;
}

const TestSchema = z.instanceof(Test);

const blob: any = "whatever";
TestSchema.parse(new Test()); // passes
TestSchema.parse("blob"); // throws
```

## Function schemas

Zod also lets you define "function schemas". This makes it easy to validate the inputs and outputs of a function without intermixing your validation code and "business logic".

You can create a function schema with `z.function(args, returnType)` .

```ts
const myFunction = z.function();

type myFunction = z.infer<typeof myFunction>;
// => ()=>unknown
```

**Define inputs and output**

```ts
const myFunction = z
  .function()
  .args(z.string(), z.number()) // accepts an arbitrary number of arguments
  .returns(z.boolean());
type myFunction = z.infer<typeof myFunction>;
// => (arg0: string, arg1: number)=>boolean
```

**Extract the input and output schemas**
You can extract the parameters and return type of a function schema.

```ts
myFunction.parameters();
// => ZodTuple<[ZodString, ZodNumber]>

myFunction.returnType();
// => ZodBoolean
```

<!-- `z.function()` accepts two arguments:

* `args: ZodTuple` The first argument is a tuple (created with `z.tuple([...])` and defines the schema of the arguments to your function. If the function doesn't accept arguments, you can pass an empty tuple (`z.tuple([])`).
* `returnType: any Zod schema` The second argument is the function's return type. This can be any Zod schema. -->

> You can use the special `z.void()` option if your function doesn't return anything. This will let Zod properly infer the type of void-returning functions. (Void-returning functions actually return undefined.)

<!--

``` ts
const args = z.tuple([z.string()]);

const returnType = z.number();

const myFunction = z.function(args, returnType);
type myFunction = z.infer<typeof myFunction>;
// => (arg0: string)=>number
``` -->

Function schemas have an `.implement()` method which accepts a function and returns a new function that automatically validates it's inputs and outputs.

```ts
const trimmedLength = z
  .function()
  .args(z.string()) // accepts an arbitrary number of arguments
  .returns(z.number())
  .implement((x) => {
    // TypeScript knows x is a string!
    return x.trim().length;
  });

trimmedLength("sandwich"); // => 8
trimmedLength(" asdf "); // => 4
```

If you only care about validating inputs, that's fine:

```ts
const myFunction = z
  .function()
  .args(z.string())
  .implement((arg) => {
    return [arg.length]; //
  });
myFunction; // (arg: string)=>number[]
```

## Preprocess

Typically Zod operates under a "parse then transform" paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the [.transform docs](#transform).)

But sometimes you want to apply some transform to the input _before_ parsing happens. A common use case: type coercion. Zod enables this with the `z.preprocess()`.

```ts
const castToString = z.preprocess((val) => String(val), z.string());
```

This returns a `ZodEffects` instance. `ZodEffects` is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.

### <hr />

## Common methods

All Zod schemas extend the `ZodType` base class, which provides the following methods.

### `.parse`

`.parse(data:unknown): T`

Given any Zod schema, you can call its `.parse` method to check `data` is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.

> IMPORTANT: In Zod 2 and Zod 1.11+, the value returned by `.parse` is a _deep clone_ of the variable you passed in. This was also the case in zod@1.4 and earlier.

```ts
const stringSchema = z.string();
stringSchema.parse("fish"); // => returns "fish"
stringSchema.parse(12); // throws Error('Non-string type: number');
```

### `.parseAsync`

`.parseAsync(data:unknown): Promise<T>`

If you use asynchronous [refinements](#refine) or [transforms](#transform) (more on those later), you'll need to use `.parseAsync`

```ts
const stringSchema = z.string().refine(async (val) => val.length > 20);
const value = await stringSchema.parseAsync("hello"); // => hello
```

### `.safeParse`

`.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }`

If you don't want Zod to throw errors when validation fails, use `.safeParse`. This method returns an object containing either the successfully parsed data or a ZodError instance containing detailed information about the validation problems.

```ts
stringSchema.safeParse(12);
// => { success: false; error: ZodError }

stringSchema.safeParse("billie");
// => { success: true; data: 'billie' }
```

The result is a _discriminated union_ so you can handle errors very conveniently:

```ts
const result = stringSchema.safeParse("billie");
if (!result.success) {
  // handle error then return
  result.error;
} else {
  // do something
  result.data;
}
```

### `.safeParseAsync`

> Alias: `.spa`

An asynchronous version of `safeParse`.

```ts
await stringSchema.safeParseAsync("billie");
```

For convenience, this has been aliased to `.spa`:

```ts
await stringSchema.spa("billie");
```

### `.refine`

`.refine(validator: (data:T)=>any, params?: RefineParams)`

Zod lets you provide custom validation logic via _refinements_. (For advanced features like creating multiple issues and customizing error codes, see [`.superRefine`](#superrefine).)

Zod was designed to mirror TypeScript as closely as possible. But there are many so-called "refinement types" you may wish to check for that can't be represented in TypeScript's type system. For instance: checking that a number is an integer or that a string is a valid email address.

For example, you can define a custom validation check on _any_ Zod schema with `.refine` :

```ts
const myString = z.string().refine((val) => val.length <= 255, {
  message: "String can't be more than 255 characters",
});
```

> ⚠️ Refinement functions should not throw. Instead they should return a falsy value to signal failure.

#### Arguments

As you can see, `.refine` takes two arguments.

1. The first is the validation function. This function takes one input (of type `T` — the inferred type of the schema) and returns `any`. Any truthy value will pass validation. (Prior to zod@1.6.2 the validation function had to return a boolean.)
2. The second argument accepts some options. You can use this to customize certain error-handling behavior:

```ts
type RefineParams = {
  // override error message
  message?: string;

  // appended to error path
  path?: (string | number)[];

  // params object you can use to customize message
  // in error map
  params?: object;
};
```

For advanced cases, the second argument can also be a function that returns `RefineParams`/

```ts
z.string().refine(
  (val) => val.length > 10,
  (val) => ({ message: `${val} is not more than 10 characters` })
);
```

#### Customize error path

```ts
const passwordForm = z
  .object({
    password: z.string(),
    confirm: z.string(),
  })
  .refine((data) => data.password === data.confirm, {
    message: "Passwords don't match",
    path: ["confirm"], // path of error
  })
  .parse({ password: "asdf", confirm: "qwer" });
```

Because you provided a `path` parameter, the resulting error will be:

```ts
ZodError {
  issues: [{
    "code": "custom",
    "path": [ "confirm" ],
    "message": "Passwords don't match"
  }]
}
```

#### Asynchronous refinements

Refinements can also be async:

```ts
const userId = z.string().refine(async (id) => {
  // verify that ID exists in database
  return true;
});
```

> ⚠️If you use async refinements, you must use the `.parseAsync` method to parse data! Otherwise Zod will throw an error.

#### Relationship to transforms

Transforms and refinements can be interleaved:

```ts
z.string()
  .transform((val) => val.length)
  .refine((val) => val > 25);
```

<!-- Note that the `path` is set to `["confirm"]` , so you can easily display this error underneath the "Confirm password" textbox.


```ts
const allForms = z.object({ passwordForm }).parse({
  passwordForm: {
    password: "asdf",
    confirm: "qwer",
  },
});
```

would result in

```

ZodError {
  issues: [{
    "code": "custom",
    "path": [ "passwordForm", "confirm" ],
    "message": "Passwords don't match"
  }]
}
``` -->

### `.superRefine`

The `.refine` method is actually syntactic sugar atop a more versatile (and verbose) method called `superRefine`. Here's an example:

```ts
const Strings = z.array(z.string()).superRefine((val, ctx) => {
  if (val.length > 3) {
    ctx.addIssue({
      code: z.ZodIssueCode.too_big,
      maximum: 3,
      type: "array",
      inclusive: true,
      message: "Too many items 😡",
    });
  }

  if (val.length !== new Set(val).size) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `No duplicated allowed.`,
    });
  }
});
```

You can add as many issues as you like. If `ctx.addIssue` is NOT called during the execution of the function, validation passes.

Normally refinements always create issues with a `ZodIssueCode.custom` error code, but with `superRefine` you can create any issue of any code. Each issue code is described in detail in the Error Handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md).

#### Abort early

By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to _abort early_ to prevent later refinements from being executed. To achieve this, pass the `fatal` flag to `ctx.addIssue`:

```ts
const Strings = z
  .number()
  .superRefine((val, ctx) => {
    if (val < 10) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "foo",
        fatal: true,
      });
    }
  })
  .superRefine((val, ctx) => {
    if (val !== " ") {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "bar",
      });
    }
  });
```

### `.transform`

`.transform<Out>((val: T) => Out)`

To transform data after parsing, use the `transform` method.

```ts
const stringToNumber = z.string().transform((val) => myString.length);
stringToNumber.parse("string"); // => 6
```

> ⚠️ Transform functions must not throw. Make sure to use refinements before the transform to make sure the input can be parsed by the transform.

#### Chaining order

Note that `stringToNumber` above is an instance of the `ZodEffects` subclass. It is NOT an instance of `ZodString`. If you want to use the built-in methods of `ZodString` (e.g. `.email()`) you must apply those methods _before_ any transforms.

```ts
const emailToDomain = z
  .string()
  .email()
  .transform((val) => val.split("@")[1]);

emailToDomain.parse("colinhacks@example.com"); // => example.com
```

#### Relationship to refinements

Transforms and refinements can be interleaved:

```ts
z.string()
  .transform((val) => val.length)
  .refine((val) => val > 25);
```

#### Async transforms

Transforms can also be async.

```ts
const IdToUser = z
  .string()
  .uuid()
  .transform(async (id) => {
    return await getUserById(id);
  });
```

> ⚠️ If your schema contains asynchronous transforms, you must use .parseAsync() or .safeParseAsync() to parse data. Otherwise Zod will throw an error.

### `.default`

You can use transforms to implement the concept of "default values" in Zod.

```ts
const stringWithDefault = z.string().default("tuna");

stringWithDefault.parse(undefined); // => "tuna"
```

Optionally, you can pass a function into `.default` that will be re-executed whenever a default value needs to be generated:

```ts
const numberWithRandomDefault = z.number().default(Math.random);

numberWithRandomDefault.parse(undefined); // => 0.4413456736055323
numberWithRandomDefault.parse(undefined); // => 0.1871840107401901
numberWithRandomDefault.parse(undefined); // => 0.7223408162401552
```

### `.optional`

A convenience method that returns an optional version of a schema.

```ts
const optionalString = z.string().optional(); // string | undefined

// equivalent to
z.optional(z.string());
```

### `.nullable`

A convenience method that returns an nullable version of a schema.

```ts
const nullableString = z.string().nullable(); // string | null

// equivalent to
z.nullable(z.string());
```

### `.nullish`

A convenience method that returns a "nullish" version of a schema. Nullish schemas will accept both `undefined` and `null`. Read more about the concept of "nullish" [here](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing).

```ts
const nullishString = z.string().nullish(); // string | null | undefined

// equivalent to
z.string().optional().nullable();
```

### `.array`

A convenience method that returns an array schema for the given type:

```ts
const nullableString = z.string().array(); // string[]

// equivalent to
z.array(z.string());
```

### `.promise`

A convenience method for promise types:

```ts
const stringPromise = z.string().promise(); // Promise<string>

// equivalent to
z.promise(z.string());
```

### `.or`

A convenience method for union types.

```ts
z.string().or(z.number()); // string | number

// equivalent to
z.union([z.string(), z.number()]);
```

### `.and`

A convenience method for creating intersection types.

```ts
z.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } & { age: number }

// equivalent to
z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));
```

## Guides and concepts

### Type inference

You can extract the TypeScript type of any schema with `z.infer<typeof mySchema>` .

```ts
const A = z.string();
type A = z.infer<typeof A>; // string

const u: A = 12; // TypeError
const u: A = "asdf"; // compiles
```

**What about transforms?**

In reality each Zod schema internally tracks **two** types: an input and an output. For most schemas (e.g. `z.string()`) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance `z.string().transform(val => val.length)` has an input of `string` and an output of `number`.

You can separately extract the input and output types like so:

```ts
const stringToNumber = z.string().transform((val) => val.length);

// ⚠️ Important: z.infer returns the OUTPUT type!
type input = z.input<typeof stringToNumber>; // string
type output = z.output<typeof stringToNumber>; // number

// equivalent to z.output!
type inferred = z.infer<typeof stringToNumber>; // number
```

### Writing generic functions

When attempting to write a functions that accepts a Zod schemas as an input, it's common to try something like this:

```ts
function makeSchemaOptional<T>(schema: z.ZodType<T>) {
  return schema.optional();
}
```

This approach has some issues. The `schema` variable in this function is typed as an instance of `ZodType`, which is an abstract class that all Zod schemas inherit from. This approach loses type information, namely _which subclass_ the input actually is.

```ts
const arg = makeSchemaOptional(z.string());
arg.unwrap();
```

A better approach is for the generate parameter to refer to _the schema as a whole_.

```ts
function makeSchemaOptional<T extends z.ZodTypeAny>(schema: T) {
  return schema.optional();
}
```

> `ZodTypeAny` is just a shorthand for `ZodType<any, any, any>`, a type that is broad enough to match any Zod schema.

As you can see, `schema` is now fully and properly typed.

```ts
const arg = makeSchemaOptional(z.string());
arg.unwrap(); // ZodString
```

**Restricting valid schemas**

The `ZodType` class has three generic parameters.

```ts
class ZodType<
  Output,
  Def extends ZodTypeDef = ZodTypeDef,
  Input = Output
> { ... }
```

By contraining these in your generic input, you can limit what schemas are allowable as inputs to your function:

```ts
function makeSchemaOptional<T extends z.ZodType<string>>(schema: T) {
  return schema.optional();
}

makeSchemaOptional(z.string());
// works fine

makeSchemaOptional(z.number());
// Error: 'ZodNumber' is not assignable to parameter of type 'ZodType<string, ZodTypeDef, string>'
```

### Error handling

Zod provides a subclass of Error called `ZodError`. ZodErrors contain an `issues` array containing detailed information about the validation problems.

```ts
const data = z.object({ name: z.string() }).safeParse({ name: 12 });

if (!data.success) {
  data.error.issues;
  /* [
      {
        "code": "invalid_type",
        "expected": "string",
        "received": "number",
        "path": [ "name" ],
        "message": "Expected string, received number"
      }
  ] */
}
```

**Error formatting**

You can use the `.format()` method to convert this error into a nested object.

```ts
data.error.format();
/* {
  name: { _errors: [ 'Expected string, received number' ] }
} */
```

For detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md)

## Comparison

There are a handful of other widely-used validation libraries, but all of them have certain design limitations that make for a non-ideal developer experience.

<!-- The table below summarizes the feature differences. Below the table there are more involved discussions of certain alternatives, where necessary. -->

<!-- | Feature                                                                                                                | [Zod](https://github.com/colinhacks) | [Joi](https://github.com/hapijs/joi) | [Yup](https://github.com/jquense/yup) | [io-ts](https://github.com/gcanti/io-ts) | [Runtypes](https://github.com/pelotom/runtypes) | [ow](https://github.com/sindresorhus/ow) | [class-validator](https://github.com/typestack/class-validator) |
| ---------------------------------------------------------------------------------------------------------------------- | :-----------------------------: | :----------------------------------: | :-----------------------------------: | :--------------------------------------: | :---------------------------------------------: | :--------------------------------------: | :-------------------------------------------------------------: |
| <abbr title='Any ability to extract a TypeScript type from a validator instance counts.'>Type inference</abbr>         |               🟢                |                  🔴                  |                  🟢                   |                    🟢                    |                       🟢                        |                    🟢                    |                               🟢                                |
| <abbr title="Yup's inferred types are incorrect in certain cases, see discussion below.">Correct type inference</abbr> |               🟢                |                  🔴                  |                  🔴                   |                    🟢                    |                       🟢                        |                    🟢                    |                               🟢                                |

<abbr title="number, string, boolean, null, undefined">Primitive Types</abbr>
<abbr title="Includes any checks beyond 'Is this a string?', e.g. min/max length, isEmail, isURL, case checking, etc.">String Validation</abbr>
<abbr title="Includes any checks beyond 'Is this a number?', e.g. min/max, isPositive, integer vs float, etc.">Number Validation</abbr>
Dates

Primitive Literals
Object Literals
Tuple Literals
Objects
Arrays
Non-empty arrays
Unions
Optionals
Nullable
Enums
Enum Autocomplete
Intersections
Object Merging
Tuples
Recursive Types
Function Schemas

<abbr title="For instance, Yup allows custom error messages with the syntax yup.number().min(5, 'Number must be more than 5!')">Validation Messages</abbr>
Immutable instances
Type Guards
Validity Checking
Casting
Default Values
Rich Errors
Branded -->

<!-- - Missing object methods: (pick, omit, partial, deepPartial, merge, extend)

* Missing nonempty arrays with proper typing (`[T, ...T[]]`)
* Missing lazy/recursive types
* Missing promise schemas
* Missing function schemas
* Missing union & intersection schemas
* Missing support for parsing cyclical data (maybe)
* Missing error customization -->

### Joi

[https://github.com/hapijs/joi](https://github.com/hapijs/joi)

Doesn't support static type inference 😕

### Yup

[https://github.com/jquense/yup](https://github.com/jquense/yup)

Yup is a full-featured library that was implemented first in vanilla JS, and later rewritten in TypeScript.

Differences

- Supports casting and transforms
- All object fields are optional by default
- Missing object methods: (partial, deepPartial)
<!-- - Missing nonempty arrays with proper typing (`[T, ...T[]]`) -->
- Missing promise schemas
- Missing function schemas
- Missing union & intersection schemas

<!-- ¹Yup has a strange interpretation of the word `required`. Instead of meaning "not undefined", Yup uses it to mean "not empty". So `yup.string().required()` will not accept an empty string, and `yup.array(yup.string()).required()` will not accept an empty array. Instead, Yup us Zod arrays there is a dedicated `.nonempty()` method to indicate this, or you can implement it with a custom refinement. -->

### io-ts

[https://github.com/gcanti/io-ts](https://github.com/gcanti/io-ts)

io-ts is an excellent library by gcanti. The API of io-ts heavily inspired the design of Zod.

In our experience, io-ts prioritizes functional programming purity over developer experience in many cases. This is a valid and admirable design goal, but it makes io-ts particularly hard to integrate into an existing codebase with a more procedural or object-oriented bias. For instance, consider how to define an object with optional properties in io-ts:

```ts
import * as t from "io-ts";

const A = t.type({
  foo: t.string,
});

const B = t.partial({
  bar: t.number,
});

const C = t.intersection([A, B]);

type C = t.TypeOf<typeof C>;
// returns { foo: string; bar?: number | undefined }
```

You must define the required and optional props in separate object validators, pass the optionals through `t.partial` (which marks all properties as optional), then combine them with `t.intersection` .

Consider the equivalent in Zod:

```ts
const C = z.object({
  foo: z.string(),
  bar: z.number().optional(),
});

type C = z.infer<typeof C>;
// returns { foo: string; bar?: number | undefined }
```

This more declarative API makes schema definitions vastly more concise.

`io-ts` also requires the use of gcanti's functional programming library `fp-ts` to parse results and handle errors. This is another fantastic resource for developers looking to keep their codebase strictly functional. But depending on `fp-ts` necessarily comes with a lot of intellectual overhead; a developer has to be familiar with functional programming concepts and the `fp-ts` nomenclature to use the library.

- Supports codecs with serialization & deserialization transforms
- Supports branded types
- Supports advanced functional programming, higher-kinded types, `fp-ts` compatibility
- Missing object methods: (pick, omit, partial, deepPartial, merge, extend)
- Missing nonempty arrays with proper typing (`[T, ...T[]]`)
- Missing promise schemas
- Missing function schemas

### Runtypes

[https://github.com/pelotom/runtypes](https://github.com/pelotom/runtypes)

Good type inference support, but limited options for object type masking (no `.pick` , `.omit` , `.extend` , etc.). No support for `Record` s (their `Record` is equivalent to Zod's `object` ). They DO support branded and readonly types, which Zod does not.

- Supports "pattern matching": computed properties that distribute over unions
- Supports readonly types
- Missing object methods: (deepPartial, merge)
- Missing nonempty arrays with proper typing (`[T, ...T[]]`)
- Missing promise schemas
- Missing error customization

### Ow

[https://github.com/sindresorhus/ow](https://github.com/sindresorhus/ow)

Ow is focused on function input validation. It's a library that makes it easy to express complicated assert statements, but it doesn't let you parse untyped data. They support a much wider variety of types; Zod has a nearly one-to-one mapping with TypeScript's type system, whereas ow lets you validate several highly-specific types out of the box (e.g. `int32Array` , see full list in their README).

If you want to validate function inputs, use function schemas in Zod! It's a much simpler approach that lets you reuse a function type declaration without repeating yourself (namely, copy-pasting a bunch of ow assertions at the beginning of every function). Also Zod lets you validate your return types as well, so you can be sure there won't be any unexpected data passed downstream.

## Changelog

View the changelog at [CHANGELOG.md](CHANGELOG.md)
````

## File: rollup.config.js
````javascript
// rollup.config.js
import typescript from "@rollup/plugin-typescript";

export default [
  {
    input: "src/index.ts",
    output: [
      {
        file: "lib/index.mjs",
        format: "es",
        sourcemap: false,
      },
    ],
    plugins: [
      typescript({
        tsconfig: "tsconfig.esm.json",
        sourceMap: false,
      }),
    ],
  },
];
````

## File: tsconfig.base.json
````json
{
  "compilerOptions": {
    "lib": [
      "es5",
      "es6",
      "es7",
      "esnext",
      "dom"
    ],
    "target": "es2018",
    "removeComments": false,
    "esModuleInterop": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "strict": true,
    "skipLibCheck": true,
    "strictPropertyInitialization": false,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "downlevelIteration": true,
    "isolatedModules": true
  },
  "include": [
    "./src/**/*",
    "./.eslintrc.js"
  ]
}
````

## File: tsconfig.cjs.json
````json
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "lib",
    "declaration": true,
    "declarationMap": false,
    "sourceMap": false
  },
  "exclude": [
    "./src/**/__tests__",
    "./src/playground.ts"
  ]
}
````

## File: tsconfig.esm.json
````json
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "es2015",
    // "outDir": "./lib/esm",
    "declaration": false,
    "declarationMap": false,
    "sourceMap": false
  },
  "exclude": [
    "./src/**/__tests__",
    "./src/playground.ts"
  ]
}
````

## File: tsconfig.json
````json
{
  "extends": "./tsconfig.base.json"
}
````

## File: tsconfig.types.json
````json
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./lib/types",
    "declaration": true,
    "declarationMap": true,
    "emitDeclarationOnly": true
  },
  "exclude": [
    "./src/**/__tests__",
    "./src/playground.ts"
  ]
}
````
